import { Action, Dispatch } from "redux";
import { Channel } from "twilio-chat/lib/channel";
import { Member } from "twilio-chat/lib/member";
import { Message } from "twilio-chat/lib/message";
import { Paginator } from "twilio-chat/lib/interfaces/paginator";
import { User } from "twilio-chat/lib/user";
import { ChatState } from "./ChatState";
export declare type MembersType = Map<string, MemberState>;
/**
 * A state of remote client in a Channel.
 * @typedef {Object} ChatState.MemberState
 * @property {Member} source - Represents the remote client in a Channel. See structure here: {@link https://media.twiliocdn.com/sdk/js/chat/releases/3.2.4/docs/Member.html}
 * @property {string} friendlyName - It represents the friendly name of the remote client.
 * @property {boolean} online - It represents if the member is online or not.
 */
export interface MemberState {
    readonly source: Member;
    readonly friendlyName: string;
    readonly online: boolean;
}
declare type PendingMessage = Pick<Message, "media" | "timestamp" | "channel" | "author" | "index" | "type"> & {
    body: string | null;
    memberSid?: string;
    sid: null;
};
export declare type MessageSource = Message | PendingMessage;
/**
 * An object which represents a state of a single message.
 * @typedef {Object} ChatState.MessageState
 * @property {boolean} isFromMe - Is the message from me.
 * @property {Message} source - Represents the message object. See structure here: {@link https://media.twiliocdn.com/sdk/js/chat/releases/3.2.4/docs/Message.html}
 * @property {boolean} groupWithNext - should the message be grouped with the next message.
 * @property {boolean} groupWithPrevious - should the message be grouped with the previous message.
 * @property {number} index - index of the message within the remote messages array.
 * @property {string} [authorName] - Represents the friendly name of the message author.
 * @property {boolean} [error] - If set to true, the message has failed to be delivered.
 */
export interface MessageState {
    readonly isFromMe: boolean;
    readonly source: MessageSource;
    readonly groupWithNext: boolean;
    readonly groupWithPrevious: boolean;
    readonly index: number;
    readonly authorName?: string;
    readonly isSending?: boolean;
    readonly error?: boolean;
}
/**
 * An object which represents a state of a channel.
 * @typedef {Object} ChatState.ChannelState
 * @property {Paginator} [currentPaginator] Paginator class to request messages on previous or next pages. See structure here: {@link https://media.twiliocdn.com/sdk/js/chat/releases/3.2.4/docs/Paginator.html}
 * @property {number} selectionStart=0 Index of the selection start
 * @property {number} selectionEnd=0 Index of the selection end
 * @property {boolean} isLoadingMessages=false Indicates if messages are currently loading
 * @property {boolean} isLoadingMembers=false Indicates if members are currently loading
 * @property {boolean} isLoadingChannel=false Indicates if channel is currently loading
 * @property {number} lastConsumedMessageIndex=0 Index of the last read message
 * @property {Map<string, ChatState.MemberState>} members Members of the chat
 * @property {ChatState.MessageState[]} messages=Map() Messages in the channel
 * @property {Channel} [source] Reference to the channel. See structure here: {@link https://media.twiliocdn.com/sdk/js/chat/releases/3.2.4/docs/Channel.html}
 * @property {Array.<ChatState.MemberState>} typers Members, who are currently typing a message
 * @property {boolean} errorWhileLoadingChannel=false Indicates if there was an error while loading a channel
 */
export interface ChannelState {
    readonly currentPaginator?: Paginator<Message>;
    readonly inputText: string;
    readonly selectionStart: number;
    readonly selectionEnd: number;
    readonly isLoadingMessages: boolean;
    readonly isLoadingMembers: boolean;
    readonly lastConsumedMessageIndex: number;
    readonly lastConsumedMessageByCurrentUserIndex: number;
    readonly listener?: ChannelListener;
    readonly members: MembersType;
    readonly unconsumedMessages: Array<MessageState>;
    readonly messages: Array<MessageState>;
    readonly pendingMessages: Array<MessageState>;
    readonly source?: Channel;
    readonly typers: Array<MemberState>;
    readonly isLoadingChannel: boolean;
    readonly errorWhileLoadingChannel: boolean;
}
export interface InitChannelPayload {
    channel: Channel;
    identity: string;
    listener: ChannelListener;
}
export declare type ChannelActionPayload = InitChannelPayload | MembersType | Paginator<Message> | Message | MemberState | string;
export interface ChannelAction extends Action {
    payload?: any;
    meta: {
        channelSid: string;
        chatState?: ChatState;
    };
}
export declare const ACTION_ADDED_MESSAGE = "CHANNEL_ADD_MESSAGE";
export declare const ACTION_ADDED_MEMBER = "CHANNEL_ADD_MEMBER";
export declare const ACTION_USER_UPDATED = "CHANNEL_USER_UPDATED";
export declare const ACTION_INIT_CHANNEL = "CHANNEL_INIT";
export declare const ACTION_UNLOAD_CHANNEL = "CHANNEL_UNLOAD";
export declare const ACTION_INIT_CHANNEL_MEMBERS = "CHANNEL_INIT_MEMBERS";
export declare const ACTION_CONSUME_MESSAGE = "ACTION_CONSUME_MESSAGE";
export declare const ACTION_LOAD_CHANNEL_MESSAGES = "CHANNEL_LOAD_MESSAGES";
export declare const ACTION_REMOVED_MESSAGE = "CHANNEL_REMOVE_MESSAGE";
export declare const ACTION_REMOVED_MEMBER = "CHANNEL_REMOVE_MEMBER";
export declare const ACTION_UPDATED_MEMBER = "CHANNEL_UPDATED_MEMBER";
export declare const ACTION_UPDATED_MESSAGE = "CHANNEL_UPDATE_MESSAGE";
export declare const ACTION_TYPING_STARTED = "CHANNEL_TYPING_STARTED";
export declare const ACTION_TYPING_ENDED = "CHANNEL_TYPING_ENDED";
export declare const ACTION_UPDATE_CHANNEL = "CHANNEL_UPDATE";
export declare const ACTION_LOAD_CHANNEL = "CHANNEL_LOAD";
export declare const ACTION_ADD_PENDING_MEDIA_MESSAGE = "ACTION_ADD_PENDING_MEDIA_MESSAGE";
export declare const ACTION_REMOVE_PENDING_MEDIA_MESSAGE = "ACTION_REMOVE_PENDING_MEDIA_MESSAGE";
export declare const ACTION_MEDIA_MESSAGE_REJECTED = "ACTION_MEDIA_MESSAGE_REJECTED";
export declare function reduce(state: ChannelState, action: ChannelAction): ChannelState;
export declare class Actions {
    private static readonly MESSAGE_LOAD_COUNT;
    private static _dispatcher;
    static get dispatcher(): Dispatch<any>;
    static set dispatcher(dispatcher: Dispatch<any>);
    static dispatchChannelAction(sid: string, type: string, payload: any, chatState?: ChatState): void;
    static init(channel: Channel): Promise<void>;
    static unload(channelSid: string): void;
    static loadMessagesFromHistory(channel: ChannelState): false | Promise<void>;
    private static loadUserDescriptorForMissingMembers;
    static deprecatedSetInputText(channel: ChannelState, body: string, selectionStart?: number, selectionEnd?: number): void;
    static updateLastConsumedMessageIndex(channel: ChannelState, newIndex: number): void;
    static removeAllListeners(): void;
    static initWithChannelSid(sid: string): void;
    static addPendingMessage(file: File, channel: Channel): void;
    static removePendingMessage(file: File, channel: Channel): void;
    static rejectMediaMessage(file: File, channel: Channel): void;
    private static getMediaFromFile;
}
export declare class ChannelListener {
    private _channel;
    private _listening;
    private _users;
    constructor(channel: Channel);
    start(): void;
    stop(): void;
    startListeningUser(user: User): void;
    stopListeningUser(user: User): void;
    private dispatchMessageOrMemberAction;
    private handleMessageAdded;
    private handleMessageUpdated;
    private handleMessageRemoved;
    private handleMemberJoined;
    private handleMemberLeft;
    private handleMemberUpdated;
    private handleTypingStarted;
    private handleTypingEnded;
    private handleUserUpdated;
    private handleChannelUpdated;
    private showNewMessageNotification;
    isListening(): boolean;
}
export declare class ChannelHelper {
    static isUserMemberOfChannel(channel: ChannelState): boolean;
}
export {};
