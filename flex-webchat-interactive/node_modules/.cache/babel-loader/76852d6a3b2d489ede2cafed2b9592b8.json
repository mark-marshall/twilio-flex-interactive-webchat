{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createClass = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar logger_1 = require(\"../logger\");\n\nvar twilsockerror_1 = require(\"../error/twilsockerror\");\n\nvar twilsockupstreamerror_1 = require(\"../error/twilsockupstreamerror\");\n\nvar Messages = require(\"../protocol/messages\");\n\nvar transportunavailableerror_1 = require(\"../error/transportunavailableerror\");\n\nvar REQUEST_TIMEOUT = 20000;\n\nfunction isHttpSuccess(code) {\n  return code >= 200 && code < 300;\n}\n\nfunction isHttpReply(packet) {\n  return packet && packet.header && packet.header.http_status;\n}\n\nvar Request = function Request() {\n  _classCallCheck(this, Request);\n};\n\nfunction parseUri(uri) {\n  var match = uri.match(/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)(\\/[^?#]*)(\\?[^#]*|)(#.*|)$/);\n\n  if (match) {\n    var uriStruct = {\n      protocol: match[1],\n      host: match[2],\n      hostname: match[3],\n      port: match[4],\n      pathname: match[5],\n      search: match[6],\n      hash: match[7],\n      params: null\n    };\n\n    if (uriStruct.search.length > 0) {\n      var paramsString = uriStruct.search.substring(1);\n      uriStruct.params = paramsString.split('&').map(function (el) {\n        return el.split('=');\n      }).reduce(function (prev, curr) {\n        if (!prev.hasOwnProperty(curr[0])) {\n          prev[curr[0]] = curr[1];\n        } else if (Array.isArray(prev[curr[0]])) {\n          prev[curr[0]].push(curr[1]);\n        } else {\n          prev[curr[0]] = [prev[curr[0]], curr[1]];\n        }\n\n        return prev;\n      }, {});\n    }\n\n    return uriStruct;\n  }\n\n  throw new twilsockerror_1.TwilsockError('Incorrect URI: ' + uri);\n}\n\nfunction twilsockAddress(method, uri) {\n  var parsedUri = parseUri(uri);\n  var to = {\n    method: method,\n    host: parsedUri.host,\n    path: parsedUri.pathname\n  };\n\n  if (parsedUri.params) {\n    to.params = parsedUri.params;\n  }\n\n  return to;\n}\n\nfunction twilsockParams(method, uri, headers, body, grant) {\n  return {\n    to: twilsockAddress(method, uri),\n    headers: headers,\n    body: body,\n    grant: grant\n  };\n}\n\nvar Upstream = /*#__PURE__*/function () {\n  function Upstream(transport, twilsock, config) {\n    _classCallCheck(this, Upstream);\n\n    this.config = config;\n    this.transport = transport;\n    this.pendingMessages = [];\n    this.twilsock = twilsock;\n  }\n\n  _createClass(Upstream, [{\n    key: \"saveMessage\",\n    value: function saveMessage(message) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        var requestDescriptor = {\n          message: message,\n          resolve: resolve,\n          reject: reject,\n          alreadyRejected: false,\n          timeout: setTimeout(function () {\n            logger_1.log.debug('request is timed out');\n            reject(new twilsockerror_1.TwilsockError(\"request '\".concat(message.to.method, \"' to '\").concat(message.to.host, \"' timed out\")));\n            requestDescriptor.alreadyRejected = true;\n          }, REQUEST_TIMEOUT)\n        };\n\n        _this.pendingMessages.push(requestDescriptor);\n      });\n    }\n  }, {\n    key: \"sendPendingMessages\",\n    value: function sendPendingMessages() {\n      var _this2 = this;\n\n      var _loop = function _loop() {\n        var request = _this2.pendingMessages[0]; // Do not send message if we've rejected its promise already\n\n        if (!request.alreadyRejected) {\n          try {\n            var message = request.message;\n\n            _this2.actualSend(message).then(function (response) {\n              return request.resolve(response);\n            }).catch(function (e) {\n              return request.reject(e);\n            });\n\n            clearTimeout(request.timeout);\n          } catch (e) {\n            logger_1.log.debug('Failed to send pending message', e);\n            return \"break\";\n          }\n        }\n\n        _this2.pendingMessages.splice(0, 1);\n      };\n\n      while (this.pendingMessages.length) {\n        var _ret = _loop();\n\n        if (_ret === \"break\") break;\n      }\n    }\n  }, {\n    key: \"rejectPendingMessages\",\n    value: function rejectPendingMessages() {\n      var _this3 = this;\n\n      this.pendingMessages.forEach(function (message) {\n        message.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + _this3.twilsock.getTerminationReason));\n        clearTimeout(message.timeout);\n      });\n      this.pendingMessages.splice(0, this.pendingMessages.length);\n    }\n  }, {\n    key: \"actualSend\",\n    value: function () {\n      var _actualSend = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(message) {\n        var address, headers, body, grant, httpRequest, upstreamMessage, reply;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                address = message.to;\n                headers = message.headers;\n                body = message.body;\n                grant = message.grant ? message.grant : this.config.activeGrant;\n                httpRequest = {\n                  host: address.host,\n                  path: address.path,\n                  method: address.method,\n                  params: address.params,\n                  headers: headers\n                };\n                upstreamMessage = new Messages.Message(grant, headers['Content-Type'] || 'application/json', httpRequest);\n                _context.next = 8;\n                return this.transport.sendWithReply(upstreamMessage, body);\n\n              case 8:\n                reply = _context.sent;\n\n                if (!(isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code))) {\n                  _context.next = 11;\n                  break;\n                }\n\n                throw new twilsockupstreamerror_1.TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);\n\n              case 11:\n                return _context.abrupt(\"return\", {\n                  status: reply.header.http_status,\n                  headers: reply.header.http_headers,\n                  body: reply.body\n                });\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function actualSend(_x) {\n        return _actualSend.apply(this, arguments);\n      }\n\n      return actualSend;\n    }()\n    /**\n     * Send an upstream message\n     * @param {string} method The upstream method\n     * @param {string} url URL to send the message to\n     * @param {object} [headers] The message headers\n     * @param {any} [body] The message body\n     * @param {string} [grant] The product grant\n     * @returns {Promise<Result>} Result from remote side\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(method, url) {\n      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var body = arguments.length > 3 ? arguments[3] : undefined;\n      var grant = arguments.length > 4 ? arguments[4] : undefined;\n\n      if (this.twilsock.isTerminalState) {\n        return Promise.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\n      }\n\n      var twilsockMessage = twilsockParams(method, url, headers, body, grant);\n\n      if (!this.twilsock.isConnected) {\n        return this.saveMessage(twilsockMessage);\n      }\n\n      return this.actualSend(twilsockMessage);\n    }\n  }]);\n\n  return Upstream;\n}();\n\nexports.Upstream = Upstream;","map":null,"metadata":{},"sourceType":"script"}