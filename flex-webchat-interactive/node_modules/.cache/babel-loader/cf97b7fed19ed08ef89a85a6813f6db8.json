{"ast":null,"code":"export function getTextFieldAriaText(rawValue, utils) {\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  return rawValue && utils.isValid(utils.date(rawValue)) ? \"Choose date, selected date is \".concat(utils.format(utils.date(rawValue), 'fullDate')) : 'Choose date';\n}\nexport var getDisplayDate = function getDisplayDate(utils, value, inputFormat) {\n  var date = utils.date(value);\n  var isEmpty = value === null;\n\n  if (isEmpty) {\n    return '';\n  }\n\n  return utils.isValid(date) ? utils.formatByString( // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nexport function pick12hOr24hFormat(userFormat, ampm, formats) {\n  if (userFormat) {\n    return userFormat;\n  }\n\n  if (typeof ampm === 'undefined') {\n    return formats.localized;\n  }\n\n  return ampm ? formats['12h'] : formats['24h'];\n}\nvar MASK_USER_INPUT_SYMBOL = '_';\nvar staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nvar staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nexport function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  var formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  var inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  var inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  var isMaskValid = inferredFormatPatternWith2Digits === mask && inferredFormatPatternWith1Digits === mask;\n\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    console.warn(\"The mask \\\"\".concat(mask, \"\\\" you passed is not valid for the format used \").concat(format, \". Falling down to uncontrolled not-masked input.\"));\n  }\n\n  return isMaskValid;\n}\nexport var maskedDateFormatter = function maskedDateFormatter(mask, acceptRegexp) {\n  return function (value) {\n    return value.split('').map(function (char, i) {\n      acceptRegexp.lastIndex = 0;\n\n      if (i > mask.length - 1) {\n        return '';\n      }\n\n      var maskChar = mask[i];\n      var nextMaskChar = mask[i + 1];\n      var acceptedChar = acceptRegexp.test(char) ? char : '';\n      var formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n\n      if (i === value.length - 1 && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n        // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n        return formattedChar ? formattedChar + nextMaskChar : '';\n      }\n\n      return formattedChar;\n    }).join('');\n  };\n};","map":null,"metadata":{},"sourceType":"module"}