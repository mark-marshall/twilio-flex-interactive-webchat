{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.diffAny = exports.diffObjects = exports.diffArrays = exports.intersection = exports.subtract = exports.isDestructive = void 0;\n\nvar equal_1 = require(\"./equal\");\n\nvar util_1 = require(\"./util\");\n\nfunction isDestructive(_a) {\n  var op = _a.op;\n  return op === 'remove' || op === 'replace' || op === 'copy' || op === 'move';\n}\n\nexports.isDestructive = isDestructive;\n/**\nList the keys in `minuend` that are not in `subtrahend`.\n\nA key is only considered if it is both 1) an own-property (o.hasOwnProperty(k))\nof the object, and 2) has a value that is not undefined. This is to match JSON\nsemantics, where JSON object serialization drops keys with undefined values.\n\n@param minuend Object of interest\n@param subtrahend Object of comparison\n@returns Array of keys that are in `minuend` but not in `subtrahend`.\n*/\n\nfunction subtract(minuend, subtrahend) {\n  // initialize empty object; we only care about the keys, the values can be anything\n  var obj = {}; // build up obj with all the properties of minuend\n\n  for (var add_key in minuend) {\n    if (util_1.hasOwnProperty.call(minuend, add_key) && minuend[add_key] !== undefined) {\n      obj[add_key] = 1;\n    }\n  } // now delete all the properties of subtrahend from obj\n  // (deleting a missing key has no effect)\n\n\n  for (var del_key in subtrahend) {\n    if (util_1.hasOwnProperty.call(subtrahend, del_key) && subtrahend[del_key] !== undefined) {\n      delete obj[del_key];\n    }\n  } // finally, extract whatever keys remain in obj\n\n\n  return Object.keys(obj);\n}\n\nexports.subtract = subtract;\n/**\nList the keys that shared by all `objects`.\n\nThe semantics of what constitutes a \"key\" is described in {@link subtract}.\n\n@param objects Array of objects to compare\n@returns Array of keys that are in (\"own-properties\" of) every object in `objects`.\n*/\n\nfunction intersection(objects) {\n  var length = objects.length; // prepare empty counter to keep track of how many objects each key occurred in\n\n  var counter = {}; // go through each object and increment the counter for each key in that object\n\n  for (var i = 0; i < length; i++) {\n    var object = objects[i];\n\n    for (var key in object) {\n      if (util_1.hasOwnProperty.call(object, key) && object[key] !== undefined) {\n        counter[key] = (counter[key] || 0) + 1;\n      }\n    }\n  } // now delete all keys from the counter that were not seen in every object\n\n\n  for (var key in counter) {\n    if (counter[key] < length) {\n      delete counter[key];\n    }\n  } // finally, extract whatever keys remain in the counter\n\n\n  return Object.keys(counter);\n}\n\nexports.intersection = intersection;\n\nfunction isArrayAdd(array_operation) {\n  return array_operation.op === 'add';\n}\n\nfunction isArrayRemove(array_operation) {\n  return array_operation.op === 'remove';\n}\n\nfunction appendArrayOperation(base, operation) {\n  return {\n    // the new operation must be pushed on the end\n    operations: base.operations.concat(operation),\n    cost: base.cost + 1\n  };\n}\n/**\nCalculate the shortest sequence of operations to get from `input` to `output`,\nusing a dynamic programming implementation of the Levenshtein distance algorithm.\n\nTo get from the input ABC to the output AZ we could just delete all the input\nand say \"insert A, insert Z\" and be done with it. That's what we do if the\ninput is empty. But we can be smarter.\n\n          output\n               A   Z\n               -   -\n          [0]  1   2\ninput A |  1  [0]  1\n      B |  2  [1]  1\n      C |  3   2  [2]\n\n1) start at 0,0 (+0)\n2) keep A (+0)\n3) remove B (+1)\n4) replace C with Z (+1)\n\nIf the `input` (source) is empty, they'll all be in the top row, resulting in an\narray of 'add' operations.\nIf the `output` (target) is empty, everything will be in the left column,\nresulting in an array of 'remove' operations.\n\n@returns A list of add/remove/replace operations.\n*/\n\n\nfunction diffArrays(input, output, ptr, diff) {\n  if (diff === void 0) {\n    diff = diffAny;\n  } // set up cost matrix (very simple initialization: just a map)\n\n\n  var memo = {\n    '0,0': {\n      operations: [],\n      cost: 0\n    }\n  };\n  /**\n  Calculate the cheapest sequence of operations required to get from\n  input.slice(0, i) to output.slice(0, j).\n  There may be other valid sequences with the same cost, but none cheaper.\n     @param i The row in the layout above\n  @param j The column in the layout above\n  @returns An object containing a list of operations, along with the total cost\n           of applying them (+1 for each add/remove/replace operation)\n  */\n\n  function dist(i, j) {\n    // memoized\n    var memo_key = i + \",\" + j;\n    var memoized = memo[memo_key];\n\n    if (memoized === undefined) {\n      if (i > 0 && j > 0 && equal_1.compare(input[i - 1], output[j - 1])) {\n        // equal (no operations => no cost)\n        memoized = dist(i - 1, j - 1);\n      } else {\n        var alternatives = [];\n\n        if (i > 0) {\n          // NOT topmost row\n          var remove_base = dist(i - 1, j);\n          var remove_operation = {\n            op: 'remove',\n            index: i - 1\n          };\n          alternatives.push(appendArrayOperation(remove_base, remove_operation));\n        }\n\n        if (j > 0) {\n          // NOT leftmost column\n          var add_base = dist(i, j - 1);\n          var add_operation = {\n            op: 'add',\n            index: i - 1,\n            value: output[j - 1]\n          };\n          alternatives.push(appendArrayOperation(add_base, add_operation));\n        }\n\n        if (i > 0 && j > 0) {\n          // TABLE MIDDLE\n          // supposing we replaced it, compute the rest of the costs:\n          var replace_base = dist(i - 1, j - 1); // okay, the general plan is to replace it, but we can be smarter,\n          // recursing into the structure and replacing only part of it if\n          // possible, but to do so we'll need the original value\n\n          var replace_operation = {\n            op: 'replace',\n            index: i - 1,\n            original: input[i - 1],\n            value: output[j - 1]\n          };\n          alternatives.push(appendArrayOperation(replace_base, replace_operation));\n        } // the only other case, i === 0 && j === 0, has already been memoized\n        // the meat of the algorithm:\n        // sort by cost to find the lowest one (might be several ties for lowest)\n        // [4, 6, 7, 1, 2].sort((a, b) => a - b) -> [ 1, 2, 4, 6, 7 ]\n\n\n        var best = alternatives.sort(function (a, b) {\n          return a.cost - b.cost;\n        })[0];\n        memoized = best;\n      }\n\n      memo[memo_key] = memoized;\n    }\n\n    return memoized;\n  } // handle weird objects masquerading as Arrays that don't have proper length\n  // properties by using 0 for everything but positive numbers\n\n\n  var input_length = isNaN(input.length) || input.length <= 0 ? 0 : input.length;\n  var output_length = isNaN(output.length) || output.length <= 0 ? 0 : output.length;\n  var array_operations = dist(input_length, output_length).operations;\n  var padded_operations = array_operations.reduce(function (_a, array_operation) {\n    var operations = _a[0],\n        padding = _a[1];\n\n    if (isArrayAdd(array_operation)) {\n      var padded_index = array_operation.index + 1 + padding;\n      var index_token = padded_index < input_length + padding ? String(padded_index) : '-';\n      var operation = {\n        op: array_operation.op,\n        path: ptr.add(index_token).toString(),\n        value: array_operation.value\n      }; // padding++ // maybe only if array_operation.index > -1 ?\n\n      return [operations.concat(operation), padding + 1];\n    } else if (isArrayRemove(array_operation)) {\n      var operation = {\n        op: array_operation.op,\n        path: ptr.add(String(array_operation.index + padding)).toString()\n      }; // padding--\n\n      return [operations.concat(operation), padding - 1];\n    } else {\n      // replace\n      var replace_ptr = ptr.add(String(array_operation.index + padding));\n      var replace_operations = diff(array_operation.original, array_operation.value, replace_ptr);\n      return [operations.concat.apply(operations, replace_operations), padding];\n    }\n  }, [[], 0])[0];\n  return padded_operations;\n}\n\nexports.diffArrays = diffArrays;\n\nfunction diffObjects(input, output, ptr, diff) {\n  if (diff === void 0) {\n    diff = diffAny;\n  } // if a key is in input but not output -> remove it\n\n\n  var operations = [];\n  subtract(input, output).forEach(function (key) {\n    operations.push({\n      op: 'remove',\n      path: ptr.add(key).toString()\n    });\n  }); // if a key is in output but not input -> add it\n\n  subtract(output, input).forEach(function (key) {\n    operations.push({\n      op: 'add',\n      path: ptr.add(key).toString(),\n      value: output[key]\n    });\n  }); // if a key is in both, diff it recursively\n\n  intersection([input, output]).forEach(function (key) {\n    operations.push.apply(operations, diff(input[key], output[key], ptr.add(key)));\n  });\n  return operations;\n}\n\nexports.diffObjects = diffObjects;\n/**\n`diffAny()` returns an empty array if `input` and `output` are materially equal\n(i.e., would produce equivalent JSON); otherwise it produces an array of patches\nthat would transform `input` into `output`.\n*/\n\nfunction diffAny(input, output, ptr, diff) {\n  if (diff === void 0) {\n    diff = diffAny;\n  } // strict equality handles literals, numbers, and strings (a sufficient but not necessary cause)\n\n\n  if (input === output) {\n    return [];\n  }\n\n  var input_type = util_1.objectType(input);\n  var output_type = util_1.objectType(output);\n\n  if (input_type == 'array' && output_type == 'array') {\n    return diffArrays(input, output, ptr, diff);\n  }\n\n  if (input_type == 'object' && output_type == 'object') {\n    return diffObjects(input, output, ptr, diff);\n  } // at this point we know that input and output are materially different;\n  // could be array -> object, object -> array, boolean -> undefined,\n  // number -> string, or some other combination, but nothing that can be split\n  // up into multiple patches: so `output` must replace `input` wholesale.\n\n\n  return [{\n    op: 'replace',\n    path: ptr.toString(),\n    value: output\n  }];\n}\n\nexports.diffAny = diffAny;","map":null,"metadata":{},"sourceType":"script"}