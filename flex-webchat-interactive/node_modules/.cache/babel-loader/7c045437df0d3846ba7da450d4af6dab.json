{"ast":null,"code":"import _slicedToArray from \"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nexport var findClosestEnabledDate = function findClosestEnabledDate(_ref) {\n  var date = _ref.date,\n      disableFuture = _ref.disableFuture,\n      disablePast = _ref.disablePast,\n      maxDate = _ref.maxDate,\n      minDate = _ref.minDate,\n      shouldDisableDate = _ref.shouldDisableDate,\n      utils = _ref.utils;\n  var today = utils.startOfDay(utils.date());\n\n  if (disablePast && utils.isBefore(minDate, today)) {\n    minDate = today;\n  }\n\n  if (disableFuture && utils.isAfter(maxDate, today)) {\n    maxDate = today;\n  }\n\n  var forward = date;\n  var backward = date;\n\n  if (utils.isBefore(date, minDate)) {\n    forward = utils.date(minDate);\n    backward = null;\n  }\n\n  if (utils.isAfter(date, maxDate)) {\n    if (backward) {\n      backward = utils.date(maxDate);\n    }\n\n    forward = null;\n  }\n\n  while (forward || backward) {\n    if (forward && utils.isAfter(forward, maxDate)) {\n      forward = null;\n    }\n\n    if (backward && utils.isBefore(backward, minDate)) {\n      backward = null;\n    }\n\n    if (forward) {\n      if (!shouldDisableDate(forward)) {\n        return forward;\n      }\n\n      forward = utils.addDays(forward, 1);\n    }\n\n    if (backward) {\n      if (!shouldDisableDate(backward)) {\n        return backward;\n      }\n\n      backward = utils.addDays(backward, -1);\n    }\n  }\n\n  return today;\n};\nexport function parsePickerInputValue(utils, value) {\n  var parsedValue = utils.date(value);\n  return utils.isValid(parsedValue) ? parsedValue : null;\n}\nexport function parseRangeInputValue(utils) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [null, null];\n  return value.map(function (date) {\n    return !utils.isValid(date) || date === null ? null : utils.startOfDay(utils.date(date));\n  });\n}\nexport var isRangeValid = function isRangeValid(utils, range) {\n  return Boolean(range && range[0] && range[1] && !utils.isBefore(range[1], range[0]));\n};\nexport var isWithinRange = function isWithinRange(utils, day, range) {\n  return isRangeValid(utils, range) && utils.isWithinRange(day, range);\n};\nexport var isStartOfRange = function isStartOfRange(utils, day, range) {\n  return isRangeValid(utils, range) && utils.isSameDay(day, range[0]);\n};\nexport var isEndOfRange = function isEndOfRange(utils, day, range) {\n  return isRangeValid(utils, range) && utils.isSameDay(day, range[1]);\n};\nexport var validateDate = function validateDate(utils, value, _ref2) {\n  var disablePast = _ref2.disablePast,\n      disableFuture = _ref2.disableFuture,\n      minDate = _ref2.minDate,\n      maxDate = _ref2.maxDate,\n      shouldDisableDate = _ref2.shouldDisableDate;\n  var now = utils.date();\n  var date = utils.date(value);\n\n  if (date === null) {\n    return null;\n  }\n\n  switch (true) {\n    case !utils.isValid(value):\n      return 'invalidDate';\n\n    case Boolean(shouldDisableDate && shouldDisableDate(date)):\n      return 'shouldDisableDate';\n\n    case Boolean(disableFuture && utils.isAfterDay(date, now)):\n      return 'disableFuture';\n\n    case Boolean(disablePast && utils.isBeforeDay(date, now)):\n      return 'disablePast';\n\n    case Boolean(minDate && utils.isBeforeDay(date, minDate)):\n      return 'minDate';\n\n    case Boolean(maxDate && utils.isAfterDay(date, maxDate)):\n      return 'maxDate';\n\n    default:\n      return null;\n  }\n};\nexport var validateDateRange = function validateDateRange(utils, value, dateValidationProps) {\n  var _value = _slicedToArray(value, 2),\n      start = _value[0],\n      end = _value[1]; // for partial input\n\n\n  if (start === null || end === null) {\n    return [null, null];\n  }\n\n  var dateValidations = [validateDate(utils, start, dateValidationProps), validateDate(utils, end, dateValidationProps)];\n\n  if (dateValidations[0] || dateValidations[1]) {\n    return dateValidations;\n  }\n\n  if (!isRangeValid(utils, [utils.date(start), utils.date(end)])) {\n    return ['invalidRange', 'invalidRange'];\n  }\n\n  return [null, null];\n};","map":null,"metadata":{},"sourceType":"module"}