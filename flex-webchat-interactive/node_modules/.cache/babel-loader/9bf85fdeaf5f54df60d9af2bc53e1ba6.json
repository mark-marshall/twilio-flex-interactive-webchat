{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createClass = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar logger_1 = require(\"./logger\");\n\nvar configuration_1 = require(\"./configuration\");\n\nvar twilsock_1 = require(\"./twilsock\");\n\nvar packetinterface_1 = require(\"./packetinterface\");\n\nvar websocketchannel_1 = require(\"./websocketchannel\");\n\nvar registrations_1 = require(\"./services/registrations\");\n\nvar upstream_1 = require(\"./services/upstream\");\n\nvar deferred_1 = require(\"./deferred\");\n\nvar twilsockerror_1 = require(\"./error/twilsockerror\");\n\nvar offlinestorage_1 = require(\"./offlinestorage\");\n\nvar tokenStorage_1 = require(\"./tokenStorage\");\n\nvar telemetrytracker_1 = require(\"./services/telemetrytracker\");\n\nvar TelemetryEvents = function TelemetryEvents() {\n  _classCallCheck(this, TelemetryEvents);\n};\n\nexports.TelemetryEvents = TelemetryEvents;\nTelemetryEvents.TWILSOCK_CONNECT = 'twilsock.sdk.connect'; // establish WebSocket connection (with WebSocket handshake finished)\n\nTelemetryEvents.TWILSOCK_INIT = 'twilsock.sdk.init'; // send \"init\" message and receive reply\n\n/**\n * @alias Twilsock\n * @classdesc Client library for the Twilsock service\n * It allows to recevie service-generated updates as well as bi-directional transport\n * @fires Twilsock#message\n * @fires Twilsock#connected\n * @fires Twilsock#disconnected\n * @fires Twilsock#tokenAboutToExpire\n * @fires Twilsock#stateChanged\n * @fires Twilsock#connectionError\n */\n\nvar TwilsockClient = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(TwilsockClient, _events_1$EventEmitte);\n\n  /**\n   * @param {string} token Twilio access token\n   * @param {string} productId Product identifier. Should be the same as a grant name in token\n   */\n  function TwilsockClient(token, productId) {\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, TwilsockClient);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TwilsockClient).call(this));\n    _this.offlineStorageDeferred = new deferred_1.Deferred();\n    options.continuationToken = options.continuationToken ? options.continuationToken : tokenStorage_1.TokenStorage.getStoredToken(productId);\n    var config = _this.config = new configuration_1.Configuration(token, productId, options);\n    logger_1.log.setLevel(config.logLevel);\n    var websocket = new websocketchannel_1.WebSocketChannel(config.url);\n    var transport = options.transport ? options.transport : new packetinterface_1.PacketInterface(websocket, config);\n    _this.channel = options.channel ? options.channel : new twilsock_1.TwilsockImpl(websocket, transport, config);\n    _this.registrations = options.registrations ? options.registrations : new registrations_1.Registrations(transport);\n    _this.upstream = new upstream_1.Upstream(transport, _this.channel, config); // Send telemetry only when connected and initialised\n\n    _this.telemetryTracker = new telemetrytracker_1.TelemetryTracker(config, transport);\n\n    _this.channel.on('initialized', function () {\n      return _this.telemetryTracker.canSendTelemetry = true;\n    });\n\n    websocket.on('disconnected', function () {\n      return _this.telemetryTracker.canSendTelemetry = false;\n    });\n\n    _this.registrations.on('registered', function (id) {\n      return _this.emit('registered', id);\n    });\n\n    _this.channel.on('message', function (type, message) {\n      return setTimeout(function () {\n        return _this.emit('message', type, message);\n      }, 0);\n    });\n\n    _this.channel.on('stateChanged', function (state) {\n      return setTimeout(function () {\n        return _this.emit('stateChanged', state);\n      }, 0);\n    });\n\n    _this.channel.on('connectionError', function (connectionError) {\n      return setTimeout(function () {\n        return _this.emit('connectionError', connectionError);\n      }, 0);\n    });\n\n    _this.channel.on('tokenAboutToExpire', function () {\n      return setTimeout(function () {\n        return _this.emit('tokenAboutToExpire');\n      }, 0);\n    });\n\n    _this.channel.on('tokenExpired', function () {\n      return setTimeout(function () {\n        return _this.emit('tokenExpired');\n      }, 0);\n    });\n\n    _this.channel.on('connected', function () {\n      return _this.registrations.updateRegistrations();\n    });\n\n    _this.channel.on('connected', function () {\n      return _this.upstream.sendPendingMessages();\n    });\n\n    _this.channel.on('connected', function () {\n      return setTimeout(function () {\n        return _this.emit('connected');\n      }, 0);\n    }); // Twilsock telemetry events\n\n\n    _this.channel.on('beforeConnect', function () {\n      return _this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Establish WebSocket connection', '', new Date()), TelemetryEvents.TWILSOCK_CONNECT, telemetrytracker_1.TelemetryPoint.Start);\n    });\n\n    _this.channel.on('connected', function () {\n      return _this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Establish WebSocket connection', '', new Date(), new Date()), TelemetryEvents.TWILSOCK_CONNECT, telemetrytracker_1.TelemetryPoint.End);\n    });\n\n    _this.channel.on('beforeSendInit', function () {\n      return _this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Send Twilsock init', '', new Date()), TelemetryEvents.TWILSOCK_INIT, telemetrytracker_1.TelemetryPoint.Start);\n    });\n\n    _this.channel.on('initialized', function () {\n      return _this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Send Twilsock init', 'Succeeded', new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, telemetrytracker_1.TelemetryPoint.End);\n    });\n\n    _this.channel.on('sendInitFailed', function () {\n      return _this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Send Twilsock init', 'Failed', new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, telemetrytracker_1.TelemetryPoint.End);\n    });\n\n    _this.channel.on('initialized', function (initReply) {\n      _this.handleStorageId(productId, initReply);\n\n      tokenStorage_1.TokenStorage.storeToken(initReply.continuationToken, productId);\n      setTimeout(function () {\n        return _this.emit('initialized', initReply);\n      }, 0);\n    });\n\n    _this.channel.on('disconnected', function () {\n      return setTimeout(function () {\n        return _this.emit('disconnected');\n      }, 0);\n    });\n\n    _this.channel.on('disconnected', function () {\n      return _this.upstream.rejectPendingMessages();\n    });\n\n    _this.channel.on('disconnected', function () {\n      return _this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError('Client disconnected'));\n    });\n\n    _this.offlineStorageDeferred.promise.catch(function () {});\n\n    return _this;\n  }\n\n  _createClass(TwilsockClient, [{\n    key: \"emit\",\n    value: function emit(event) {\n      var _get2;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      logger_1.log.debug(\"Emitting \".concat(event.toString(), \"(\").concat(args.map(function (a) {\n        return JSON.stringify(a);\n      }).join(', '), \")\"));\n      return (_get2 = _get(_getPrototypeOf(TwilsockClient.prototype), \"emit\", this)).call.apply(_get2, [this, event].concat(args));\n    }\n  }, {\n    key: \"handleStorageId\",\n    value: function handleStorageId(productId, initReply) {\n      if (!initReply.offlineStorage) {\n        this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError('No offline storage id'));\n      } else if (initReply.offlineStorage.hasOwnProperty(productId)) {\n        try {\n          this.offlineStorageDeferred.set(offlinestorage_1.OfflineProductStorage.create(initReply.offlineStorage[productId]));\n          logger_1.log.debug(\"Offline storage for '\".concat(productId, \"' product: \").concat(JSON.stringify(initReply.offlineStorage[productId]), \".\"));\n        } catch (e) {\n          this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError(\"Failed to parse offline storage for \".concat(productId, \" \").concat(JSON.stringify(initReply.offlineStorage[productId]), \". \").concat(e, \".\")));\n        }\n      } else {\n        this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError(\"No offline storage id for '\".concat(productId, \"' product: \").concat(JSON.stringify(initReply.offlineStorage))));\n      }\n    }\n    /**\n     * Get offline storage ID\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"storageId\",\n    value: function storageId() {\n      return this.offlineStorageDeferred.promise;\n    }\n    /**\n     * Indicates if twilsock is connected now\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"updateToken\",\n\n    /**\n     * Update token\n     * @param {String} token\n     * @returns {Promise}\n     */\n    value: function () {\n      var _updateToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(token) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger_1.log.trace(\"updating token '\".concat(token, \"'\"));\n\n                if (!(this.config.token === token)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 3:\n                this.config.updateToken(token);\n                return _context.abrupt(\"return\", this.channel.updateToken(token));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function updateToken(_x) {\n        return _updateToken.apply(this, arguments);\n      }\n\n      return updateToken;\n    }()\n    /**\n     * Updates notification context.\n     * This method shouldn't be used anyone except twilio notifications library\n     * @param contextId id of notification context\n     * @param context value of notification context\n     * @private\n     */\n\n  }, {\n    key: \"setNotificationsContext\",\n    value: function setNotificationsContext(contextId, context) {\n      this.registrations.setNotificationsContext(contextId, context);\n    }\n    /**\n     * Remove notification context.\n     * This method shouldn't be used anyone except twilio notifications library\n     * @param contextId id of notification context\n     * @private\n     */\n\n  }, {\n    key: \"removeNotificationsContext\",\n    value: function removeNotificationsContext(contextId) {\n      this.registrations.removeNotificationsContext(contextId);\n    }\n    /**\n     * Connect to the server\n     * @fires Twilsock#connected\n     * @public\n     * @returns {void}\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      return this.channel.connect();\n    }\n    /**\n     * Disconnect from the server\n     * @fires Twilsock#disconnected\n     * @public\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEventsIncludingUnfinished);\n      return this.channel.disconnect();\n    }\n    /**\n     * Get HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {string} [grant] The product grant\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(url, headers, grant) {\n      this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n      return this.upstream.send('GET', url, headers, undefined, grant);\n    }\n    /**\n     * Post HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {body} body Body to send\n     * @param {string} [grant] The product grant\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"post\",\n    value: function post(url, headers, body, grant) {\n      this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n      return this.upstream.send('POST', url, headers, body, grant);\n    }\n    /**\n     * Put HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {body} body Body to send\n     * @param {string} [grant] The product grant\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(url, headers, body, grant) {\n      this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n      return this.upstream.send('PUT', url, headers, body, grant);\n    }\n    /**\n     * Delete HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {string} [grant] The product grant\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(url, headers, grant) {\n      this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n      return this.upstream.send('DELETE', url, headers, undefined, grant);\n    }\n    /**\n     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.\n     * @param {TelemetryEventDescription} event Event details.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addTelemetryEvent\",\n    value: function addTelemetryEvent(event) {\n      this.telemetryTracker.addTelemetryEvent(event);\n      this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need\n    }\n    /**\n     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.\n     * @param {TelemetryEventDescription} event Event details.\n     * @param {string} eventKey Unique event key.\n     * @param {TelemetryPoint} point Is this partial event for start or end of measurement.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addPartialTelemetryEvent\",\n    value: function addPartialTelemetryEvent(event, eventKey, point) {\n      this.telemetryTracker.addPartialEvent(event, eventKey, point);\n\n      if (point === telemetrytracker_1.TelemetryPoint.End) {\n        // this telemetry event is complete, so minimal portion could become ready to send\n        this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.channel.isConnected;\n    }\n    /**\n     * Current state\n     * @returns {String}\n     */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.channel.state;\n    }\n  }]);\n\n  return TwilsockClient;\n}(events_1.EventEmitter);\n\nexports.TwilsockClient = TwilsockClient;\nexports.Twilsock = TwilsockClient;\n/**\n * Twilsock destination address descriptor\n * @typedef {Object} Twilsock#Address\n * @property {String} method - HTTP method. (POST, PUT, etc)\n * @property {String} host - host name without path. (e.g. my.company.com)\n * @property {String} path - path on the host (e.g. /my/app/to/call.php)\n */\n\n/**\n * Twilsock upstream message\n * @typedef {Object} Twilsock#Message\n * @property {Twilsock#Address} to - destination address\n * @property {Object} headers - HTTP headers\n * @property {Object} body - Body\n */\n\n/**\n * Fired when new message received\n * @param {Twilsock#Message} message\n * @event Twilsock#message\n */\n\n/**\n * Fired when socket connected\n * @param {String} URI of endpoint\n * @event Twilsock#connected\n */\n\n/**\n * Fired when socket disconnected\n * @event Twilsock#disconnected\n */\n\n/**\n * Fired when token is about to expire and should be updated\n * @event Twilsock#tokenAboutToExpire\n */\n\n/**\n* Fired when socket connected\n* @param {('connecting'|'connected'|'rejected'|'disconnecting'|'disconnected')} state - general twilsock state\n* @event Twilsock#stateChanged\n*/\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n * @event Twilsock#connectionError\n */","map":null,"metadata":{},"sourceType":"script"}