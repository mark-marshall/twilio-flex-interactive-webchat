{"ast":null,"code":"\"use strict\";\n\nvar _keys = require(\"babel-runtime/core-js/object/keys\");\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _toConsumableArray2 = require(\"babel-runtime/helpers/toConsumableArray\");\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _set = require(\"babel-runtime/core-js/set\");\n\nvar _set2 = _interopRequireDefault(_set);\n\nvar _regenerator = require(\"babel-runtime/regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _promise = require(\"babel-runtime/core-js/promise\");\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _asyncToGenerator2 = require(\"babel-runtime/helpers/asyncToGenerator\");\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _map = require(\"babel-runtime/core-js/map\");\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _isInteger = require(\"babel-runtime/core-js/number/is-integer\");\n\nvar _isInteger2 = _interopRequireDefault(_isInteger);\n\nvar _getPrototypeOf = require(\"babel-runtime/core-js/object/get-prototype-of\");\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar logger_1 = require(\"./logger\");\n\nvar members_1 = require(\"./data/members\");\n\nvar member_1 = require(\"./member\");\n\nvar messages_1 = require(\"./data/messages\");\n\nvar util_1 = require(\"./util\");\n\nvar log = logger_1.Logger.scope('Channel');\nvar fieldMappings = {\n  lastMessage: 'lastMessage',\n  attributes: 'attributes',\n  createdBy: 'createdBy',\n  dateCreated: 'dateCreated',\n  dateUpdated: 'dateUpdated',\n  friendlyName: 'friendlyName',\n  lastConsumedMessageIndex: 'lastConsumedMessageIndex',\n  notificationLevel: 'notificationLevel',\n  sid: 'sid',\n  status: 'status',\n  type: 'type',\n  uniqueName: 'uniqueName',\n  state: 'state'\n};\n\nfunction parseTime(timeString) {\n  try {\n    return new Date(timeString);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction filterStatus(status) {\n  switch (status) {\n    case 'notParticipating':\n      return 'known';\n\n    default:\n      return status;\n  }\n}\n\nexports.filterStatus = filterStatus;\n/**\n * @classdesc A Channel represents a remote channel of communication between multiple Programmable Chat Clients\n * @property {Object} attributes - The Channel's custom attributes\n * @property {String} createdBy - The identity of the User that created this Channel\n * @property {Date} dateCreated - The Date this Channel was created\n * @property {Date} dateUpdated - The Date this Channel was last updated\n * @property {String} friendlyName - The Channel's name\n * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)\n * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in this Channel\n * @property {Channel#LastMessage} lastMessage - Last Message sent to this Channel\n * @property {Channel#NotificationLevel} notificationLevel - User Notification level for this Channel\n * @property {String} sid - The Channel's unique system identifier\n * @property {Channel#State} state - The Channel's state\n * @property {Channel#Status} status - The Channel's status\n * @property {Channel#Type} type - The Channel's type\n * @property {String} uniqueName - The Channel's unique name (tag)\n * @fires Channel#memberJoined\n * @fires Channel#memberLeft\n * @fires Channel#memberUpdated\n * @fires Channel#messageAdded\n * @fires Channel#messageRemoved\n * @fires Channel#messageUpdated\n * @fires Channel#typingEnded\n * @fires Channel#typingStarted\n * @fires Channel#updated\n * @fires Channel#removed\n */\n\nvar Channel = function (_events_1$EventEmitte) {\n  (0, _inherits3.default)(Channel, _events_1$EventEmitte);\n  /**\n   * These options can be passed to {@link Channel#sendMessage}.\n   * @typedef {Object} Channel#SendMediaOptions\n   * @property {String} contentType - content type of media\n   * @property {String | Buffer} media - content to post\n   */\n\n  /**\n   * The update reason for <code>updated</code> event emitted on Channel\n   * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |\n    'friendlyName' | 'lastConsumedMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' |\n    'notificationLevel' )} Channel#UpdateReason\n   */\n\n  /**\n   * The status of the Channel, relative to the Client: whether the Channel\n   * is <code>known</code> to local Client, Client is <code>invited</code> to or\n   * is <code>joined</code> to this Channel\n   * @typedef {('unknown' | 'known' | 'invited' | 'joined')} Channel#Status\n   */\n\n  /**\n   * The type of Channel (<code>public</code> or <code>private</code>).\n   * @typedef {('public' | 'private')} Channel#Type\n   */\n\n  /**\n   * The User's Notification level for Channel, determines whether the currently logged-in User will receive\n   * pushes for events in this Channel. Can be either <code>muted</code> or <code>default</code>,\n   * where <code>default</code> defers to global Service push configuration.\n   * @typedef {('default' | 'muted')} Channel#NotificationLevel\n   */\n\n  /**\n   * The Channel's state. Set to undefined if the channel is not a conversation.\n   * @typedef {Object | undefined} Channel#State\n   * @property {('active' | 'inactive' | 'closed')} current - the current state\n   * @property {Date} dateUpdated - date at which the latest channel state update happened\n   */\n\n  function Channel(services, descriptor, sid) {\n    (0, _classCallCheck3.default)(this, Channel);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Channel.__proto__ || (0, _getPrototypeOf2.default)(Channel)).call(this));\n\n    var attributes = descriptor.attributes || {};\n    var createdBy = descriptor.createdBy;\n    var dateCreated = parseTime(descriptor.dateCreated);\n    var dateUpdated = parseTime(descriptor.dateUpdated);\n    var friendlyName = descriptor.friendlyName || null;\n    var lastConsumedMessageIndex = (0, _isInteger2.default)(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;\n    var uniqueName = descriptor.uniqueName || null;\n\n    try {\n      (0, _stringify2.default)(attributes);\n    } catch (e) {\n      throw new Error('Attributes must be a valid JSON object.');\n    }\n\n    _this.services = services;\n    _this.sid = sid;\n    _this.entityName = descriptor.channel;\n    _this.channelState = {\n      uniqueName: uniqueName,\n      status: 'known',\n      type: descriptor.type,\n      attributes: attributes,\n      createdBy: createdBy,\n      dateCreated: dateCreated,\n      dateUpdated: dateUpdated,\n      friendlyName: friendlyName,\n      lastConsumedMessageIndex: lastConsumedMessageIndex\n    };\n\n    if (descriptor.notificationLevel) {\n      _this.channelState.notificationLevel = descriptor.notificationLevel;\n    }\n\n    _this.members = new _map2.default();\n    _this.membersEntity = new members_1.Members(_this, _this.services, _this.members);\n\n    _this.membersEntity.on('memberJoined', _this.emit.bind(_this, 'memberJoined'));\n\n    _this.membersEntity.on('memberLeft', _this.emit.bind(_this, 'memberLeft'));\n\n    _this.membersEntity.on('memberUpdated', function (args) {\n      return _this.emit('memberUpdated', args);\n    });\n\n    _this.messagesEntity = new messages_1.Messages(_this, services);\n\n    _this.messagesEntity.on('messageAdded', function (message) {\n      return _this._onMessageAdded(message);\n    });\n\n    _this.messagesEntity.on('messageUpdated', function (args) {\n      return _this.emit('messageUpdated', args);\n    });\n\n    _this.messagesEntity.on('messageRemoved', _this.emit.bind(_this, 'messageRemoved'));\n\n    return _this;\n  }\n\n  (0, _createClass3.default)(Channel, [{\n    key: \"_subscribe\",\n\n    /**\n     * The Channel's last message's information.\n     * @typedef {Object} Channel#LastMessage\n     * @property {Number} index - Message's index\n     * @property {Date} timestamp - Message's creation timestamp\n     */\n\n    /**\n     * Load and Subscribe to this Channel and do not subscribe to its Members and Messages.\n     * This or _subscribeStreams will need to be called before any events on Channel will fire.\n     * @returns {Promise}\n     * @private\n     */\n    value: function _subscribe() {\n      var _this2 = this;\n\n      if (this.entityPromise) {\n        return this.entityPromise;\n      }\n\n      return this.entityPromise = this.entityPromise || this.services.syncClient.document({\n        id: this.entityName,\n        mode: 'open_existing'\n      }).then(function (entity) {\n        _this2.entity = entity;\n\n        _this2.entity.on('updated', function (args) {\n          _this2._update(args.value);\n        });\n\n        _this2.entity.on('removed', function () {\n          return _this2.emit('removed', _this2);\n        });\n\n        _this2._update(_this2.entity.value);\n\n        return entity;\n      }).catch(function (err) {\n        _this2.entity = null;\n        _this2.entityPromise = null;\n\n        if (_this2.services.syncClient.connectionState != 'disconnected') {\n          log.error('Failed to get channel object', err);\n        }\n\n        log.debug('ERROR: Failed to get channel object', err);\n        throw err;\n      });\n    }\n    /**\n     * Load the attributes of this Channel and instantiate its Members and Messages.\n     * This or _subscribe will need to be called before any events on Channel will fire.\n     * This will need to be called before any events on Members or Messages will fire\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"_subscribeStreams\",\n    value: function () {\n      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {\n        var messagesObjectName, rosterObjectName;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this._subscribe();\n\n              case 3:\n                log.trace('_subscribeStreams, this.entity.value=', this.entity.value);\n                messagesObjectName = this.entity.value.messages;\n                rosterObjectName = this.entity.value.roster;\n                _context.next = 8;\n                return _promise2.default.all([this.messagesEntity.subscribe(messagesObjectName), this.membersEntity.subscribe(rosterObjectName)]);\n\n              case 8:\n                _context.next = 15;\n                break;\n\n              case 10:\n                _context.prev = 10;\n                _context.t0 = _context[\"catch\"](0);\n\n                if (this.services.syncClient.connectionState !== 'disconnected') {\n                  log.error('Failed to subscribe on channel objects', this.sid, _context.t0);\n                }\n\n                log.debug('ERROR: Failed to subscribe on channel objects', this.sid, _context.t0);\n                throw _context.t0;\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 10]]);\n      }));\n\n      function _subscribeStreams() {\n        return _ref.apply(this, arguments);\n      }\n\n      return _subscribeStreams;\n    }()\n    /**\n     * Stop listening for and firing events on this Channel.\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"_unsubscribe\",\n    value: function () {\n      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.isPrivate && this.entity)) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.entity.close();\n\n              case 3:\n                this.entity = null;\n                this.entityPromise = null;\n\n              case 5:\n                return _context2.abrupt(\"return\", _promise2.default.all([this.membersEntity.unsubscribe(), this.messagesEntity.unsubscribe()]));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _unsubscribe() {\n        return _ref2.apply(this, arguments);\n      }\n\n      return _unsubscribe;\n    }()\n    /**\n     * Set channel status\n     * @private\n     */\n\n  }, {\n    key: \"_setStatus\",\n    value: function _setStatus(status, source) {\n      var _this3 = this;\n\n      this.statusSource = source;\n\n      if (this.channelState.status === status) {\n        return;\n      }\n\n      this.channelState.status = status;\n\n      if (status === 'joined') {\n        this._subscribeStreams().catch(function (err) {\n          log.debug('ERROR while setting channel status ' + status, err);\n\n          if (_this3.services.syncClient.connectionState !== 'disconnected') {\n            throw err;\n          }\n        });\n      } else if (status === 'invited') {\n        this._subscribe().catch(function (err) {\n          log.debug('ERROR while setting channel status ' + status, err);\n\n          if (_this3.services.syncClient.connectionState !== 'disconnected') {\n            throw err;\n          }\n        });\n      } else if (this.entityPromise) {\n        this._unsubscribe().catch(function (err) {\n          log.debug('ERROR while setting channel status ' + status, err);\n\n          if (_this3.services.syncClient.connectionState !== 'disconnected') {\n            throw err;\n          }\n        });\n      }\n    }\n    /**\n     * If channel's status update source\n     * @private\n     * @return {Channels.DataSource}\n     */\n\n  }, {\n    key: \"_statusSource\",\n    value: function _statusSource() {\n      return this.statusSource;\n    }\n  }, {\n    key: \"_update\",\n\n    /**\n     * Updates local channel object with new values\n     * @private\n     */\n    value: function _update(update) {\n      var _a, _b, _c, _d, _e;\n\n      log.trace('_update', update);\n      Channel.preprocessUpdate(update, this.sid);\n      var updateReasons = new _set2.default();\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(update)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          var localKey = fieldMappings[key];\n\n          if (!localKey) {\n            continue;\n          }\n\n          switch (localKey) {\n            case fieldMappings.status:\n              if (!update.status || update.status === 'unknown' || this.channelState.status === filterStatus(update.status)) {\n                break;\n              }\n\n              this.channelState.status = filterStatus(update.status);\n              updateReasons.add(localKey);\n              break;\n\n            case fieldMappings.attributes:\n              if (util_1.isDeepEqual(this.channelState.attributes, update.attributes)) {\n                break;\n              }\n\n              this.channelState.attributes = update.attributes;\n              updateReasons.add(localKey);\n              break;\n\n            case fieldMappings.lastConsumedMessageIndex:\n              if (update.lastConsumedMessageIndex === undefined || update.lastConsumedMessageIndex === this.channelState.lastConsumedMessageIndex) {\n                break;\n              }\n\n              this.channelState.lastConsumedMessageIndex = update.lastConsumedMessageIndex;\n              updateReasons.add(localKey);\n              break;\n\n            case fieldMappings.lastMessage:\n              if (this.channelState.lastMessage && !update.lastMessage) {\n                delete this.channelState.lastMessage;\n                updateReasons.add(localKey);\n                break;\n              }\n\n              this.channelState.lastMessage = this.channelState.lastMessage || {};\n\n              if (((_a = update.lastMessage) === null || _a === void 0 ? void 0 : _a.index) !== undefined && update.lastMessage.index !== this.channelState.lastMessage.index) {\n                this.channelState.lastMessage.index = update.lastMessage.index;\n                updateReasons.add(localKey);\n              }\n\n              if (((_b = update.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp) !== undefined && ((_d = (_c = this.channelState.lastMessage) === null || _c === void 0 ? void 0 : _c.timestamp) === null || _d === void 0 ? void 0 : _d.getTime()) !== update.lastMessage.timestamp.getTime()) {\n                this.channelState.lastMessage.timestamp = update.lastMessage.timestamp;\n                updateReasons.add(localKey);\n              }\n\n              if (util_1.isDeepEqual(this.channelState.lastMessage, {})) {\n                delete this.channelState.lastMessage;\n              }\n\n              break;\n\n            case fieldMappings.state:\n              var state = update.state || undefined;\n\n              if (state !== undefined) {\n                state.dateUpdated = new Date(state.dateUpdated);\n              }\n\n              if (util_1.isDeepEqual(this.channelState.state, state)) {\n                break;\n              }\n\n              this.channelState.state = state;\n              updateReasons.add(localKey);\n              break;\n\n            default:\n              var isDate = update[key] instanceof Date;\n              var keysMatchAsDates = isDate && ((_e = this.channelState[localKey]) === null || _e === void 0 ? void 0 : _e.getTime()) === update[key].getTime();\n              var keysMatchAsNonDates = !isDate && this[localKey] === update[key];\n\n              if (keysMatchAsDates || keysMatchAsNonDates) {\n                break;\n              }\n\n              this.channelState[localKey] = update[key];\n              updateReasons.add(localKey);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (updateReasons.size > 0) {\n        this.emit('updated', {\n          channel: this,\n          updateReasons: [].concat((0, _toConsumableArray3.default)(updateReasons))\n        });\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_onMessageAdded\",\n    value: function _onMessageAdded(message) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = (0, _getIterator3.default)(this.members.values()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var member = _step2.value;\n\n          if (member.identity === message.author) {\n            member._endTyping();\n\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.emit('messageAdded', message);\n    }\n    /**\n     * Add a participant to the Channel by its Identity.\n     * @param {String} identity - Identity of the Client to add\n     * @returns {Promise<void|Error|SessionError>}\n     */\n\n  }, {\n    key: \"add\",\n    value: function () {\n      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(identity) {\n        return _regenerator2.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(!identity || typeof identity !== 'string')) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new Error('Channel.add requires an <String>identity parameter');\n\n              case 2:\n                return _context3.abrupt(\"return\", this.membersEntity.add(identity));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function add(_x) {\n        return _ref3.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n     * Advance last consumed Channel's Message index to current consumption horizon.\n     * Rejects if User is not Member of Channel.\n     * Last consumed Message index is updated only if new index value is higher than previous.\n     * @param {Number} index - Message index to advance to as last read\n     * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel\n     */\n\n  }, {\n    key: \"advanceLastConsumedMessageIndex\",\n    value: function () {\n      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(index) {\n        return _regenerator2.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if ((0, _isInteger2.default)(index)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('Channel.advanceLastConsumedMessageIndex requires an integral <Number>index parameter');\n\n              case 2:\n                _context4.next = 4;\n                return this._subscribeStreams();\n\n              case 4:\n                return _context4.abrupt(\"return\", this.services.consumptionHorizon.advanceLastConsumedMessageIndexForChannel(this.sid, index, this.lastConsumedMessageIndex));\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function advanceLastConsumedMessageIndex(_x2) {\n        return _ref4.apply(this, arguments);\n      }\n\n      return advanceLastConsumedMessageIndex;\n    }()\n    /**\n     * Decline an invitation to the Channel and unsubscribe from its events.\n     * @returns {Promise<Channel|SessionError>}\n     */\n\n  }, {\n    key: \"decline\",\n    value: function () {\n      var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {\n        return _regenerator2.default.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.services.session.addCommand('declineInvitation', {\n                  channelSid: this.sid\n                });\n\n              case 2:\n                return _context5.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function decline() {\n        return _ref5.apply(this, arguments);\n      }\n\n      return decline;\n    }()\n    /**\n     * Delete the Channel and unsubscribe from its events.\n     * @returns {Promise<Channel|SessionError>}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {\n        return _regenerator2.default.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.services.session.addCommand('destroyChannel', {\n                  channelSid: this.sid\n                });\n\n              case 2:\n                return _context6.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _delete() {\n        return _ref6.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n    /**\n     * Get the custom attributes of this Channel.<br/>\n     *\n     * <i>NOTE: {@link Channel}'s <code>attributes</code> property will be empty for public channels until this function is called.</i>\n     * @returns {Promise<Object>}\n     */\n\n  }, {\n    key: \"getAttributes\",\n    value: function () {\n      var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {\n        return _regenerator2.default.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this._subscribe();\n\n              case 2:\n                return _context7.abrupt(\"return\", this.attributes);\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getAttributes() {\n        return _ref7.apply(this, arguments);\n      }\n\n      return getAttributes;\n    }()\n    /**\n     * Returns messages from channel using paginator interface.\n     * @param {Number} [pageSize=30] Number of messages to return in single chunk\n     * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default\n     * @param {String} [direction=backwards] - Query direction. By default it query backwards\n     *                                         from newer to older. 'forward' will query in opposite direction\n     * @returns {Promise<Paginator<Message>>} page of messages\n     */\n\n  }, {\n    key: \"getMessages\",\n    value: function () {\n      var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(pageSize, anchor, direction) {\n        return _regenerator2.default.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!(typeof anchor !== 'undefined' && !(0, _isInteger2.default)(anchor))) {\n                  _context8.next = 2;\n                  break;\n                }\n\n                throw new Error('Anchor should be a valid message index');\n\n              case 2:\n                _context8.next = 4;\n                return this._subscribeStreams();\n\n              case 4:\n                return _context8.abrupt(\"return\", this.messagesEntity.getMessages(pageSize, anchor, direction));\n\n              case 5:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getMessages(_x3, _x4, _x5) {\n        return _ref8.apply(this, arguments);\n      }\n\n      return getMessages;\n    }()\n    /**\n     * Get a list of all Members joined to this Channel.\n     * @returns {Promise<Array<Member>>}\n     */\n\n  }, {\n    key: \"getMembers\",\n    value: function () {\n      var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9() {\n        return _regenerator2.default.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                return _context9.abrupt(\"return\", this.membersEntity.getMembers());\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getMembers() {\n        return _ref9.apply(this, arguments);\n      }\n\n      return getMembers;\n    }()\n    /**\n     * Get channel members count.\n     * <br/>\n     * This method is semi-realtime. This means that this data will be eventually correct,\n     * but will also possibly be incorrect for a few seconds. The Chat system does not\n     * provide real time events for counter values changes.\n     * <br/>\n     * So this is quite useful for any UI badges, but is not recommended\n     * to build any core application logic based on these counters being accurate in real time.\n     * @returns {Promise<number|Error>}\n     */\n\n  }, {\n    key: \"getMembersCount\",\n    value: function () {\n      var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10() {\n        var links, url, response;\n        return _regenerator2.default.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.services.session.getSessionLinks();\n\n              case 2:\n                links = _context10.sent;\n                url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();\n                _context10.next = 6;\n                return this.services.network.get(url);\n\n              case 6:\n                response = _context10.sent;\n                return _context10.abrupt(\"return\", response.body.members_count);\n\n              case 8:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getMembersCount() {\n        return _ref10.apply(this, arguments);\n      }\n\n      return getMembersCount;\n    }()\n    /**\n     * Get a Member by its SID.\n     * @param {String} memberSid - Member sid\n     * @returns {Promise<Member>}\n     */\n\n  }, {\n    key: \"getMemberBySid\",\n    value: function () {\n      var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(memberSid) {\n        return _regenerator2.default.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!(!memberSid || typeof memberSid !== 'string')) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                throw new Error('Channel.getMemberBySid requires a <String>memberSid parameter');\n\n              case 2:\n                return _context11.abrupt(\"return\", this.membersEntity.getMemberBySid(memberSid));\n\n              case 3:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getMemberBySid(_x6) {\n        return _ref11.apply(this, arguments);\n      }\n\n      return getMemberBySid;\n    }()\n    /**\n     * Get a Member by its identity.\n     * @param {String} identity - Member identity\n     * @returns {Promise<Member>}\n     */\n\n  }, {\n    key: \"getMemberByIdentity\",\n    value: function () {\n      var _ref12 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee12(identity) {\n        return _regenerator2.default.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (!(!identity || typeof identity !== 'string')) {\n                  _context12.next = 2;\n                  break;\n                }\n\n                throw new Error('Channel.getMemberByIdentity requires a <String>identity parameter');\n\n              case 2:\n                return _context12.abrupt(\"return\", this.membersEntity.getMemberByIdentity(identity));\n\n              case 3:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getMemberByIdentity(_x7) {\n        return _ref12.apply(this, arguments);\n      }\n\n      return getMemberByIdentity;\n    }()\n    /**\n     * Get total message count in a channel.\n     * <br/>\n     * This method is semi-realtime. This means that this data will be eventually correct,\n     * but will also possibly be incorrect for a few seconds. The Chat system does not\n     * provide real time events for counter values changes.\n     * <br/>\n     * So this is quite useful for any UI badges, but is not recommended\n     * to build any core application logic based on these counters being accurate in real time.\n     * @returns {Promise<number|Error>}\n     */\n\n  }, {\n    key: \"getMessagesCount\",\n    value: function () {\n      var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee13() {\n        var links, url, response;\n        return _regenerator2.default.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.services.session.getSessionLinks();\n\n              case 2:\n                links = _context13.sent;\n                url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();\n                _context13.next = 6;\n                return this.services.network.get(url);\n\n              case 6:\n                response = _context13.sent;\n                return _context13.abrupt(\"return\", response.body.messages_count);\n\n              case 8:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function getMessagesCount() {\n        return _ref13.apply(this, arguments);\n      }\n\n      return getMessagesCount;\n    }()\n    /**\n     * Get unconsumed messages count for User if he is Member of this Channel.\n     * Rejects if User is not Member of Channel.\n     * <br/>\n     * This method is semi-realtime. This means that this data will be eventually correct,\n     * but will also possibly be incorrect for a few seconds. The Chat system does not\n     * provide real time events for counter values changes.\n     * <br/>\n     * So this is quite useful for any “unread messages count” badges, but is not recommended\n     * to build any core application logic based on these counters being accurate in real time.\n     * @returns {Promise<number|Error>}\n     */\n\n  }, {\n    key: \"getUnconsumedMessagesCount\",\n    value: function () {\n      var _ref14 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee14() {\n        var links, url, response;\n        return _regenerator2.default.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.services.session.getSessionLinks();\n\n              case 2:\n                links = _context14.sent;\n                url = new util_1.UriBuilder(links.myChannelsUrl).arg('ChannelSid', this.sid).build();\n                _context14.next = 6;\n                return this.services.network.get(url);\n\n              case 6:\n                response = _context14.sent;\n\n                if (!(response.body.channels.length && response.body.channels[0].channel_sid == this.sid)) {\n                  _context14.next = 11;\n                  break;\n                }\n\n                if (!(typeof response.body.channels[0].unread_messages_count !== 'undefined' && response.body.channels[0].unread_messages_count != null)) {\n                  _context14.next = 10;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", response.body.channels[0].unread_messages_count);\n\n              case 10:\n                return _context14.abrupt(\"return\", null);\n\n              case 11:\n                throw new Error('Channel is not in user channels list');\n\n              case 12:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function getUnconsumedMessagesCount() {\n        return _ref14.apply(this, arguments);\n      }\n\n      return getUnconsumedMessagesCount;\n    }()\n    /**\n     * Invite a user to the Channel by their Identity.\n     * @param {String} identity - Identity of the user to invite\n     * @returns {Promise<void|Error|SessionError>}\n     */\n\n  }, {\n    key: \"invite\",\n    value: function () {\n      var _ref15 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee15(identity) {\n        return _regenerator2.default.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                if (!(typeof identity !== 'string' || !identity.length)) {\n                  _context15.next = 2;\n                  break;\n                }\n\n                throw new Error('Channel.invite requires an <String>identity parameter');\n\n              case 2:\n                _context15.next = 4;\n                return this.membersEntity.invite(identity);\n\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function invite(_x8) {\n        return _ref15.apply(this, arguments);\n      }\n\n      return invite;\n    }()\n    /**\n     * Join the Channel and subscribe to its events.\n     * @returns {Promise<Channel|SessionError>}\n     */\n\n  }, {\n    key: \"join\",\n    value: function () {\n      var _ref16 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee16() {\n        return _regenerator2.default.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return this.services.session.addCommand('joinChannelV2', {\n                  channelSid: this.sid\n                });\n\n              case 2:\n                return _context16.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function join() {\n        return _ref16.apply(this, arguments);\n      }\n\n      return join;\n    }()\n    /**\n     * Leave the Channel.\n     * @returns {Promise<Channel|SessionError>}\n     */\n\n  }, {\n    key: \"leave\",\n    value: function () {\n      var _ref17 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee17() {\n        return _regenerator2.default.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (!(this.channelState.status === 'joined')) {\n                  _context17.next = 3;\n                  break;\n                }\n\n                _context17.next = 3;\n                return this.services.session.addCommand('leaveChannel', {\n                  channelSid: this.sid\n                });\n\n              case 3:\n                return _context17.abrupt(\"return\", this);\n\n              case 4:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function leave() {\n        return _ref17.apply(this, arguments);\n      }\n\n      return leave;\n    }()\n    /**\n     * Remove a Member from the Channel.\n     * @param {String} member - identity of member to remove\n     * @returns {Promise<void|Error|SessionError>}\n     */\n\n  }, {\n    key: \"removeMember\",\n    value: function () {\n      var _ref18 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee18(member) {\n        return _regenerator2.default.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (!(!member || typeof member !== 'string' && !(member instanceof member_1.Member))) {\n                  _context18.next = 2;\n                  break;\n                }\n\n                throw new Error('Channel.removeMember requires a <String|Member>member parameter.');\n\n              case 2:\n                if (!(member instanceof member_1.Member)) {\n                  _context18.next = 7;\n                  break;\n                }\n\n                _context18.next = 5;\n                return this.membersEntity.removeBySid(member.sid);\n\n              case 5:\n                _context18.next = 9;\n                break;\n\n              case 7:\n                _context18.next = 9;\n                return this.membersEntity.removeByIdentity(member);\n\n              case 9:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function removeMember(_x9) {\n        return _ref18.apply(this, arguments);\n      }\n\n      return removeMember;\n    }()\n    /**\n     * Send a Message in the Channel.\n     * @param {String | FormData | Channel#SendMediaOptions} message - The message body for text message,\n     * FormData or MediaOptions for media content. Sending FormData supported only with browser engine\n     * @param {Object} messageAttributes - attributes for the message\n     * @returns {Promise<number|Error|SessionError>} new Message's index in the Channel's messages list\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _ref19 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee19(message, messageAttributes) {\n        var response, _response;\n\n        return _regenerator2.default.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                if (!(typeof message === 'undefined')) {\n                  _context19.next = 2;\n                  break;\n                }\n\n                throw new Error('Message is required parameter');\n\n              case 2:\n                if (!(typeof message === 'string' || message === null)) {\n                  _context19.next = 9;\n                  break;\n                }\n\n                _context19.next = 5;\n                return this.messagesEntity.send(message, messageAttributes);\n\n              case 5:\n                response = _context19.sent;\n                return _context19.abrupt(\"return\", util_1.parseToNumber(response.messageId));\n\n              case 9:\n                _context19.next = 11;\n                return this.messagesEntity.sendMedia(message, messageAttributes);\n\n              case 11:\n                _response = _context19.sent;\n                return _context19.abrupt(\"return\", util_1.parseToNumber(_response.messageId));\n\n              case 13:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function sendMessage(_x10, _x11) {\n        return _ref19.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n    /**\n     * Set last consumed Channel's Message index to last known Message's index in this Channel.\n     * @returns {Promise<number|SessionError>} resulting unread messages count in the channel\n     */\n\n  }, {\n    key: \"setAllMessagesConsumed\",\n    value: function () {\n      var _ref20 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee20() {\n        var messagesPage;\n        return _regenerator2.default.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                _context20.next = 4;\n                return this.getMessages(1);\n\n              case 4:\n                messagesPage = _context20.sent;\n\n                if (!(messagesPage.items.length > 0)) {\n                  _context20.next = 7;\n                  break;\n                }\n\n                return _context20.abrupt(\"return\", this.advanceLastConsumedMessageIndex(messagesPage.items[0].index));\n\n              case 7:\n                return _context20.abrupt(\"return\", _promise2.default.resolve(0));\n\n              case 8:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function setAllMessagesConsumed() {\n        return _ref20.apply(this, arguments);\n      }\n\n      return setAllMessagesConsumed;\n    }()\n    /**\n     * Set all messages in the channel unread.\n     * @returns {Promise<number|SessionError>} resulting unread messages count in the channel\n     */\n\n  }, {\n    key: \"setNoMessagesConsumed\",\n    value: function () {\n      var _ref21 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee21() {\n        return _regenerator2.default.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                return _context21.abrupt(\"return\", this.services.consumptionHorizon.updateLastConsumedMessageIndexForChannel(this.sid, null));\n\n              case 3:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function setNoMessagesConsumed() {\n        return _ref21.apply(this, arguments);\n      }\n\n      return setNoMessagesConsumed;\n    }()\n    /**\n     * Set User Notification level for this channel.\n     * @param {Channel#NotificationLevel} notificationLevel - The new user notification level\n     * @returns {Promise<void|Error|SessionError>}\n     */\n\n  }, {\n    key: \"setUserNotificationLevel\",\n    value: function () {\n      var _ref22 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee22(notificationLevel) {\n        return _regenerator2.default.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                if (notificationLevel) {\n                  _context22.next = 2;\n                  break;\n                }\n\n                throw new Error('notificationLevel can\\'t be null');\n\n              case 2:\n                _context22.next = 4;\n                return this.services.session.addCommand('editNotificationLevel', {\n                  channelSid: this.sid,\n                  notificationLevel: notificationLevel\n                });\n\n              case 4:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function setUserNotificationLevel(_x12) {\n        return _ref22.apply(this, arguments);\n      }\n\n      return setUserNotificationLevel;\n    }()\n    /**\n     * Send a notification to the server indicating that this Client is currently typing in this Channel.\n     * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.\n     * @returns {Promise<void|SessionError>}\n     */\n\n  }, {\n    key: \"typing\",\n    value: function typing() {\n      return this.services.typingIndicator.send(this.sid);\n    }\n    /**\n     * Update the Channel's attributes.\n     * @param {Object} attributes - The new attributes object\n     * @returns {Promise<Channel|Error|SessionError>}\n     */\n\n  }, {\n    key: \"updateAttributes\",\n    value: function () {\n      var _ref23 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee23(attributes) {\n        return _regenerator2.default.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                if (!(typeof attributes === 'undefined')) {\n                  _context23.next = 4;\n                  break;\n                }\n\n                throw new Error('Attributes is required parameter');\n\n              case 4:\n                if (!(attributes === null)) {\n                  _context23.next = 8;\n                  break;\n                }\n\n                throw new Error('Attributes can\\'t be null');\n\n              case 8:\n                if (!(attributes.constructor !== Object)) {\n                  _context23.next = 10;\n                  break;\n                }\n\n                throw new Error('Attributes must be a valid JSON object.');\n\n              case 10:\n                _context23.next = 12;\n                return this.services.session.addCommand('editAttributes', {\n                  channelSid: this.sid,\n                  attributes: (0, _stringify2.default)(attributes)\n                });\n\n              case 12:\n                return _context23.abrupt(\"return\", this);\n\n              case 13:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function updateAttributes(_x13) {\n        return _ref23.apply(this, arguments);\n      }\n\n      return updateAttributes;\n    }()\n    /**\n     * Update the Channel's friendlyName.\n     * @param {String} name - The new Channel friendlyName\n     * @returns {Promise<Channel|SessionError>}\n     */\n\n  }, {\n    key: \"updateFriendlyName\",\n    value: function () {\n      var _ref24 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee24(name) {\n        return _regenerator2.default.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                if (!(this.channelState.friendlyName !== name)) {\n                  _context24.next = 3;\n                  break;\n                }\n\n                _context24.next = 3;\n                return this.services.session.addCommand('editFriendlyName', {\n                  channelSid: this.sid,\n                  friendlyName: name\n                });\n\n              case 3:\n                return _context24.abrupt(\"return\", this);\n\n              case 4:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function updateFriendlyName(_x14) {\n        return _ref24.apply(this, arguments);\n      }\n\n      return updateFriendlyName;\n    }()\n    /**\n     * Set last consumed Channel's Message index to current consumption horizon.\n     * @param {Number|null} index - Message index to set as last read.\n     * If null provided, then the behavior is identical to {@link Channel#setNoMessagesConsumed}\n     * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel\n     */\n\n  }, {\n    key: \"updateLastConsumedMessageIndex\",\n    value: function () {\n      var _ref25 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee25(index) {\n        return _regenerator2.default.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                if ((0, _isInteger2.default)(index) || index === null) {\n                  _context25.next = 2;\n                  break;\n                }\n\n                throw new Error('Incorrect argument \"index\": integer number or null expected');\n\n              case 2:\n                _context25.next = 4;\n                return this._subscribeStreams();\n\n              case 4:\n                return _context25.abrupt(\"return\", this.services.consumptionHorizon.updateLastConsumedMessageIndexForChannel(this.sid, index));\n\n              case 5:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function updateLastConsumedMessageIndex(_x15) {\n        return _ref25.apply(this, arguments);\n      }\n\n      return updateLastConsumedMessageIndex;\n    }()\n    /**\n     * Update the Channel's unique name.\n     * @param {String} uniqueName - The new Channel uniqueName\n     * @returns {Promise<Channel|SessionError>}\n     */\n\n  }, {\n    key: \"updateUniqueName\",\n    value: function () {\n      var _ref26 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee26(uniqueName) {\n        return _regenerator2.default.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                if (!(this.channelState.uniqueName !== uniqueName)) {\n                  _context26.next = 4;\n                  break;\n                }\n\n                if (!uniqueName) {\n                  uniqueName = '';\n                }\n\n                _context26.next = 4;\n                return this.services.session.addCommand('editUniqueName', {\n                  channelSid: this.sid,\n                  uniqueName: uniqueName\n                });\n\n              case 4:\n                return _context26.abrupt(\"return\", this);\n\n              case 5:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function updateUniqueName(_x16) {\n        return _ref26.apply(this, arguments);\n      }\n\n      return updateUniqueName;\n    }()\n    /**\n     * Gets User Descriptors for this channel.\n     * @returns {Promise<Paginator<UserDescriptor>>}\n     */\n\n  }, {\n    key: \"getUserDescriptors\",\n    value: function () {\n      var _ref27 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee27() {\n        return _regenerator2.default.wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                return _context27.abrupt(\"return\", this.services.users.getChannelUserDescriptors(this.sid));\n\n              case 1:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function getUserDescriptors() {\n        return _ref27.apply(this, arguments);\n      }\n\n      return getUserDescriptors;\n    }()\n  }, {\n    key: \"status\",\n    get: function get() {\n      return this.channelState.status;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.channelState.type;\n    }\n  }, {\n    key: \"uniqueName\",\n    get: function get() {\n      return this.channelState.uniqueName;\n    }\n  }, {\n    key: \"isPrivate\",\n    get: function get() {\n      return this.channelState.type === 'private';\n    }\n  }, {\n    key: \"friendlyName\",\n    get: function get() {\n      return this.channelState.friendlyName;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.channelState.dateUpdated;\n    }\n  }, {\n    key: \"dateCreated\",\n    get: function get() {\n      return this.channelState.dateCreated;\n    }\n  }, {\n    key: \"createdBy\",\n    get: function get() {\n      return this.channelState.createdBy;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this.channelState.attributes;\n    }\n  }, {\n    key: \"lastConsumedMessageIndex\",\n    get: function get() {\n      return this.channelState.lastConsumedMessageIndex;\n    }\n  }, {\n    key: \"lastMessage\",\n    get: function get() {\n      return this.channelState.lastMessage;\n    }\n  }, {\n    key: \"notificationLevel\",\n    get: function get() {\n      return this.channelState.notificationLevel;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.channelState.state;\n    }\n  }], [{\n    key: \"preprocessUpdate\",\n    value: function preprocessUpdate(update, channelSid) {\n      try {\n        if (typeof update.attributes === 'string') {\n          update.attributes = JSON.parse(update.attributes);\n        } else if (update.attributes) {\n          (0, _stringify2.default)(update.attributes);\n        }\n      } catch (e) {\n        log.warn('Retrieved malformed attributes from the server for channel: ' + channelSid);\n        update.attributes = {};\n      }\n\n      try {\n        if (update.dateCreated) {\n          update.dateCreated = new Date(update.dateCreated);\n        }\n      } catch (e) {\n        log.warn('Retrieved malformed dateCreated from the server for channel: ' + channelSid);\n        delete update.dateCreated;\n      }\n\n      try {\n        if (update.dateUpdated) {\n          update.dateUpdated = new Date(update.dateUpdated);\n        }\n      } catch (e) {\n        log.warn('Retrieved malformed dateUpdated from the server for channel: ' + channelSid);\n        delete update.dateUpdated;\n      }\n\n      try {\n        if (update.lastMessage && update.lastMessage.timestamp) {\n          update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);\n        }\n      } catch (e) {\n        log.warn('Retrieved malformed lastMessage.timestamp from the server for channel: ' + channelSid);\n        delete update.lastMessage.timestamp;\n      }\n    }\n  }]);\n  return Channel;\n}(events_1.EventEmitter);\n\nexports.Channel = Channel;\n/**\n * Fired when a Member has joined the Channel.\n * @event Channel#memberJoined\n * @type {Member}\n */\n\n/**\n * Fired when a Member has left the Channel.\n * @event Channel#memberLeft\n * @type {Member}\n */\n\n/**\n * Fired when a Member's fields has been updated.\n * @event Channel#memberUpdated\n * @type {Object}\n * @property {Member} member - Updated Member\n * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons\n */\n\n/**\n * Fired when a new Message has been added to the Channel.\n * @event Channel#messageAdded\n * @type {Message}\n */\n\n/**\n * Fired when Message is removed from Channel's message list.\n * @event Channel#messageRemoved\n * @type {Message}\n */\n\n/**\n * Fired when an existing Message's fields are updated with new values.\n * @event Channel#messageUpdated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n\n/**\n * Fired when a Member has stopped typing.\n * @event Channel#typingEnded\n * @type {Member}\n */\n\n/**\n * Fired when a Member has started typing.\n * @event Channel#typingStarted\n * @type {Member}\n */\n\n/**\n * Fired when a Channel's attributes or metadata have been updated.\n * During Channel's {@link Client.create | creation and initialization} this event might be fired multiple times\n * for same joined or created Channel as new data is arriving from different sources.\n * @event Channel#updated\n * @type {Object}\n * @property {Channel} channel - Updated Channel\n * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons\n */\n\n/**\n * Fired when the Channel was destroyed or currently logged in User has left private Channel\n * @event Channel#removed\n * @type {Channel}\n */","map":null,"metadata":{},"sourceType":"script"}