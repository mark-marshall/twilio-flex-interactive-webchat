{"ast":null,"code":"\"use strict\";\n\nvar _promise = require(\"babel-runtime/core-js/promise\");\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _regenerator = require(\"babel-runtime/regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _asyncToGenerator2 = require(\"babel-runtime/helpers/asyncToGenerator\");\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _set = require(\"babel-runtime/core-js/set\");\n\nvar _set2 = _interopRequireDefault(_set);\n\nvar _map = require(\"babel-runtime/core-js/map\");\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _getPrototypeOf = require(\"babel-runtime/core-js/object/get-prototype-of\");\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar logger_1 = require(\"../logger\");\n\nvar channel_1 = require(\"../channel\");\n\nexports.Channel = channel_1.Channel;\n\nvar deferred_1 = require(\"../util/deferred\");\n\nvar util_1 = require(\"../util\");\n\nvar log = logger_1.Logger.scope('Channels');\n/**\n * Represents channels collection\n * {@see Channel}\n */\n\nvar Channels = function (_events_1$EventEmitte) {\n  (0, _inherits3.default)(Channels, _events_1$EventEmitte);\n\n  function Channels(services) {\n    (0, _classCallCheck3.default)(this, Channels);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Channels.__proto__ || (0, _getPrototypeOf2.default)(Channels)).call(this));\n\n    _this.services = services;\n    _this.channels = new _map2.default();\n    _this.thumbstones = new _set2.default();\n    _this.syncListFetched = false;\n    _this.syncListRead = new deferred_1.Deferred();\n    return _this;\n  }\n\n  (0, _createClass3.default)(Channels, [{\n    key: \"getMap\",\n    value: function getMap() {\n      var _this2 = this;\n\n      return this.services.session.getMyChannelsId().then(function (name) {\n        return _this2.services.syncClient.map({\n          id: name,\n          mode: 'open_existing'\n        });\n      });\n    }\n    /**\n     * Add channel to server\n     * @private\n     * @returns {Promise<Channel|SessionError>} Channel\n     */\n\n  }, {\n    key: \"addChannel\",\n    value: function () {\n      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(options) {\n        var attributes, response, channelSid, channelDocument, existingChannel, channel;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                attributes = void 0;\n\n                if (typeof options.attributes === 'undefined') {\n                  attributes = {};\n                } else {\n                  attributes = options.attributes;\n                }\n\n                if (!(attributes === null)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new Error('Attributes can\\'t be null');\n\n              case 4:\n                if (!(attributes.constructor !== Object)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw new Error('Attributes must be a valid JSON object');\n\n              case 6:\n                _context.next = 8;\n                return this.services.session.addCommand('createChannel', {\n                  friendlyName: options.friendlyName,\n                  uniqueName: options.uniqueName,\n                  type: options.isPrivate ? 'private' : 'public',\n                  attributes: (0, _stringify2.default)(attributes)\n                });\n\n              case 8:\n                response = _context.sent;\n                channelSid = 'channelSid' in response ? response['channelSid'] : null;\n                channelDocument = 'channel' in response ? response['channel'] : null;\n                existingChannel = this.channels.get(channelSid);\n\n                if (!existingChannel) {\n                  _context.next = 16;\n                  break;\n                }\n\n                _context.next = 15;\n                return existingChannel._subscribe();\n\n              case 15:\n                return _context.abrupt(\"return\", existingChannel);\n\n              case 16:\n                channel = new channel_1.Channel(this.services, {\n                  channel: channelDocument,\n                  entityName: null,\n                  uniqueName: null,\n                  attributes: null,\n                  createdBy: null,\n                  friendlyName: null,\n                  lastConsumedMessageIndex: null,\n                  type: options.isPrivate ? 'private' : 'public',\n                  dateCreated: null,\n                  dateUpdated: null\n                }, channelSid);\n                this.channels.set(channel.sid, channel);\n                this.registerForEvents(channel);\n                _context.next = 21;\n                return channel._subscribe();\n\n              case 21:\n                this.emit('channelAdded', channel);\n                return _context.abrupt(\"return\", channel);\n\n              case 23:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function addChannel(_x) {\n        return _ref.apply(this, arguments);\n      }\n\n      return addChannel;\n    }()\n    /**\n     * Fetch channels list and instantiate all necessary objects\n     */\n\n  }, {\n    key: \"fetchChannels\",\n    value: function fetchChannels() {\n      var _this3 = this;\n\n      this.getMap().then(function () {\n        var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(map) {\n          var upserts, paginator, items;\n          return _regenerator2.default.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  map.on('itemAdded', function (args) {\n                    log.debug('itemAdded: ' + args.item.key);\n\n                    _this3.upsertChannel('sync', args.item.key, args.item.value);\n                  });\n                  map.on('itemRemoved', function (args) {\n                    log.debug('itemRemoved: ' + args.key);\n                    var sid = args.key;\n\n                    if (!_this3.syncListFetched) {\n                      _this3.thumbstones.add(sid);\n                    }\n\n                    var channel = _this3.channels.get(sid);\n\n                    if (channel) {\n                      if (channel.status === 'joined' || channel.status === 'invited') {\n                        channel._setStatus('known', 'sync');\n\n                        _this3.emit('channelLeft', channel);\n                      }\n\n                      if (channel.isPrivate) {\n                        _this3.channels.delete(sid);\n\n                        _this3.emit('channelRemoved', channel);\n\n                        channel.emit('removed', channel);\n                      }\n                    }\n                  });\n                  map.on('itemUpdated', function (args) {\n                    log.debug('itemUpdated: ' + args.item.key);\n\n                    _this3.upsertChannel('sync', args.item.key, args.item.value);\n                  });\n                  upserts = [];\n                  _context2.next = 6;\n                  return _this3.services.syncList.getPage();\n\n                case 6:\n                  paginator = _context2.sent;\n                  items = paginator.items;\n                  items.forEach(function (item) {\n                    upserts.push(_this3.upsertChannel('synclist', item.channel_sid, item));\n                  });\n\n                case 9:\n                  if (!paginator.hasNextPage) {\n                    _context2.next = 16;\n                    break;\n                  }\n\n                  _context2.next = 12;\n                  return paginator.nextPage();\n\n                case 12:\n                  paginator = _context2.sent;\n                  paginator.items.forEach(function (item) {\n                    upserts.push(_this3.upsertChannel('synclist', item.channel_sid, item));\n                  });\n                  _context2.next = 9;\n                  break;\n\n                case 16:\n                  _this3.syncListRead.set(true);\n\n                  return _context2.abrupt(\"return\", _promise2.default.all(upserts));\n\n                case 18:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, _this3);\n        }));\n\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()).then(function () {\n        _this3.syncListFetched = true;\n\n        _this3.thumbstones.clear();\n\n        log.debug('Channels list fetched');\n      }).then(function () {\n        return _this3;\n      }).catch(function (e) {\n        if (_this3.services.syncClient.connectionState != 'disconnected') {\n          log.error('Failed to get channels list', e);\n        }\n\n        log.debug('ERROR: Failed to get channels list', e);\n        throw e;\n      });\n    }\n  }, {\n    key: \"_wrapPaginator\",\n    value: function _wrapPaginator(page, op) {\n      var _this4 = this;\n\n      return op(page.items).then(function (items) {\n        return {\n          items: items,\n          hasNextPage: page.hasNextPage,\n          hasPrevPage: page.hasPrevPage,\n          nextPage: function nextPage() {\n            return page.nextPage().then(function (x) {\n              return _this4._wrapPaginator(x, op);\n            });\n          },\n          prevPage: function prevPage() {\n            return page.prevPage().then(function (x) {\n              return _this4._wrapPaginator(x, op);\n            });\n          }\n        };\n      });\n    }\n  }, {\n    key: \"getChannels\",\n    value: function getChannels(args) {\n      var _this5 = this;\n\n      return this.getMap().then(function (channelsMap) {\n        return channelsMap.getItems(args);\n      }).then(function (page) {\n        return _this5._wrapPaginator(page, function (items) {\n          return _promise2.default.all(items.map(function (item) {\n            return _this5.upsertChannel('sync', item.key, item.value);\n          }));\n        });\n      });\n    }\n  }, {\n    key: \"getChannel\",\n    value: function getChannel(sid) {\n      var _this6 = this;\n\n      return this.getMap().then(function (channelsMap) {\n        return channelsMap.getItems({\n          key: sid\n        });\n      }).then(function (page) {\n        return page.items.map(function (item) {\n          return _this6.upsertChannel('sync', item.key, item.value);\n        });\n      }).then(function (items) {\n        return items.length > 0 ? items[0] : null;\n      });\n    }\n  }, {\n    key: \"pushChannel\",\n    value: function pushChannel(descriptor) {\n      var sid = descriptor.sid;\n      var data = {\n        entityName: null,\n        lastConsumedMessageIndex: descriptor.lastConsumedMessageIndex,\n        type: descriptor.type,\n        status: descriptor.status,\n        friendlyName: descriptor.friendlyName,\n        dateUpdated: descriptor.dateUpdated,\n        dateCreated: descriptor.dateCreated,\n        uniqueName: descriptor.uniqueName,\n        createdBy: descriptor.createdBy,\n        attributes: descriptor.attributes,\n        channel: descriptor.channel,\n        notificationLevel: descriptor.notificationLevel,\n        sid: sid\n      };\n      return this.upsertChannel('chat', sid, data);\n    }\n  }, {\n    key: \"upsertChannel\",\n    value: function upsertChannel(source, sid, data) {\n      var _this7 = this;\n\n      log.trace('upsertChannel(sid=' + sid + ', data=', data);\n      var channel = this.channels.get(sid); // Update the Channel's status if we know about it\n\n      if (channel) {\n        log.trace('upsertChannel: channel ' + sid + ' is known and it\\'s' + ' status is known from source ' + channel._statusSource() + ' and update came from source ' + source, channel);\n\n        if (typeof channel._statusSource() === 'undefined' || source === channel._statusSource() || source === 'synclist' && channel._statusSource() !== 'sync' || source === 'sync') {\n          if (data.status === 'joined' && channel.status !== 'joined') {\n            channel._setStatus('joined', source);\n\n            var updateData = {};\n\n            if (typeof data.notificationLevel !== 'undefined') {\n              updateData.notificationLevel = data.notificationLevel;\n            }\n\n            if (typeof data.lastConsumedMessageIndex !== 'undefined') {\n              updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;\n            }\n\n            if (!util_1.isDeepEqual(updateData, {})) {\n              channel._update(updateData);\n            }\n\n            channel._subscribe().then(function () {\n              _this7.emit('channelJoined', channel);\n            });\n          } else if (data.status === 'invited' && channel.status !== 'invited') {\n            channel._setStatus('invited', source);\n\n            var _updateData = {};\n\n            if (typeof data.notificationLevel !== 'undefined') {\n              _updateData.notificationLevel = data.notificationLevel;\n            }\n\n            if (typeof data.lastConsumedMessageIndex !== 'undefined') {\n              _updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;\n            }\n\n            if (!util_1.isDeepEqual(_updateData, {})) {\n              channel._update(_updateData);\n            }\n\n            channel._subscribe().then(function () {\n              _this7.emit('channelInvited', channel);\n            });\n          } else if (data.status === 'known' && (channel.status === 'invited' || channel.status === 'joined')) {\n            channel._setStatus('known', source);\n\n            channel._update(data);\n\n            channel._subscribe().then(function () {\n              _this7.emit('channelLeft', channel);\n            });\n          } else if ((data.status === 'notParticipating' || data.status === 'known') && data.type === 'private') {\n            channel._subscribe();\n          } else {\n            channel._update(data);\n          }\n        } else {\n          log.trace('upsertChannel: channel is known from sync and came from chat, ignoring', {\n            sid: sid,\n            data: data.status,\n            channel: channel.status\n          });\n        }\n\n        return channel._subscribe().then(function () {\n          return channel;\n        });\n      }\n\n      if ((source === 'chat' || source === 'synclist') && this.thumbstones.has(sid)) {\n        // if channel was deleted, we ignore it\n        log.trace('upsertChannel: channel is deleted and came again from chat, ignoring', sid);\n        return;\n      } // Fetch the Channel if we don't know about it\n\n\n      log.trace('upsertChannel: creating local channel object with sid ' + sid, data);\n      channel = new channel_1.Channel(this.services, data, sid);\n      this.channels.set(sid, channel);\n      return channel._subscribe().then(function () {\n        _this7.registerForEvents(channel);\n\n        _this7.emit('channelAdded', channel);\n\n        if (data.status === 'joined') {\n          channel._setStatus('joined', source);\n\n          _this7.emit('channelJoined', channel);\n        } else if (data.status === 'invited') {\n          channel._setStatus('invited', source);\n\n          _this7.emit('channelInvited', channel);\n        }\n\n        return channel;\n      });\n    }\n  }, {\n    key: \"onChannelRemoved\",\n    value: function onChannelRemoved(sid) {\n      var channel = this.channels.get(sid);\n\n      if (channel) {\n        this.channels.delete(sid);\n        this.emit('channelRemoved', channel);\n      }\n    }\n  }, {\n    key: \"registerForEvents\",\n    value: function registerForEvents(channel) {\n      var _this8 = this;\n\n      channel.on('removed', function () {\n        return _this8.onChannelRemoved(channel.sid);\n      });\n      channel.on('updated', function (args) {\n        return _this8.emit('channelUpdated', args);\n      });\n      channel.on('memberJoined', this.emit.bind(this, 'memberJoined'));\n      channel.on('memberLeft', this.emit.bind(this, 'memberLeft'));\n      channel.on('memberUpdated', function (args) {\n        return _this8.emit('memberUpdated', args);\n      });\n      channel.on('messageAdded', this.emit.bind(this, 'messageAdded'));\n      channel.on('messageUpdated', function (args) {\n        return _this8.emit('messageUpdated', args);\n      });\n      channel.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));\n      channel.on('typingStarted', this.emit.bind(this, 'typingStarted'));\n      channel.on('typingEnded', this.emit.bind(this, 'typingEnded'));\n    }\n  }]);\n  return Channels;\n}(events_1.EventEmitter);\n\nexports.Channels = Channels;","map":null,"metadata":{},"sourceType":"script"}