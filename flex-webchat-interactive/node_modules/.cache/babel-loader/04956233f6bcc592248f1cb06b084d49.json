{"ast":null,"code":"\"use strict\";\n\nvar _regenerator = require(\"babel-runtime/regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _assign = require(\"babel-runtime/core-js/object/assign\");\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _asyncToGenerator2 = require(\"babel-runtime/helpers/asyncToGenerator\");\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _promise = require(\"babel-runtime/core-js/promise\");\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _getPrototypeOf = require(\"babel-runtime/core-js/object/get-prototype-of\");\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar logger_1 = require(\"./logger\");\n\nvar configuration_1 = require(\"./configuration\");\n\nvar user_1 = require(\"./user\");\n\nexports.User = user_1.User;\n\nvar publicchannels_1 = require(\"./data/publicchannels\");\n\nvar network_1 = require(\"./services/network\");\n\nvar notificationtypes_1 = require(\"./interfaces/notificationtypes\");\n\nvar synclist_1 = require(\"./synclist\");\n\nvar twilsock_1 = require(\"twilsock\");\n\nvar twilio_notifications_1 = require(\"twilio-notifications\");\n\nvar twilio_sync_1 = require(\"twilio-sync\");\n\nvar twilio_mcs_client_1 = require(\"twilio-mcs-client\");\n\nvar session_1 = require(\"./session\");\n\nvar channels_1 = require(\"./data/channels\");\n\nvar users_1 = require(\"./data/users\");\n\nvar typingindicator_1 = require(\"./services/typingindicator\");\n\nvar consumptionhorizon_1 = require(\"./services/consumptionhorizon\");\n\nvar userchannels_1 = require(\"./data/userchannels\");\n\nvar pushnotification_1 = require(\"./pushnotification\");\n\nexports.PushNotification = pushnotification_1.PushNotification;\n\nvar util_1 = require(\"./util\");\n\nvar log = logger_1.Logger.scope('Client');\n\nvar SDK_VERSION = require('./../package.json').version;\n\nvar MSG_NO_TOKEN = 'A valid Twilio token should be provided';\n\nvar ClientServices = function ClientServices() {\n  (0, _classCallCheck3.default)(this, ClientServices);\n};\n/**\n * A Client is a starting point to access Twilio Programmable Chat functionality.\n *\n * @property {Client#ConnectionState} connectionState - Client connection state\n * @property {Boolean} reachabilityEnabled - Client reachability state\n * @property {User} user - Information for logged in user\n * @property {String} version - Current version of Chat client\n *\n * @fires Client#connectionError\n * @fires Client#connectionStateChanged\n * @fires Client#channelAdded\n * @fires Client#channelInvited\n * @fires Client#channelJoined\n * @fires Client#channelLeft\n * @fires Client#channelRemoved\n * @fires Client#channelUpdated\n * @fires Client#memberJoined\n * @fires Client#memberLeft\n * @fires Client#memberUpdated\n * @fires Client#messageAdded\n * @fires Client#messageRemoved\n * @fires Client#messageUpdated\n * @fires Client#pushNotification\n * @fires Client#tokenAboutToExpire\n * @fires Client#tokenExpired\n * @fires Client#typingEnded\n * @fires Client#typingStarted\n * @fires Client#userSubscribed\n * @fires Client#userUnsubscribed\n * @fires Client#userUpdated\n */\n\n\nvar Client = function (_events_1$EventEmitte) {\n  (0, _inherits3.default)(Client, _events_1$EventEmitte);\n  /**\n   * These options can be passed to Client constructor.\n   * @typedef {Object} Client#ClientOptions\n   * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n   *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n   */\n\n  /**\n   * These options can be passed to {@link Client#createChannel}.\n   * @typedef {Object} Client#CreateChannelOptions\n   * @property {Object} [attributes] - Any custom attributes to attach to the Channel\n   * @property {String} [friendlyName] - The non-unique display name of the Channel\n   * @property {Boolean} [isPrivate] - Whether or not this Channel should be visible to uninvited Clients\n   * @property {String} [uniqueName] - The unique identity name of the Channel\n   */\n\n  /**\n   * Connection state of Client.\n   * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState\n   */\n\n  /**\n   * Notifications channel type.\n   * @typedef {('gcm'|'fcm'|'apn')} Client#NotificationsChannelType\n   */\n\n  /**\n   * These options can be passed to {@link Client#getLocalChannels}.\n   * @typedef {Object} Client#ChannelSortingOptions\n   * @property {('lastMessage'|'friendlyName'|'uniqueName')} criteria - Sorting criteria for Channels array\n   * @property {('ascending'|'descending')} [order] - Sorting order. If not present, then default is <code>ascending</code>\n   */\n\n  function Client(token, options) {\n    (0, _classCallCheck3.default)(this, Client);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Client.__proto__ || (0, _getPrototypeOf2.default)(Client)).call(this));\n\n    _this.connectionState = 'connecting';\n    _this.sessionPromise = null;\n    _this.channelsPromise = null;\n    _this.version = SDK_VERSION;\n    _this.parsePushNotification = Client.parsePushNotification;\n    _this.options = options || {};\n\n    if (!_this.options.disableDeepClone) {\n      _this.options = util_1.deepClone(_this.options);\n    }\n\n    _this.options.logLevel = _this.options.logLevel || 'silent';\n    log.setLevel(_this.options.logLevel);\n    var productId = _this.options.productId = 'ip_messaging'; // Filling ClientMetadata\n\n    _this.options.clientMetadata = _this.options.clientMetadata || {};\n\n    if (!_this.options.clientMetadata.hasOwnProperty('type')) {\n      _this.options.clientMetadata.type = 'chat';\n    }\n\n    if (!_this.options.clientMetadata.hasOwnProperty('sdk')) {\n      _this.options.clientMetadata.sdk = 'JS';\n      _this.options.clientMetadata.sdkv = SDK_VERSION;\n    } // Enable session local storage for Sync\n\n\n    _this.options.Sync = _this.options.Sync || {};\n\n    if (typeof _this.options.Sync.enableSessionStorage === 'undefined') {\n      _this.options.Sync.enableSessionStorage = true;\n    }\n\n    if (_this.options.region) {\n      _this.options.Sync.region = _this.options.region;\n    }\n\n    if (!token) {\n      throw new Error(MSG_NO_TOKEN);\n    }\n\n    _this.services = new ClientServices();\n    _this.config = new configuration_1.Configuration(_this.options);\n    _this.options.twilsockClient = _this.options.twilsockClient || new twilsock_1.Twilsock(token, productId, _this.options);\n    _this.options.transport = _this.options.transport || _this.options.twilsockClient;\n    _this.options.notificationsClient = _this.options.notificationsClient || new twilio_notifications_1.Notifications(token, _this.options);\n    _this.options.syncClient = _this.options.syncClient || new twilio_sync_1.SyncClient(token, _this.options);\n    _this.services.syncClient = _this.options.syncClient;\n    _this.services.transport = _this.options.transport;\n    _this.services.twilsockClient = _this.options.twilsockClient;\n    _this.services.notificationClient = _this.options.notificationsClient;\n    _this.services.session = new session_1.Session(_this.services, _this.config);\n    _this.sessionPromise = _this.services.session.initialize();\n    _this.services.network = new network_1.Network(_this.config, _this.services);\n    _this.services.users = new users_1.Users({\n      session: _this.services.session,\n      network: _this.services.network,\n      syncClient: _this.services.syncClient\n    });\n\n    _this.services.users.on('userSubscribed', _this.emit.bind(_this, 'userSubscribed'));\n\n    _this.services.users.on('userUpdated', function (args) {\n      return _this.emit('userUpdated', args);\n    });\n\n    _this.services.users.on('userUnsubscribed', _this.emit.bind(_this, 'userUnsubscribed'));\n\n    _this.services.twilsockClient.on('tokenAboutToExpire', function (ttl) {\n      return _this.emit('tokenAboutToExpire', ttl);\n    });\n\n    _this.services.twilsockClient.on('tokenExpired', function () {\n      return _this.emit('tokenExpired');\n    });\n\n    _this.services.twilsockClient.on('connectionError', function (error) {\n      return _this.emit('connectionError', error);\n    });\n\n    _this.services.consumptionHorizon = new consumptionhorizon_1.ConsumptionHorizon(_this.services);\n    _this.services.typingIndicator = new typingindicator_1.TypingIndicator(_this.config, {\n      transport: _this.services.twilsockClient,\n      notificationClient: _this.services.notificationClient\n    }, _this.getChannelBySid.bind(_this));\n    _this.services.syncList = new synclist_1.SyncList(_this.services);\n    _this.channels = new channels_1.Channels(_this.services);\n    _this.channelsPromise = _this.sessionPromise.then(function () {\n      _this.channels.on('channelAdded', _this.emit.bind(_this, 'channelAdded'));\n\n      _this.channels.on('channelRemoved', _this.emit.bind(_this, 'channelRemoved'));\n\n      _this.channels.on('channelInvited', _this.emit.bind(_this, 'channelInvited'));\n\n      _this.channels.on('channelJoined', _this.emit.bind(_this, 'channelJoined'));\n\n      _this.channels.on('channelLeft', _this.emit.bind(_this, 'channelLeft'));\n\n      _this.channels.on('channelUpdated', function (args) {\n        return _this.emit('channelUpdated', args);\n      });\n\n      _this.channels.on('memberJoined', _this.emit.bind(_this, 'memberJoined'));\n\n      _this.channels.on('memberLeft', _this.emit.bind(_this, 'memberLeft'));\n\n      _this.channels.on('memberUpdated', function (args) {\n        return _this.emit('memberUpdated', args);\n      });\n\n      _this.channels.on('messageAdded', _this.emit.bind(_this, 'messageAdded'));\n\n      _this.channels.on('messageUpdated', function (args) {\n        return _this.emit('messageUpdated', args);\n      });\n\n      _this.channels.on('messageRemoved', _this.emit.bind(_this, 'messageRemoved'));\n\n      _this.channels.on('typingStarted', _this.emit.bind(_this, 'typingStarted'));\n\n      _this.channels.on('typingEnded', _this.emit.bind(_this, 'typingEnded'));\n\n      return _this.channels.fetchChannels();\n    }).then(function () {\n      return _this.channels;\n    });\n\n    _this.services.notificationClient.on('connectionStateChanged', function (state) {\n      var changedConnectionState = null;\n\n      switch (state) {\n        case 'connected':\n          changedConnectionState = 'connected';\n          break;\n\n        case 'denied':\n          changedConnectionState = 'denied';\n          break;\n\n        case 'disconnecting':\n          changedConnectionState = 'disconnecting';\n          break;\n\n        case 'disconnected':\n          changedConnectionState = 'disconnected';\n          break;\n\n        default:\n          changedConnectionState = 'connecting';\n      }\n\n      if (changedConnectionState !== _this.connectionState) {\n        _this.connectionState = changedConnectionState;\n\n        _this.emit('connectionStateChanged', _this.connectionState);\n      }\n    });\n\n    _this.fpaToken = token;\n    return _this;\n  }\n  /**\n   * Factory method to create Chat client instance.\n   *\n   * @param {String} token - Access token\n   * @param {Client#ClientOptions} options - Options to customize the Client\n   * @returns {Promise<Client>}\n   */\n\n\n  (0, _createClass3.default)(Client, [{\n    key: \"subscribeToPushNotifications\",\n    value: function subscribeToPushNotifications(channelType) {\n      var _this2 = this;\n\n      var subscriptions = [];\n      [notificationtypes_1.NotificationTypes.NEW_MESSAGE, notificationtypes_1.NotificationTypes.ADDED_TO_CHANNEL, notificationtypes_1.NotificationTypes.INVITED_TO_CHANNEL, notificationtypes_1.NotificationTypes.REMOVED_FROM_CHANNEL, notificationtypes_1.NotificationTypes.TYPING_INDICATOR, notificationtypes_1.NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {\n        subscriptions.push(_this2.services.notificationClient.subscribe(messageType, channelType));\n      });\n      return _promise2.default.all(subscriptions);\n    }\n  }, {\n    key: \"unsubscribeFromPushNotifications\",\n    value: function unsubscribeFromPushNotifications(channelType) {\n      var _this3 = this;\n\n      var subscriptions = [];\n      [notificationtypes_1.NotificationTypes.NEW_MESSAGE, notificationtypes_1.NotificationTypes.ADDED_TO_CHANNEL, notificationtypes_1.NotificationTypes.INVITED_TO_CHANNEL, notificationtypes_1.NotificationTypes.REMOVED_FROM_CHANNEL, notificationtypes_1.NotificationTypes.TYPING_INDICATOR, notificationtypes_1.NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {\n        subscriptions.push(_this3.services.notificationClient.unsubscribe(messageType, channelType));\n      });\n      return _promise2.default.all(subscriptions);\n    }\n  }, {\n    key: \"initialize\",\n    value: function () {\n      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {\n        var _this4 = this;\n\n        var links, options;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.sessionPromise;\n\n              case 2:\n                Client.supportedPushChannels.forEach(function (channelType) {\n                  return _this4.subscribeToPushNotifications(channelType);\n                });\n                _context.next = 5;\n                return this.services.session.getSessionLinks();\n\n              case 5:\n                links = _context.sent;\n                this.services.publicChannels = new publicchannels_1.PublicChannels(this, this.services, links.publicChannelsUrl);\n                this.services.userChannels = new userchannels_1.UserChannels(this, this.services, links.myChannelsUrl);\n                options = (0, _assign2.default)(this.options);\n                options.transport = null;\n                this.services.mcsClient = new twilio_mcs_client_1.McsClient(this.fpaToken, links.mediaServiceUrl, options);\n                _context.next = 13;\n                return this.services.typingIndicator.initialize();\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function initialize() {\n        return _ref.apply(this, arguments);\n      }\n\n      return initialize;\n    }()\n    /**\n     * Gracefully shutting down library instance.\n     * @public\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"shutdown\",\n    value: function () {\n      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.services.twilsockClient.disconnect();\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function shutdown() {\n        return _ref2.apply(this, arguments);\n      }\n\n      return shutdown;\n    }()\n    /**\n     * Update the token used by the Client and re-register with Programmable Chat services.\n     * @param {String} token - Access token\n     * @public\n     * @returns {Promise<Client>}\n     */\n\n  }, {\n    key: \"updateToken\",\n    value: function () {\n      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(token) {\n        var _this5 = this;\n\n        return _regenerator2.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                log.info('updateToken');\n\n                if (token) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw new Error(MSG_NO_TOKEN);\n\n              case 3:\n                if (!(this.fpaToken === token)) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this);\n\n              case 5:\n                _context3.next = 7;\n                return this.services.twilsockClient.updateToken(token).then(function () {\n                  return _this5.fpaToken = token;\n                }).then(function () {\n                  return _this5.services.mcsClient.updateToken(token);\n                }).then(function () {\n                  return _this5.sessionPromise;\n                });\n\n              case 7:\n                return _context3.abrupt(\"return\", this);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateToken(_x) {\n        return _ref3.apply(this, arguments);\n      }\n\n      return updateToken;\n    }()\n    /**\n     * Get a known Channel by its SID.\n     * @param {String} channelSid - Channel sid\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"getChannelBySid\",\n    value: function () {\n      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(channelSid) {\n        var _this6 = this;\n\n        return _regenerator2.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(!channelSid || typeof channelSid !== 'string')) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('Client.getChannelBySid requires a <String>channelSid parameter');\n\n              case 2:\n                return _context4.abrupt(\"return\", this.channels.syncListRead.promise.then(function () {\n                  return _this6.channels.getChannel(channelSid).then(function (channel) {\n                    return channel || _this6.services.publicChannels.getChannelBySid(channelSid).then(function (x) {\n                      return _this6.channels.pushChannel(x);\n                    });\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getChannelBySid(_x2) {\n        return _ref4.apply(this, arguments);\n      }\n\n      return getChannelBySid;\n    }()\n    /**\n     * Get a known Channel by its unique identifier name.\n     * @param {String} uniqueName - The unique identifier name of the Channel to get\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"getChannelByUniqueName\",\n    value: function () {\n      var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(uniqueName) {\n        var _this7 = this;\n\n        return _regenerator2.default.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(!uniqueName || typeof uniqueName !== 'string')) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error('Client.getChannelByUniqueName requires a <String>uniqueName parameter');\n\n              case 2:\n                return _context5.abrupt(\"return\", this.channels.syncListRead.promise.then(function () {\n                  return _this7.services.publicChannels.getChannelByUniqueName(uniqueName).then(function (x) {\n                    return _this7.channels.pushChannel(x);\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getChannelByUniqueName(_x3) {\n        return _ref5.apply(this, arguments);\n      }\n\n      return getChannelByUniqueName;\n    }()\n    /**\n     * Get the current list of all subscribed Channels.\n     * @returns {Promise<Paginator<Channel>>}\n     */\n\n  }, {\n    key: \"getSubscribedChannels\",\n    value: function getSubscribedChannels(args) {\n      return this.channelsPromise.then(function (channels) {\n        return channels.getChannels(args);\n      });\n    }\n    /**\n     * Get array of Channels locally known to Client in provided sorting order.\n     * Locally known channels are the ones created and/or joined during client runtime and currently logged in User subscribed Channels.\n     * To ensure full list of subscribed Channels fetched - call the {@link Client#getSubscribedChannels} method\n     * and fetch all pages with help of {@link Paginator#nextPage} method.\n     * @param {Client#ChannelSortingOptions} [sortingOptions] - Options for the Channel sorting\n     * @returns {Promise<Array<Channel>>}\n     */\n\n  }, {\n    key: \"getLocalChannels\",\n    value: function getLocalChannels(sortingOptions) {\n      return this.channelsPromise.then(function (channels) {\n        var result = [];\n        channels.channels.forEach(function (value) {\n          result.push(value);\n        });\n        var sortingOrder = 'ascending';\n\n        if (sortingOptions && sortingOptions.order) {\n          if (sortingOptions.order === 'descending') {\n            sortingOrder = 'descending';\n          } else if (sortingOptions.order !== 'ascending') {\n            throw new Error('Sorting order should be `ascending` or `descending`');\n          }\n        }\n\n        if (sortingOptions && sortingOptions.criteria) {\n          if (sortingOptions.criteria === 'lastMessage') {\n            result.sort(function (a, b) {\n              return Client.compareChannelsByLastMessage(a, b, sortingOrder);\n            });\n          } else if (sortingOptions.criteria === 'uniqueName') {\n            result.sort(function (a, b) {\n              return Client.compareChannelsByStringProperty(a.uniqueName, b.uniqueName, sortingOrder);\n            });\n          } else if (sortingOptions.criteria === 'friendlyName') {\n            result.sort(function (a, b) {\n              return Client.compareChannelsByStringProperty(a.friendlyName, b.friendlyName, sortingOrder);\n            });\n          } else {\n            throw new Error('Sorting criteria should be one of `lastMessage`, `uniqueName` or `friendlyName`');\n          }\n        }\n\n        return result;\n      });\n    }\n  }, {\n    key: \"getPublicChannelDescriptors\",\n\n    /**\n     * Get the public channels directory content.\n     * @returns {Promise<Paginator<ChannelDescriptor>>}\n     */\n    value: function getPublicChannelDescriptors() {\n      return this.services.publicChannels.getChannels();\n    }\n    /**\n     * Get the User's (created by, joined or invited to) channels directory content.\n     * @returns {Promise<Paginator<ChannelDescriptor>>}\n     */\n\n  }, {\n    key: \"getUserChannelDescriptors\",\n    value: function getUserChannelDescriptors() {\n      return this.services.userChannels.getChannels();\n    }\n    /**\n     * Create a Channel on the server and subscribe to its events.\n     * Default options are public Channel type with empty uniqueName and friendlyName.\n     * @param {Client#CreateChannelOptions} [options] - Options for the Channel\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"createChannel\",\n    value: function createChannel(options) {\n      options = options || {};\n      return this.channelsPromise.then(function (channelsEntity) {\n        return channelsEntity.addChannel(options);\n      });\n    }\n    /**\n     * Registers for push notifications.\n     * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported\n     * @param {string} registrationId - Push notification id provided by platform\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"setPushRegistrationId\",\n    value: function () {\n      var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(channelType, registrationId) {\n        var _this8 = this;\n\n        return _regenerator2.default.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(Client.supportedPushChannels.indexOf(channelType) === -1)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new Error('Invalid or unsupported channelType: ' + channelType);\n\n              case 2:\n                _context6.next = 4;\n                return this.subscribeToPushNotifications(channelType).then(function () {\n                  return _this8.services.notificationClient.setPushRegistrationId(registrationId, channelType);\n                });\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function setPushRegistrationId(_x4, _x5) {\n        return _ref6.apply(this, arguments);\n      }\n\n      return setPushRegistrationId;\n    }()\n    /**\n     * Unregisters from push notifications.\n     * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"unsetPushRegistrationId\",\n    value: function () {\n      var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(channelType) {\n        return _regenerator2.default.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(Client.supportedPushChannels.indexOf(channelType) === -1)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new Error('Invalid or unsupported channelType: ' + channelType);\n\n              case 2:\n                _context7.next = 4;\n                return this.unsubscribeFromPushNotifications(channelType);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function unsetPushRegistrationId(_x6) {\n        return _ref7.apply(this, arguments);\n      }\n\n      return unsetPushRegistrationId;\n    }()\n  }, {\n    key: \"handlePushNotification\",\n\n    /**\n     * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.\n     * @param {Object} notificationPayload - Push notification payload\n     * @returns {void|Error}\n     */\n    value: function () {\n      var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(notificationPayload) {\n        return _regenerator2.default.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                log.debug('handlePushNotification, notificationPayload=', notificationPayload);\n                this.emit('pushNotification', Client.parsePushNotification(notificationPayload));\n\n              case 2:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function handlePushNotification(_x7) {\n        return _ref8.apply(this, arguments);\n      }\n\n      return handlePushNotification;\n    }()\n    /**\n     * Gets user for given identity, if it's in subscribed list - then return the user object from it,\n     * if not - then subscribes and adds user to the subscribed list.\n     * @param {String} identity - Identity of User\n     * @returns {Promise<User>} Fully initialized user\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function getUser(identity) {\n      return this.services.users.getUser(identity);\n    }\n    /**\n     * Gets user descriptor for given identity.\n     * @param {String} identity - Identity of User\n     * @returns {Promise<UserDescriptor>} User descriptor\n     */\n\n  }, {\n    key: \"getUserDescriptor\",\n    value: function () {\n      var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9(identity) {\n        return _regenerator2.default.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                return _context9.abrupt(\"return\", this.services.users.getUserDescriptor(identity));\n\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getUserDescriptor(_x8) {\n        return _ref9.apply(this, arguments);\n      }\n\n      return getUserDescriptor;\n    }()\n    /**\n     * @returns {Promise<Array<User>>} List of subscribed User objects\n     */\n\n  }, {\n    key: \"getSubscribedUsers\",\n    value: function () {\n      var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10() {\n        return _regenerator2.default.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                return _context10.abrupt(\"return\", this.services.users.getSubscribedUsers());\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getSubscribedUsers() {\n        return _ref10.apply(this, arguments);\n      }\n\n      return getSubscribedUsers;\n    }()\n  }, {\n    key: \"user\",\n    get: function get() {\n      return this.services.users.myself;\n    }\n  }, {\n    key: \"reachabilityEnabled\",\n    get: function get() {\n      return this.services.session.reachabilityEnabled;\n    }\n  }, {\n    key: \"token\",\n    get: function get() {\n      return this.fpaToken;\n    }\n  }], [{\n    key: \"create\",\n    value: function () {\n      var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(token, options) {\n        var client;\n        return _regenerator2.default.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                client = new Client(token, options);\n                _context11.next = 3;\n                return client.initialize();\n\n              case 3:\n                return _context11.abrupt(\"return\", client);\n\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function create(_x9, _x10) {\n        return _ref11.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"compareChannelsByLastMessage\",\n    value: function compareChannelsByLastMessage(a, b, order) {\n      if (a.lastMessage && b.lastMessage) {\n        if (a.lastMessage.timestamp && b.lastMessage.timestamp) {\n          if (a.lastMessage.timestamp.getTime() < b.lastMessage.timestamp.getTime()) {\n            return order === 'ascending' ? -1 : 1;\n          } else {\n            return order === 'ascending' ? 1 : -1;\n          }\n        } else {\n          if (a.lastMessage.timestamp) {\n            return -1;\n          } else if (b.lastMessage.timestamp) {\n            return 1;\n          }\n        }\n      }\n\n      if (a.lastMessage) {\n        return -1;\n      } else if (b.lastMessage) {\n        return 1;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"compareChannelsByStringProperty\",\n    value: function compareChannelsByStringProperty(str1, str2, order) {\n      if (str1 && str2) {\n        return order === 'ascending' ? str1.localeCompare(str2) : -1 * str1.localeCompare(str2);\n      } else if (str1) {\n        return -1;\n      } else if (str2) {\n        return 1;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"parsePushNotificationChatData\",\n    value: function parsePushNotificationChatData(data) {\n      var result = {};\n\n      for (var key in Client.supportedPushDataFields) {\n        if (typeof data[key] !== 'undefined' && data[key] !== null) {\n          if (key === 'message_index') {\n            if (util_1.parseToNumber(data[key]) !== null) {\n              result[Client.supportedPushDataFields[key]] = Number(data[key]);\n            }\n          } else {\n            result[Client.supportedPushDataFields[key]] = data[key];\n          }\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object\n     * @param {Object} notificationPayload - Push notification payload\n     * @returns {PushNotification|Error}\n     */\n\n  }, {\n    key: \"parsePushNotification\",\n    value: function parsePushNotification(notificationPayload) {\n      log.debug('parsePushNotification, notificationPayload=', notificationPayload);\n\n      if (typeof notificationPayload === 'undefined' || notificationPayload === null) {\n        throw new Error('Push notification payload should be provided');\n      } // APNS specifics\n\n\n      if (typeof notificationPayload.aps !== 'undefined') {\n        if (!notificationPayload.twi_message_type) {\n          throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');\n        }\n\n        var data = Client.parsePushNotificationChatData(notificationPayload);\n        var apsPayload = notificationPayload.aps;\n        var body = null;\n        var title = null;\n\n        if (typeof apsPayload.alert === 'string') {\n          body = apsPayload.alert || null;\n        } else {\n          body = apsPayload.alert.body || null;\n          title = apsPayload.alert.title || null;\n        }\n\n        return new pushnotification_1.PushNotification({\n          title: title,\n          body: body,\n          sound: apsPayload.sound || null,\n          badge: apsPayload.badge || null,\n          action: apsPayload.category || null,\n          type: notificationPayload.twi_message_type,\n          data: data\n        });\n      } // FCM/GCM specifics\n\n\n      if (typeof notificationPayload.data !== 'undefined') {\n        var dataPayload = notificationPayload.data;\n\n        if (!dataPayload.twi_message_type) {\n          throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');\n        }\n\n        var _data = Client.parsePushNotificationChatData(notificationPayload.data);\n\n        return new pushnotification_1.PushNotification({\n          title: dataPayload.twi_title || null,\n          body: dataPayload.twi_body || null,\n          sound: dataPayload.twi_sound || null,\n          badge: null,\n          action: dataPayload.twi_action || null,\n          type: dataPayload.twi_message_type,\n          data: _data\n        });\n      }\n\n      throw new Error('Provided push notification payload is not Programmable Chat notification');\n    }\n  }]);\n  return Client;\n}(events_1.EventEmitter);\n\nexports.Client = Client;\nClient.version = SDK_VERSION;\nClient.supportedPushChannels = ['fcm', 'apn', 'gcm'];\nClient.supportedPushDataFields = {\n  'channel_sid': 'channelSid',\n  'message_sid': 'messageSid',\n  'message_index': 'messageIndex'\n};\nexports.default = Client;\n/**\n * Fired when a Channel becomes visible to the Client.\n * Fired for created and not joined private channels and for all type of channels Client has joined or invited to.\n * @event Client#channelAdded\n * @type {Channel}\n */\n\n/**\n * Fired when the Client is invited to a Channel.\n * @event Client#channelInvited\n * @type {Channel}\n */\n\n/**\n * Fired when the Client joins a Channel.\n * @event Client#channelJoined\n * @type {Channel}\n */\n\n/**\n * Fired when the Client leaves a Channel.\n * @event Client#channelLeft\n * @type {Channel}\n */\n\n/**\n * Fired when a Channel is no longer visible to the Client.\n * @event Client#channelRemoved\n * @type {Channel}\n */\n\n/**\n * Fired when a Channel's attributes or metadata have been updated.\n * During Channel's {@link Client.create| creation and initialization} this event might be fired multiple times\n * for same joined or created Channel as new data is arriving from different sources.\n * @event Client#channelUpdated\n * @type {Object}\n * @property {Channel} channel - Updated Channel\n * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons\n */\n\n/**\n * Fired when Client's connection state has been changed.\n * @event Client#connectionStateChanged\n * @type {Client#ConnectionState}\n */\n\n/**\n * Fired when a Member has joined the Channel.\n * @event Client#memberJoined\n * @type {Member}\n */\n\n/**\n * Fired when a Member has left the Channel.\n * @event Client#memberLeft\n * @type {Member}\n */\n\n/**\n * Fired when a Member's fields has been updated.\n * @event Client#memberUpdated\n * @type {Object}\n * @property {Member} member - Updated Member\n * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons\n */\n\n/**\n * Fired when a new Message has been added to the Channel on the server.\n * @event Client#messageAdded\n * @type {Message}\n */\n\n/**\n * Fired when Message is removed from Channel's message list.\n * @event Client#messageRemoved\n * @type {Message}\n */\n\n/**\n * Fired when an existing Message's fields are updated with new values.\n * @event Client#messageUpdated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n\n/**\n * Fired when token is about to expire and needs to be updated.\n * @event Client#tokenAboutToExpire\n * @type {void}\n */\n\n/**\n * Fired when token is expired.\n * @event Client#tokenExpired\n * @type {void}\n */\n\n/**\n * Fired when a Member has stopped typing.\n * @event Client#typingEnded\n * @type {Member}\n */\n\n/**\n * Fired when a Member has started typing.\n * @event Client#typingStarted\n * @type {Member}\n */\n\n/**\n * Fired when client received (and parsed) push notification via one of push channels (apn, gcm, fcm).\n * @event Client#pushNotification\n * @type {PushNotification}\n */\n\n/**\n * Fired when the Client is subscribed to a User.\n * @event Client#userSubscribed\n * @type {User}\n */\n\n/**\n * Fired when the Client is unsubscribed from a User.\n * @event Client#userUnsubscribed\n * @type {User}\n */\n\n/**\n * Fired when the User's properties or reachability status have been updated.\n * @event Client#userUpdated\n * @type {Object}\n * @property {User} user - Updated User\n * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons\n */\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @event Client#connectionError\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n */","map":null,"metadata":{},"sourceType":"script"}