{"ast":null,"code":"'use strict';\n\nexports.__esModule = true; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nfunction Visitor() {\n  this.parents = [];\n}\n\nVisitor.prototype = {\n  constructor: Visitor,\n  mutating: false,\n  // Visits a given value. If mutating, will replace the value if necessary.\n  acceptKey: function acceptKey(node, name) {\n    var value = this.accept(node[name]);\n\n    if (this.mutating) {\n      // Hacky sanity check: This may have a few false positives for type for the helper\n      // methods but will generally do the right thing without a lot of overhead.\n      if (value && !Visitor.prototype[value.type]) {\n        throw new _exception2['default']('Unexpected node type \"' + value.type + '\" found when accepting ' + name + ' on ' + node.type);\n      }\n\n      node[name] = value;\n    }\n  },\n  // Performs an accept operation with added sanity check to ensure\n  // required keys are not removed.\n  acceptRequired: function acceptRequired(node, name) {\n    this.acceptKey(node, name);\n\n    if (!node[name]) {\n      throw new _exception2['default'](node.type + ' requires ' + name);\n    }\n  },\n  // Traverses a given array. If mutating, empty respnses will be removed\n  // for child elements.\n  acceptArray: function acceptArray(array) {\n    for (var i = 0, l = array.length; i < l; i++) {\n      this.acceptKey(array, i);\n\n      if (!array[i]) {\n        array.splice(i, 1);\n        i--;\n        l--;\n      }\n    }\n  },\n  accept: function accept(object) {\n    if (!object) {\n      return;\n    }\n    /* istanbul ignore next: Sanity code */\n\n\n    if (!this[object.type]) {\n      throw new _exception2['default']('Unknown type: ' + object.type, object);\n    }\n\n    if (this.current) {\n      this.parents.unshift(this.current);\n    }\n\n    this.current = object;\n    var ret = this[object.type](object);\n    this.current = this.parents.shift();\n\n    if (!this.mutating || ret) {\n      return ret;\n    } else if (ret !== false) {\n      return object;\n    }\n  },\n  Program: function Program(program) {\n    this.acceptArray(program.body);\n  },\n  MustacheStatement: visitSubExpression,\n  Decorator: visitSubExpression,\n  BlockStatement: visitBlock,\n  DecoratorBlock: visitBlock,\n  PartialStatement: visitPartial,\n  PartialBlockStatement: function PartialBlockStatement(partial) {\n    visitPartial.call(this, partial);\n    this.acceptKey(partial, 'program');\n  },\n  ContentStatement: function ContentStatement()\n  /* content */\n  {},\n  CommentStatement: function CommentStatement()\n  /* comment */\n  {},\n  SubExpression: visitSubExpression,\n  PathExpression: function PathExpression()\n  /* path */\n  {},\n  StringLiteral: function StringLiteral()\n  /* string */\n  {},\n  NumberLiteral: function NumberLiteral()\n  /* number */\n  {},\n  BooleanLiteral: function BooleanLiteral()\n  /* bool */\n  {},\n  UndefinedLiteral: function UndefinedLiteral()\n  /* literal */\n  {},\n  NullLiteral: function NullLiteral()\n  /* literal */\n  {},\n  Hash: function Hash(hash) {\n    this.acceptArray(hash.pairs);\n  },\n  HashPair: function HashPair(pair) {\n    this.acceptRequired(pair, 'value');\n  }\n};\n\nfunction visitSubExpression(mustache) {\n  this.acceptRequired(mustache, 'path');\n  this.acceptArray(mustache.params);\n  this.acceptKey(mustache, 'hash');\n}\n\nfunction visitBlock(block) {\n  visitSubExpression.call(this, block);\n  this.acceptKey(block, 'program');\n  this.acceptKey(block, 'inverse');\n}\n\nfunction visitPartial(partial) {\n  this.acceptRequired(partial, 'name');\n  this.acceptArray(partial.params);\n  this.acceptKey(partial, 'hash');\n}\n\nexports['default'] = Visitor;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}