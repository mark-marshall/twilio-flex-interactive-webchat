{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\n\nvar events_1 = require(\"events\");\n\nvar twilsock_1 = require(\"twilsock\");\n\nvar configuration_1 = require(\"./configuration\");\n\nvar registrar_1 = require(\"./registrar\");\n\nvar logger_1 = require(\"./logger\");\n/**\n * @class\n * @alias Notifications\n * @classdesc The helper library for the notification service.\n * Provides high level api for creating and managing notification subscriptions and receiving messages\n * Creates the instance of Notification helper library\n *\n * @constructor\n * @param {string} token - Twilio access token\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\n */\n\n\nvar Client = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Client, _events_1$EventEmitte);\n\n  var _super = _createSuper(Client);\n\n  function Client(token) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Client);\n\n    _this = _super.call(this);\n\n    if (!token || token.length === 0) {\n      throw new Error('Token is required for Notifications client');\n    }\n\n    options.logLevel = options.logLevel || 'error';\n    logger_1.log.setLevel(options.logLevel);\n    var minTokenRefreshInterval = options.minTokenRefreshInterval || 10000;\n    var productId = options.productId || 'notifications';\n    options.twilsockClient = options.twilsockClient || new twilsock_1.TwilsockClient(token, productId, options);\n    options.transport = options.transport || options.twilsockClient;\n    _this.services = {\n      twilsock: options.twilsockClient,\n      transport: options.transport,\n      config: new configuration_1.Configuration(null, options)\n    };\n    _this.registrar = new registrar_1.Registrar(productId, _this.services.transport, _this.services.twilsock, _this.services.config);\n    _this.reliableTransportState = {\n      overall: false,\n      transport: false,\n      registration: false,\n      lastEmitted: null\n    };\n\n    _this._onTransportStateChange(_this.services.twilsock.isConnected);\n\n    _this.registrar.on('transportReady', function (state) {\n      _this._onRegistrationStateChange(state ? 'registered' : '');\n    });\n\n    _this.registrar.on('stateChanged', function (state) {\n      _this._onRegistrationStateChange(state);\n    });\n\n    _this.registrar.on('needReliableTransport', _this._onNeedReliableTransport.bind(_assertThisInitialized(_this)));\n\n    _this.services.twilsock.on('message', function (type, message) {\n      return _this._routeMessage(type, message);\n    });\n\n    _this.services.twilsock.on('connected', function (notificationId) {\n      _this._onTransportStateChange(true);\n\n      _this.registrar.setNotificationId('twilsock', notificationId);\n    });\n\n    _this.services.twilsock.on('disconnected', function () {\n      _this._onTransportStateChange(false);\n    });\n\n    _this.services.config.updateToken(token);\n\n    _this.registrar.updateToken(token);\n\n    return _this;\n  }\n\n  _createClass(Client, [{\n    key: \"connectionState\",\n    get: function get() {\n      if (this.services.twilsock.state === 'disconnected') {\n        return 'disconnected';\n      } else if (this.services.twilsock.state === 'disconnecting') {\n        return 'disconnecting';\n      } else if (this.services.twilsock.state === 'connected' && this.reliableTransportState.registration) {\n        return 'connected';\n      } else if (this.services.twilsock.state === 'rejected') {\n        return 'denied';\n      }\n\n      return 'connecting';\n    }\n    /**\n     * Routes messages to the external subscribers\n     * @private\n     */\n\n  }, {\n    key: \"_routeMessage\",\n    value: function _routeMessage(type, message) {\n      logger_1.log.trace('Message arrived: ', type, message);\n      this.emit('message', type, message);\n    }\n  }, {\n    key: \"_onNeedReliableTransport\",\n    value: function _onNeedReliableTransport(isNeeded) {\n      if (isNeeded) {\n        this.services.twilsock.connect();\n      } else {\n        this.services.twilsock.disconnect();\n      }\n    }\n  }, {\n    key: \"_onRegistrationStateChange\",\n    value: function _onRegistrationStateChange(state) {\n      this.reliableTransportState.registration = state === 'registered';\n\n      this._updateTransportState();\n    }\n  }, {\n    key: \"_onTransportStateChange\",\n    value: function _onTransportStateChange(connected) {\n      this.reliableTransportState.transport = connected;\n\n      this._updateTransportState();\n    }\n  }, {\n    key: \"_updateTransportState\",\n    value: function _updateTransportState() {\n      var overallState = this.reliableTransportState.transport && this.reliableTransportState.registration;\n\n      if (this.reliableTransportState.overall !== overallState) {\n        this.reliableTransportState.overall = overallState;\n        logger_1.log.info('Transport ready:', overallState);\n        this.emit('transportReady', overallState);\n      }\n\n      if (this.reliableTransportState.lastEmitted !== this.connectionState) {\n        this.reliableTransportState.lastEmitted = this.connectionState;\n        this.emit('connectionStateChanged', this.connectionState);\n      }\n    }\n    /**\n     * Adds the subscription for the given message type\n     * @param {string} messageType The type of message that you want to receive\n     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(messageType) {\n      var channelType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'twilsock';\n      logger_1.log.trace('Add subscriptions for message type: ', messageType, channelType);\n      return this.registrar.subscribe(messageType, channelType);\n    }\n    /**\n     * Remove the subscription for the particular message type\n     * @param {string} messageType The type of message that you don't want to receive anymore\n     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(messageType) {\n      var channelType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'twilsock';\n      logger_1.log.trace('Remove subscriptions for message type: ', messageType, channelType);\n      return this.registrar.unsubscribe(messageType, channelType);\n    }\n    /**\n     * Handle incoming push notification.\n     * Client application should call this method when it receives push notifications and pass the received data\n     * @param {Object} message push message\n     * @return {PushNotification}\n     */\n\n  }, {\n    key: \"handlePushNotification\",\n    value: function handlePushNotification(message) {\n      return {\n        messageType: message.twi_message_type,\n        payload: message.payload\n      };\n    }\n    /**\n     * Set APN/GCM/FCM token to enable application register for a push messages\n     * @param {string} gcmToken/fcmToken Token received from GCM/FCM system\n     */\n\n  }, {\n    key: \"setPushRegistrationId\",\n    value: function setPushRegistrationId(registrationId, channelType) {\n      logger_1.log.trace('Set push registration id', registrationId, channelType);\n      this.registrar.setNotificationId(channelType, registrationId);\n    }\n    /**\n     * Updates auth token for registration\n     * @param {string} token Authentication token for registrations\n     */\n\n  }, {\n    key: \"updateToken\",\n    value: function () {\n      var _updateToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(token) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger_1.log.info('authTokenUpdated');\n\n                if (!(this.services.config.token === token)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 3:\n                _context.next = 5;\n                return this.services.twilsock.updateToken(token);\n\n              case 5:\n                this.services.config.updateToken(token);\n                this.registrar.updateToken(token);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function updateToken(_x) {\n        return _updateToken.apply(this, arguments);\n      }\n\n      return updateToken;\n    }()\n  }]);\n\n  return Client;\n}(events_1.EventEmitter);\n\nexports.Client = Client;\n/**\n * Fired when new message arrived.\n * @param {Object} message`\n * @event Client#message\n */\n\n/**\n * Fired when transport state has changed\n * @param {boolean} transport state\n * @event Client#transportReady\n */\n\n/**\n * Fired when transport state has been changed\n * @param {string} transport state\n * @event Client#connectionStateChanged\n */\n\n/**\n * These options can be passed to Client constructor\n * @typedef {Object} Notifications#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n */","map":null,"metadata":{},"sourceType":"script"}