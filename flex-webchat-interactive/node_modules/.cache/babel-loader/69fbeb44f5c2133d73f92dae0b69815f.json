{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createClass = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PacketInterface = exports.PacketResponse = void 0;\n\nvar logger_1 = require(\"./logger\");\n\nvar uuid_1 = require(\"uuid\");\n\nvar twilsockerror_1 = require(\"./error/twilsockerror\");\n\nvar twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\n\nvar parser_1 = require(\"./parser\");\n\nvar Messages = require(\"./protocol/messages\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar REQUEST_TIMEOUT = 30000;\n\nfunction isHttpSuccess(code) {\n  return code >= 200 && code < 300;\n}\n/**\n * Makes sure that body is properly stringified\n */\n\n\nfunction preparePayload(payload) {\n  switch (typeof payload) {\n    case 'undefined':\n      return '';\n\n    case 'object':\n      return JSON.stringify(payload);\n\n    default:\n      return payload;\n  }\n}\n\nvar PacketRequest = function PacketRequest() {\n  _classCallCheck(this, PacketRequest);\n};\n\nvar PacketResponse = function PacketResponse() {\n  _classCallCheck(this, PacketResponse);\n};\n\nexports.PacketResponse = PacketResponse;\n\nvar PacketInterface = /*#__PURE__*/function () {\n  function PacketInterface(channel, config) {\n    var _this = this;\n\n    _classCallCheck(this, PacketInterface);\n\n    this.config = config;\n    this.activeRequests = new Map();\n    this.channel = channel;\n    this.channel.on('reply', function (reply) {\n      return _this.processReply(reply);\n    });\n    this.channel.on('disconnected', function () {\n      _this.activeRequests.forEach(function (descriptor) {\n        clearTimeout(descriptor.timeout);\n        descriptor.reject(new twilsockerror_1.TwilsockError('disconnected'));\n      });\n\n      _this.activeRequests.clear();\n    });\n  }\n\n  _createClass(PacketInterface, [{\n    key: \"processReply\",\n    value: function processReply(reply) {\n      var request = this.activeRequests.get(reply.id);\n\n      if (request) {\n        clearTimeout(request.timeout);\n        this.activeRequests.delete(reply.id);\n\n        if (!isHttpSuccess(reply.status.code)) {\n          request.reject(new twilsockreplyerror_1.TwilsockReplyError('Transport failure: ' + reply.status.status, reply));\n          logger_1.log.trace('message rejected');\n        } else {\n          request.resolve(reply);\n        }\n      }\n    }\n  }, {\n    key: \"storeRequest\",\n    value: function storeRequest(id, resolve, reject) {\n      var requestDescriptor = {\n        resolve: resolve,\n        reject: reject,\n        timeout: setTimeout(function () {\n          logger_1.log.trace('request', id, 'is timed out');\n          reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout: ' + id));\n        }, REQUEST_TIMEOUT)\n      };\n      this.activeRequests.set(id, requestDescriptor);\n    }\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      this.activeRequests.forEach(function (descriptor) {\n        clearTimeout(descriptor.timeout);\n        descriptor.reject(new twilsockerror_1.TwilsockError('Twilsock: request cancelled by user'));\n      });\n      this.activeRequests.clear();\n    }\n  }, {\n    key: \"sendInit\",\n    value: function () {\n      var _sendInit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var metadata, message, response;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger_1.log.trace('sendInit');\n                metadata = metadata_1.Metadata.getMetadata(this.config);\n                message = new Messages.Init(this.config.token, this.config.continuationToken, metadata, this.config.initRegistrations, this.config.tweaks);\n                _context.next = 5;\n                return this.sendWithReply(message);\n\n              case 5:\n                response = _context.sent;\n                return _context.abrupt(\"return\", new Messages.InitReply(response.id, response.header.continuation_token, response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info, new Set(response.header.capabilities)));\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sendInit() {\n        return _sendInit.apply(this, arguments);\n      }\n\n      return sendInit;\n    }()\n  }, {\n    key: \"sendClose\",\n    value: function sendClose() {\n      var message = new Messages.Close(); //@todo send telemetry AnyEventsIncludingUnfinished\n\n      this.send(message);\n    }\n  }, {\n    key: \"sendWithReply\",\n    value: function sendWithReply(header, payload) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        var id = _this2.send(header, payload);\n\n        _this2.storeRequest(id, resolve, reject);\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(header, payload) {\n      header.id = header.id || \"TM\".concat(uuid_1.v4());\n      var message = parser_1.Parser.createPacket(header, preparePayload(payload));\n\n      try {\n        this.channel.send(message);\n        return header.id;\n      } catch (e) {\n        logger_1.log.debug('failed to send ', header, e);\n        logger_1.log.trace(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.channel.isConnected;\n    }\n  }]);\n\n  return PacketInterface;\n}();\n\nexports.PacketInterface = PacketInterface;","map":null,"metadata":{},"sourceType":"script"}