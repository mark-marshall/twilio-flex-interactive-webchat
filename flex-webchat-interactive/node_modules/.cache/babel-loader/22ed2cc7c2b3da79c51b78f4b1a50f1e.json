{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/mmarshall/Desktop/twilio-flex-interactive-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar operation_retrier_1 = require(\"operation-retrier\");\n/**\n * Retrier with backoff override capability\n*/\n\n\nvar BackoffRetrier = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(BackoffRetrier, _events_1$EventEmitte);\n\n  function BackoffRetrier(options) {\n    var _this;\n\n    _classCallCheck(this, BackoffRetrier);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BackoffRetrier).call(this));\n    _this.options = options ? Object.assign({}, options) : {};\n    return _this;\n  }\n\n  _createClass(BackoffRetrier, [{\n    key: \"start\",\n\n    /**\n     * Should be called once per attempt series to start retrier.\n    */\n    value: function start() {\n      if (this.inProgress) {\n        throw new Error('Already waiting for next attempt, call finishAttempt(success : boolean) to finish it');\n      }\n\n      this.createRetrier();\n    }\n    /**\n     * Should be called to stop retrier entirely.\n    */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.cleanRetrier();\n      this.newBackoff = null;\n      this.usedBackoff = null;\n    }\n    /**\n     * Modifies backoff for next attempt.\n     * Expected behavior:\n     * - If there was no backoff passed previously reschedulling next attempt to given backoff\n     * - If previous backoff was longer then ignoring this one.\n     * - If previous backoff was shorter then reschedulling with this one.\n     * With or without backoff retrier will keep growing normally.\n     * @param delay delay of next attempts in ms.\n     */\n\n  }, {\n    key: \"modifyBackoff\",\n    value: function modifyBackoff(delay) {\n      this.newBackoff = delay;\n    }\n    /**\n     * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.\n    */\n\n  }, {\n    key: \"attemptFailed\",\n    value: function attemptFailed() {\n      if (!this.inProgress) {\n        throw new Error('No attempt is in progress');\n      }\n\n      if (this.newBackoff) {\n        var shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;\n\n        if (shouldUseNewBackoff) {\n          this.createRetrier();\n        } else {\n          this.retrier.failed(new Error());\n        }\n      } else {\n        this.retrier.failed(new Error());\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.retrier) {\n        this.retrier.cancel();\n      }\n    }\n  }, {\n    key: \"cleanRetrier\",\n    value: function cleanRetrier() {\n      if (this.retrier) {\n        this.retrier.removeAllListeners();\n        this.retrier.cancel();\n        this.retrier = null;\n      }\n    }\n  }, {\n    key: \"getRetryPolicy\",\n    value: function getRetryPolicy() {\n      var clone = Object.assign({}, this.options);\n\n      if (this.newBackoff) {\n        clone.min = this.newBackoff;\n        clone.max = this.options.max && this.options.max > this.newBackoff ? this.options.max : this.newBackoff;\n      } // As we're always skipping first attempt we should add one extra if limit is present\n\n\n      clone.maxAttemptsCount = this.options.maxAttemptsCount ? this.options.maxAttemptsCount + 1 : undefined;\n      return clone;\n    }\n  }, {\n    key: \"createRetrier\",\n    value: function createRetrier() {\n      var _this2 = this;\n\n      this.cleanRetrier();\n      var retryPolicy = this.getRetryPolicy();\n      this.retrier = new operation_retrier_1.Retrier(retryPolicy);\n      this.retrier.once('attempt', function () {\n        _this2.retrier.on('attempt', function () {\n          return _this2.emit('attempt');\n        });\n\n        _this2.retrier.failed(new Error('Skipping first attempt'));\n      });\n      this.retrier.on('failed', function (err) {\n        return _this2.emit('failed', err);\n      });\n      this.usedBackoff = this.newBackoff;\n      this.newBackoff = null;\n      this.retrier.start().catch(function (err) {});\n    }\n  }, {\n    key: \"inProgress\",\n    get: function get() {\n      return !!this.retrier;\n    }\n  }]);\n\n  return BackoffRetrier;\n}(events_1.EventEmitter);\n\nexports.BackoffRetrier = BackoffRetrier;","map":null,"metadata":{},"sourceType":"script"}