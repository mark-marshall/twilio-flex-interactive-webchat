{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar telemetry_1 = require(\"../protocol/messages/telemetry\");\n\nvar logger_1 = require(\"../logger\");\n\nvar TelemetryEventDescription = /*#__PURE__*/function () {\n  function TelemetryEventDescription(title, details, start, end, type, id) {\n    _classCallCheck(this, TelemetryEventDescription);\n\n    this.title = title;\n    this.details = details;\n    this.start = start;\n    this.type = type;\n    this.id = id;\n    this.end = end;\n  } // Prepare telemetry event right before sending it.\n  // Convert times to relative.\n\n\n  _createClass(TelemetryEventDescription, [{\n    key: \"toTelemetryEvent\",\n    value: function toTelemetryEvent() {\n      // Fix dates\n      var now = new Date();\n      var actualStart = this.start;\n      var actualEnd = this.end ? this.end : now;\n\n      if (actualEnd < actualStart) {\n        var tmp = actualEnd;\n        actualEnd = actualStart;\n        actualStart = tmp;\n      } // Converting dates to relative offset from current moment in ms\n\n\n      var startOffset = actualStart.getTime() - now.getTime();\n      var endOffset = actualEnd.getTime() - now.getTime();\n      var result = new telemetry_1.TelemetryEvent(startOffset, endOffset, this.title, this.details, this.id, this.type);\n      return result;\n    }\n  }]);\n\n  return TelemetryEventDescription;\n}();\n\nexports.TelemetryEventDescription = TelemetryEventDescription;\nvar TelemetryPoint;\n\n(function (TelemetryPoint) {\n  TelemetryPoint[TelemetryPoint[\"Start\"] = 0] = \"Start\";\n  TelemetryPoint[TelemetryPoint[\"End\"] = 1] = \"End\";\n})(TelemetryPoint || (TelemetryPoint = {}));\n\nexports.TelemetryPoint = TelemetryPoint;\nvar EventSendingLimitation;\n\n(function (EventSendingLimitation) {\n  EventSendingLimitation[EventSendingLimitation[\"MinEventsPortion\"] = 0] = \"MinEventsPortion\";\n  EventSendingLimitation[EventSendingLimitation[\"AnyEvents\"] = 1] = \"AnyEvents\";\n  EventSendingLimitation[EventSendingLimitation[\"AnyEventsIncludingUnfinished\"] = 2] = \"AnyEventsIncludingUnfinished\";\n})(EventSendingLimitation || (EventSendingLimitation = {}));\n\nexports.EventSendingLimitation = EventSendingLimitation;\n\nvar TelemetryTracker = /*#__PURE__*/function () {\n  function TelemetryTracker(config, packetInterface) {\n    _classCallCheck(this, TelemetryTracker);\n\n    // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)\n    this.minEventsPortionToSend = 50; // max events batch size to be sent in a single Telemetry message\n\n    this.maxEventsPortionToSend = 100;\n    this.pendingEvents = new Map(); // started events: have TelemetryEvent::startTime only\n\n    this.readyEvents = []; // events ready to send\n\n    this.hasInitializationFinished = false;\n    this._canSendTelemetry = false;\n    this.config = config;\n    this.packetInterface = packetInterface;\n  } // Keeping this private prevents the type declaration from being generated properly.\n  // Ideally, this should be private.\n\n\n  _createClass(TelemetryTracker, [{\n    key: \"isTelemetryEnabled\",\n    get: function get() {\n      return this.config.confirmedCapabilities.has('telemetry.v1');\n    }\n  }, {\n    key: \"canSendTelemetry\",\n    get: function get() {\n      return this._canSendTelemetry && this.isTelemetryEnabled;\n    },\n    set: function set(enable) {\n      logger_1.log.debug(\"TelemetryTracker.canSendTelemetry: \".concat(enable, \" TelemetryTracker.isTelemetryEnabled: \").concat(this.isTelemetryEnabled)); // We want to keep telemetry events added in advance but\n      // we need to purge events from previous connection when being disconnected\n\n      if (this._canSendTelemetry && !enable) {\n        this.pendingEvents.clear();\n        this.readyEvents = [];\n      }\n\n      this._canSendTelemetry = enable;\n\n      if (enable) {\n        this.sendTelemetry(EventSendingLimitation.AnyEvents);\n      }\n\n      if (enable && !this.hasInitializationFinished) {\n        this.hasInitializationFinished = true;\n      }\n    } // Add complete event\n\n  }, {\n    key: \"addTelemetryEvent\",\n    value: function addTelemetryEvent(event) {\n      // Allow adding events before initialization.\n      if (!this.canSendTelemetry && this.hasInitializationFinished) {\n        return;\n      }\n\n      this.readyEvents.push(event);\n    } // Add incomplete event (with either starting or ending time point)\n\n  }, {\n    key: \"addPartialEvent\",\n    value: function addPartialEvent(incompleteEvent, eventKey, point) {\n      logger_1.log.debug(\"Adding \".concat(point === TelemetryPoint.Start ? 'starting' : 'ending', \" timepoint for '\").concat(eventKey, \"' event\"));\n      var exists = this.pendingEvents.has(eventKey);\n\n      if (point === TelemetryPoint.Start) {\n        if (exists) {\n          logger_1.log.debug(\"Overwriting starting point for '\".concat(eventKey, \"' event\"));\n        }\n\n        this.pendingEvents.set(eventKey, incompleteEvent);\n      } else {\n        if (!exists) {\n          logger_1.log.info(\"Could not find started event for '\".concat(eventKey, \"' event\"));\n          return;\n        }\n\n        this.addTelemetryEvent(this.merge(this.pendingEvents.get(eventKey), incompleteEvent));\n        this.pendingEvents.delete(eventKey);\n      }\n    }\n  }, {\n    key: \"getTelemetryToSend\",\n    value: function getTelemetryToSend(sendingLimit) {\n      if (!this.canSendTelemetry || this.readyEvents.length == 0) {\n        return []; // Events are collected but not sent until telemetry is enabled\n      }\n\n      if (sendingLimit == EventSendingLimitation.MinEventsPortion && this.readyEvents.length < this.minEventsPortionToSend) {\n        return [];\n      }\n\n      return this.getTelemetryPortion(sendingLimit == EventSendingLimitation.AnyEventsIncludingUnfinished);\n    }\n  }, {\n    key: \"getTelemetryPortion\",\n    value: function getTelemetryPortion(includeUnfinished) {\n      var _this = this;\n\n      var eventsPortionToSend = Math.min(this.readyEvents.length, this.maxEventsPortionToSend);\n      var res = this.readyEvents.splice(0, eventsPortionToSend);\n\n      if (includeUnfinished && res.length < this.maxEventsPortionToSend) {\n        this.pendingEvents.forEach(function (value, key) {\n          if (res.length >= _this.maxEventsPortionToSend) {\n            return; // @fixme does not end the loop early\n          }\n\n          var event = _this.pendingEvents.get(key);\n\n          _this.pendingEvents.delete(key);\n\n          res.push(new TelemetryEventDescription(\"[UNFINISHED] \".concat(event.title), // add prefix title to mark unfinished events for CleanSock\n          event.details, event.start, null, // Not ended, on sending will be replaced with now\n          event.type, event.id));\n        });\n      }\n\n      return res;\n    } // Merging 2 partial events:\n    //   use start.startTime & end.endTime.\n    // For other fields,\n    //   if there are values in end, use them,\n    //   else use values from start.\n\n  }, {\n    key: \"merge\",\n    value: function merge(start, end) {\n      return new TelemetryEventDescription(end.title ? end.title : start.title, end.details ? end.details : start.details, start.start, end.end, end.type ? end.type : start.type, end.id ? end.id : start.id);\n    }\n  }, {\n    key: \"sendTelemetryIfMinimalPortionCollected\",\n    value: function sendTelemetryIfMinimalPortionCollected() {\n      this.sendTelemetry(EventSendingLimitation.MinEventsPortion);\n    } // NB: getTelemetryToSend will return non-empty array only if we have already received initReply\n    // and telemetry.v1 capability is enabled there.\n\n  }, {\n    key: \"sendTelemetry\",\n    value: function sendTelemetry(limit) {\n      var events = this.getTelemetryToSend(limit);\n\n      if (events.length === 0) {\n        return; // not enough telemetry data collected\n      }\n\n      try {\n        this.packetInterface.send(new telemetry_1.Telemetry(events.map(function (e) {\n          return e.toTelemetryEvent();\n        })));\n      } catch (err) {\n        logger_1.log.debug(\"Error while sending \".concat(events.length, \" telemetry events due to \").concat(err, \"; they will be resubmitted\"));\n        this.readyEvents = this.readyEvents.concat(events);\n      }\n    }\n  }]);\n\n  return TelemetryTracker;\n}();\n\nexports.TelemetryTracker = TelemetryTracker;","map":null,"metadata":{},"sourceType":"script"}