{"ast":null,"code":"\"use strict\";\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _regenerator = require(\"babel-runtime/regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require(\"babel-runtime/helpers/asyncToGenerator\");\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _isInteger = require(\"babel-runtime/core-js/number/is-integer\");\n\nvar _isInteger2 = _interopRequireDefault(_isInteger);\n\nvar _getPrototypeOf = require(\"babel-runtime/core-js/object/get-prototype-of\");\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar util_1 = require(\"./util\");\n\nvar logger_1 = require(\"./logger\");\n\nvar log = logger_1.Logger.scope('Member');\n/**\n * @classdesc A Member represents a remote Client in a Channel.\n * @property {Object} attributes - Object with custom attributes for Member\n * @property {Channel} channel - The Channel the remote Client is a Member of\n * @property {Date} dateCreated - The Date this Member was created\n * @property {Date} dateUpdated - The Date this Member was last updated\n * @property {String} identity - The identity of the remote Client\n * @property {Boolean} isTyping - Whether or not this Member is currently typing\n * @property {Number} lastConsumedMessageIndex - Latest consumed Message index by this Member.\n * Note that just retrieving messages on a client endpoint does not mean that messages are consumed/read,\n * please consider reading about [Consumption Horizon feature]{@link https://www.twilio.com/docs/api/chat/guides/consumption-horizon}\n * to find out how to mark messages as consumed.\n * @property {Date} lastConsumptionTimestamp - Date when Member has updated his consumption horizon\n * @property {String} sid - The server-assigned unique identifier for the Member\n * @property {Member#Type} type - The type of Member\n * @fires Member#typingEnded\n * @fires Member#typingStarted\n * @fires Member#updated\n */\n\nvar Member = function (_events_1$EventEmitte) {\n  (0, _inherits3.default)(Member, _events_1$EventEmitte);\n  /**\n   * The update reason for <code>updated</code> event emitted on Member\n   * @typedef {('attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' |\n    'lastConsumedMessageIndex' | 'lastConsumptionTimestamp')} Member#UpdateReason\n   */\n\n  /**\n   * The type of Member\n   * @typedef {('chat' | 'sms' | 'whatsapp')} Member#Type\n   */\n\n  function Member(services, channel, data, sid) {\n    (0, _classCallCheck3.default)(this, Member);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Member.__proto__ || (0, _getPrototypeOf2.default)(Member)).call(this));\n\n    _this.channel = channel;\n    _this.services = services;\n    _this.state = {\n      attributes: util_1.parseAttributes(data.attributes, 'Retrieved malformed attributes from the server for member: ' + sid, log),\n      dateCreated: data.dateCreated ? util_1.parseTime(data.dateCreated) : null,\n      dateUpdated: data.dateCreated ? util_1.parseTime(data.dateUpdated) : null,\n      sid: sid,\n      typingTimeout: null,\n      isTyping: false,\n      identity: data.identity || null,\n      roleSid: data.roleSid || null,\n      lastConsumedMessageIndex: (0, _isInteger2.default)(data.lastConsumedMessageIndex) ? data.lastConsumedMessageIndex : null,\n      lastConsumptionTimestamp: data.lastConsumptionTimestamp ? util_1.parseTime(data.lastConsumptionTimestamp) : null,\n      type: data.type || 'chat',\n      userInfo: data.userInfo\n    };\n\n    if (!data.identity && !data.type) {\n      throw new Error('Received invalid Member object from server: Missing identity or type of Member.');\n    }\n\n    return _this;\n  }\n\n  (0, _createClass3.default)(Member, [{\n    key: \"_startTyping\",\n\n    /**\n     * Private method used to start or reset the typing indicator timeout (with event emitting)\n     * @private\n     */\n    value: function _startTyping(timeout) {\n      var _this2 = this;\n\n      clearTimeout(this.state.typingTimeout);\n      this.state.isTyping = true;\n      this.emit('typingStarted', this);\n      this.channel.emit('typingStarted', this);\n      this.state.typingTimeout = setTimeout(function () {\n        return _this2._endTyping();\n      }, timeout);\n      return this;\n    }\n    /**\n     * Private method function used to stop typing indicator (with event emitting)\n     * @private\n     */\n\n  }, {\n    key: \"_endTyping\",\n    value: function _endTyping() {\n      if (!this.state.typingTimeout) {\n        return;\n      }\n\n      this.state.isTyping = false;\n      this.emit('typingEnded', this);\n      this.channel.emit('typingEnded', this);\n      clearInterval(this.state.typingTimeout);\n      this.state.typingTimeout = null;\n    }\n    /**\n     * Private method function used update local object's property roleSid with new value\n     * @private\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update(data) {\n      var updateReasons = [];\n      var updateAttributes = util_1.parseAttributes(data.attributes, 'Retrieved malformed attributes from the server for member: ' + this.state.sid, log);\n\n      if (data.attributes && !util_1.isDeepEqual(this.state.attributes, updateAttributes)) {\n        this.state.attributes = updateAttributes;\n        updateReasons.push('attributes');\n      }\n\n      var updatedDateUpdated = util_1.parseTime(data.dateUpdated);\n\n      if (data.dateUpdated && updatedDateUpdated.getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {\n        this.state.dateUpdated = updatedDateUpdated;\n        updateReasons.push('dateUpdated');\n      }\n\n      var updatedDateCreated = util_1.parseTime(data.dateCreated);\n\n      if (data.dateCreated && updatedDateCreated.getTime() !== (this.state.dateCreated && this.state.dateCreated.getTime())) {\n        this.state.dateCreated = updatedDateCreated;\n        updateReasons.push('dateCreated');\n      }\n\n      if (data.roleSid && this.state.roleSid !== data.roleSid) {\n        this.state.roleSid = data.roleSid;\n        updateReasons.push('roleSid');\n      }\n\n      if (((0, _isInteger2.default)(data.lastConsumedMessageIndex) || data.lastConsumedMessageIndex === null) && this.state.lastConsumedMessageIndex !== data.lastConsumedMessageIndex) {\n        this.state.lastConsumedMessageIndex = data.lastConsumedMessageIndex;\n        updateReasons.push('lastConsumedMessageIndex');\n      }\n\n      if (data.lastConsumptionTimestamp) {\n        var lastConsumptionTimestamp = new Date(data.lastConsumptionTimestamp);\n\n        if (!this.state.lastConsumptionTimestamp || this.state.lastConsumptionTimestamp.getTime() !== lastConsumptionTimestamp.getTime()) {\n          this.state.lastConsumptionTimestamp = lastConsumptionTimestamp;\n          updateReasons.push('lastConsumptionTimestamp');\n        }\n      }\n\n      if (updateReasons.length > 0) {\n        this.emit('updated', {\n          member: this,\n          updateReasons: updateReasons\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Gets User Descriptor for this member. Supported only for <code>chat</code> type of Members\n     * @returns {Promise<UserDescriptor|Error>}\n     */\n\n  }, {\n    key: \"getUserDescriptor\",\n    value: function () {\n      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.type != 'chat')) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('Getting User Descriptor is not supported for this Member type: ' + this.type);\n\n              case 2:\n                return _context.abrupt(\"return\", this.services.users.getUserDescriptor(this.state.identity));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getUserDescriptor() {\n        return _ref.apply(this, arguments);\n      }\n\n      return getUserDescriptor;\n    }()\n    /**\n     * Gets User for this member and subscribes to it. Supported only for <code>chat</code> type of Members\n     * @returns {Promise<User|Error>}\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function () {\n      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.type != 'chat')) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error('Getting User is not supported for this Member type: ' + this.type);\n\n              case 2:\n                return _context2.abrupt(\"return\", this.services.users.getUser(this.state.identity, this.state.userInfo));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getUser() {\n        return _ref2.apply(this, arguments);\n      }\n\n      return getUser;\n    }()\n    /**\n     * Remove Member from the Channel.\n     * @returns {Promise<void|Error|SessionError>}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {\n        return _regenerator2.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.channel.removeMember(this));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function remove() {\n        return _ref3.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /**\n     * Edit member attributes.\n     * @param {Object} attributes new attributes for Member.\n     * @returns {Promise<Member|Error|SessionError>}\n     */\n\n  }, {\n    key: \"updateAttributes\",\n    value: function () {\n      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(attributes) {\n        return _regenerator2.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(typeof attributes === 'undefined')) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw new Error('Attributes is required parameter');\n\n              case 4:\n                if (!(attributes === null)) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                throw new Error('Attributes can\\'t be null');\n\n              case 8:\n                if (!(attributes.constructor !== Object)) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                throw new Error('Attributes must be a valid JSON object');\n\n              case 10:\n                _context4.next = 12;\n                return this.services.session.addCommand('editMemberAttributes', {\n                  channelSid: this.channel.sid,\n                  memberSid: this.sid,\n                  attributes: (0, _stringify2.default)(attributes)\n                });\n\n              case 12:\n                return _context4.abrupt(\"return\", this);\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function updateAttributes(_x) {\n        return _ref4.apply(this, arguments);\n      }\n\n      return updateAttributes;\n    }()\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.state.sid;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this.state.attributes;\n    }\n  }, {\n    key: \"dateCreated\",\n    get: function get() {\n      return this.state.dateCreated;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.state.dateUpdated;\n    }\n  }, {\n    key: \"identity\",\n    get: function get() {\n      return this.state.identity;\n    }\n  }, {\n    key: \"isTyping\",\n    get: function get() {\n      return this.state.isTyping;\n    }\n  }, {\n    key: \"lastConsumedMessageIndex\",\n    get: function get() {\n      return this.state.lastConsumedMessageIndex;\n    }\n  }, {\n    key: \"lastConsumptionTimestamp\",\n    get: function get() {\n      return this.state.lastConsumptionTimestamp;\n    }\n  }, {\n    key: \"roleSid\",\n    get: function get() {\n      return this.state.roleSid;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.state.type;\n    }\n  }]);\n  return Member;\n}(events_1.EventEmitter);\n\nexports.Member = Member;\n/**\n * Fired when Member started to type.\n * @event Member#typingStarted\n * @type {Member}\n */\n\n/**\n * Fired when Member ended to type.\n * @event Member#typingEnded\n * @type {Member}\n */\n\n/**\n * Fired when Member's fields has been updated.\n * @event Member#updated\n * @type {Object}\n * @property {Member} member - Updated Member\n * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons\n */","map":null,"metadata":{},"sourceType":"script"}