{"ast":null,"code":"import _classCallCheck from \"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mmarshall/Desktop/ps-webchat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nvar _jsxFileName = \"/Users/mmarshall/Desktop/ps-webchat/src/components/clickableMessages.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport * as FlexWebChat from '@twilio/flex-webchat-ui';\nvar wrapper = {\n  display: 'block',\n  overflowX: 'hidden',\n  justifyContent: 'center',\n  width: '40%'\n};\nvar bubble = {\n  paddingLeft: '12px',\n  paddingRight: '12px',\n  color: 'black',\n  paddingTop: '5px',\n  paddingBottom: '8px',\n  margin: '5px 10px',\n  position: 'relative',\n  overflowX: 'hidden',\n  display: 'flex',\n  background: '#eeeeee',\n  borderRadius: '6px',\n  fontSize: '1em'\n};\n\nvar ClickableMessages = /*#__PURE__*/function (_React$Component) {\n  _inherits(ClickableMessages, _React$Component);\n\n  var _super = _createSuper(ClickableMessages);\n\n  function ClickableMessages(props) {\n    var _this;\n\n    _classCallCheck(this, ClickableMessages);\n\n    _this = _super.call(this);\n    _this.props = props;\n    return _this;\n  } // We are going to get the channel, then add a channel listener (to subscribe to) any time there are updates to\n  // the attributes of the channel.  From there we will push the updated clickableMessages object into redux\n  // and that is how we are rendering button/component changes as the studio flow push new objects throughout the flow!\n\n\n  _createClass(ClickableMessages, [{\n    key: \"getChannelAttributes\",\n    value: function getChannelAttributes() {\n      var dispatch = this.props.dispatch;\n      FlexWebChat.manager.chatClient.getChannelBySid(this.props.channelSid).then(function (channel) {\n        channel.on('updated', function (_ref) {\n          var channel = _ref.channel,\n              updateReasons = _ref.updateReasons;\n\n          if (updateReasons.indexOf('attributes') !== -1 && channel.attributes.status === 'INACTIVE') {\n            FlexWebChat.Actions.invokeAction('RestartEngagement');\n            return;\n          }\n\n          if (undefined !== channel.attributes.clickableMessages && updateReasons.indexOf('attributes') !== -1) {\n            dispatch({\n              type: 'SET_CLICKABLE_MESSAGES',\n              payload: {\n                clickableMessages: channel.attributes.clickableMessages\n              }\n            });\n          }\n        });\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var channelSid = this.props.channelSid;\n      var dispatch = this.props.dispatch;\n      this.getChannelAttributes();\n      return this.props.clickableMessages ? /*#__PURE__*/React.createElement(\"div\", {\n        className: \"generatedAnswers\",\n        style: wrapper,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 72,\n          columnNumber: 7\n        }\n      }, this.props.clickableMessages.map(function (m) {\n        return /*#__PURE__*/React.createElement(\"div\", {\n          className: \"generatedAnswerBubble\",\n          style: bubble,\n          onClick: function onClick(e) {\n            // This removes all the clickable messages on click to reset the buttons\n            dispatch({\n              type: 'SET_CLICKABLE_MESSAGES',\n              payload: {\n                clickableMessages: []\n              }\n            }); // Once they click the button, we will post that as the message in the chat\n\n            FlexWebChat.manager.chatClient.getChannelBySid(channelSid).then(function (channel) {\n              channel.sendMessage(m.message);\n            });\n          },\n          key: m.message,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 75,\n            columnNumber: 13\n          }\n        }, m.message);\n      })) : null;\n    }\n  }]);\n\n  return ClickableMessages;\n}(React.Component);\n\nvar mapStateToProps = function mapStateToProps(state) {\n  var channelSid = state.flex.session.channelSid;\n  return {\n    state: state,\n    clickableMessages: state.custom.clickableMessages,\n    channelSid: channelSid\n  };\n};\n\nexport default connect(mapStateToProps)(ClickableMessages);","map":{"version":3,"sources":["/Users/mmarshall/Desktop/ps-webchat/src/components/clickableMessages.js"],"names":["React","connect","FlexWebChat","wrapper","display","overflowX","justifyContent","width","bubble","paddingLeft","paddingRight","color","paddingTop","paddingBottom","margin","position","background","borderRadius","fontSize","ClickableMessages","props","dispatch","manager","chatClient","getChannelBySid","channelSid","then","channel","on","updateReasons","indexOf","attributes","status","Actions","invokeAction","undefined","clickableMessages","type","payload","getChannelAttributes","map","m","e","sendMessage","message","Component","mapStateToProps","state","flex","session","custom"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { connect } from 'react-redux';\nimport * as FlexWebChat from '@twilio/flex-webchat-ui';\n\nconst wrapper = {\n  display: 'block',\n  overflowX: 'hidden',\n  justifyContent: 'center',\n  width: '40%',\n};\n\nconst bubble = {\n  paddingLeft: '12px',\n  paddingRight: '12px',\n  color: 'black',\n  paddingTop: '5px',\n  paddingBottom: '8px',\n  margin: '5px 10px',\n  position: 'relative',\n  overflowX: 'hidden',\n  display: 'flex',\n  background: '#eeeeee',\n  borderRadius: '6px',\n  fontSize: '1em',\n};\n\nclass ClickableMessages extends React.Component {\n  constructor(props) {\n    super();\n    this.props = props;\n  }\n\n  // We are going to get the channel, then add a channel listener (to subscribe to) any time there are updates to\n  // the attributes of the channel.  From there we will push the updated clickableMessages object into redux\n  // and that is how we are rendering button/component changes as the studio flow push new objects throughout the flow!\n  getChannelAttributes() {\n    const dispatch = this.props.dispatch;\n\n    FlexWebChat.manager.chatClient\n      .getChannelBySid(this.props.channelSid)\n      .then((channel) => {\n        channel.on('updated', ({ channel, updateReasons }) => {\n          if (\n            updateReasons.indexOf('attributes') !== -1 &&\n            channel.attributes.status === 'INACTIVE'\n          ) {\n            FlexWebChat.Actions.invokeAction('RestartEngagement');\n            return;\n          }\n          if (\n            undefined !== channel.attributes.clickableMessages &&\n            updateReasons.indexOf('attributes') !== -1\n          ) {\n            dispatch({\n              type: 'SET_CLICKABLE_MESSAGES',\n              payload: {\n                clickableMessages: channel.attributes.clickableMessages,\n              },\n            });\n          }\n        });\n      });\n  }\n\n  render() {\n    const channelSid = this.props.channelSid;\n    const dispatch = this.props.dispatch;\n\n    this.getChannelAttributes();\n\n    return this.props.clickableMessages ? (\n      <div className=\"generatedAnswers\" style={wrapper}>\n        {this.props.clickableMessages.map(function(m) {\n          return (\n            <div\n              className=\"generatedAnswerBubble\"\n              style={bubble}\n              onClick={(e) => {\n                // This removes all the clickable messages on click to reset the buttons\n                dispatch({\n                  type: 'SET_CLICKABLE_MESSAGES',\n                  payload: { clickableMessages: [] },\n                });\n                // Once they click the button, we will post that as the message in the chat\n                FlexWebChat.manager.chatClient\n                  .getChannelBySid(channelSid)\n                  .then((channel) => {\n                    channel.sendMessage(m.message);\n                  });\n              }}\n              key={m.message}\n            >\n              {m.message}\n            </div>\n          );\n        })}\n      </div>\n    ) : null;\n  }\n}\n\nconst mapStateToProps = (state) => {\n  let channelSid = state.flex.session.channelSid;\n\n  return {\n    state: state,\n    clickableMessages: state.custom.clickableMessages,\n    channelSid,\n  };\n};\n\nexport default connect(mapStateToProps)(ClickableMessages);\n"]},"metadata":{},"sourceType":"module"}