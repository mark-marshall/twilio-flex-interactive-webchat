{"ast":null,"code":"\"use strict\";\n\nvar _regenerator = require(\"babel-runtime/regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require(\"babel-runtime/helpers/asyncToGenerator\");\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _promise = require(\"babel-runtime/core-js/promise\");\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _slicedToArray2 = require(\"babel-runtime/helpers/slicedToArray\");\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _assign = require(\"babel-runtime/core-js/object/assign\");\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _map = require(\"babel-runtime/core-js/map\");\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operation_retrier_1 = require(\"operation-retrier\");\n\nvar Network = function () {\n  function Network(config, services) {\n    var _this = this;\n\n    (0, _classCallCheck3.default)(this, Network);\n    this.config = config;\n    this.services = services;\n    this.cache = new _map2.default();\n    this.cacheLifetime = 0;\n    this.services.session.getHttpCacheInterval().then(function (seconds) {\n      _this.cacheLifetime = seconds * 1000;\n\n      _this.cleanupCache();\n    });\n  }\n\n  (0, _createClass3.default)(Network, [{\n    key: \"backoffConfig\",\n    value: function backoffConfig() {\n      return (0, _assign2.default)(this.config.backoffConfigDefault, this.config.backoffConfigOverride);\n    }\n  }, {\n    key: \"retryWhenThrottled\",\n    value: function retryWhenThrottled() {\n      if (typeof this.config.retryWhenThrottledOverride !== 'undefined') {\n        return this.config.retryWhenThrottledOverride;\n      }\n\n      if (typeof this.config.retryWhenThrottledDefault !== 'undefined') {\n        return this.config.retryWhenThrottledDefault;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isExpired\",\n    value: function isExpired(timestamp) {\n      return !this.cacheLifetime || Date.now() - timestamp > this.cacheLifetime;\n    }\n  }, {\n    key: \"cleanupCache\",\n    value: function cleanupCache() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (0, _getIterator3.default)(this.cache), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref = _step.value;\n\n          var _ref2 = (0, _slicedToArray3.default)(_ref, 2);\n\n          var k = _ref2[0];\n          var v = _ref2[1];\n\n          if (this.isExpired(v.timestamp)) {\n            this.cache.delete(k);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (this.cache.size === 0) {\n        clearInterval(this.timer);\n      }\n    }\n  }, {\n    key: \"pokeTimer\",\n    value: function pokeTimer() {\n      var _this2 = this;\n\n      this.timer = this.timer || setInterval(function () {\n        return _this2.cleanupCache();\n      }, this.cacheLifetime * 2);\n    }\n  }, {\n    key: \"executeWithRetry\",\n    value: function executeWithRetry(request) {\n      var _this3 = this;\n\n      var retryWhenThrottled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return new _promise2.default(function (resolve, reject) {\n        var codesToRetryOn = [502, 503, 504];\n\n        if (retryWhenThrottled) {\n          codesToRetryOn.push(429);\n        }\n\n        var retrier = new operation_retrier_1.Retrier(_this3.backoffConfig());\n        retrier.on('attempt', function () {\n          request().then(function (result) {\n            return retrier.succeeded(result);\n          }).catch(function (err) {\n            if (codesToRetryOn.indexOf(err.status) > -1) {\n              retrier.failed(err);\n            } else if (err.message === 'Twilsock disconnected') {\n              // Ugly hack. We must make a proper exceptions for twilsock\n              retrier.failed(err);\n            } else {\n              // Fatal error\n              retrier.removeAllListeners();\n              retrier.cancel();\n              reject(err);\n            }\n          });\n        });\n        retrier.on('succeeded', function (result) {\n          resolve(result);\n        });\n        retrier.on('cancelled', function (err) {\n          return reject(err);\n        });\n        retrier.on('failed', function (err) {\n          return reject(err);\n        });\n        retrier.start();\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(url) {\n        var _this4 = this;\n\n        var cacheEntry, headers, response;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                cacheEntry = this.cache.get(url);\n\n                if (!(cacheEntry && !this.isExpired(cacheEntry.timestamp))) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", cacheEntry.response);\n\n              case 3:\n                headers = {};\n                _context.next = 6;\n                return this.executeWithRetry(function () {\n                  return _this4.services.transport.get(url, headers);\n                }, this.retryWhenThrottled());\n\n              case 6:\n                response = _context.sent;\n                this.cache.set(url, {\n                  response: response,\n                  timestamp: Date.now()\n                });\n                this.pokeTimer();\n                return _context.abrupt(\"return\", response);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function get(_x2) {\n        return _ref3.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }]);\n  return Network;\n}();\n\nexports.Network = Network;","map":null,"metadata":{},"sourceType":"script"}