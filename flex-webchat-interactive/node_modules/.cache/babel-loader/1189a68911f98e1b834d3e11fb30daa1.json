{"ast":null,"code":"\"use strict\";\n\nvar _promise = require(\"babel-runtime/core-js/promise\");\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _map = require(\"babel-runtime/core-js/map\");\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sessionerror_1 = require(\"../sessionerror\");\n\nvar ConsumptionReportRequest = function ConsumptionReportRequest() {\n  (0, _classCallCheck3.default)(this, ConsumptionReportRequest);\n};\n\nvar ConsumptionReportEntry = function ConsumptionReportEntry() {\n  (0, _classCallCheck3.default)(this, ConsumptionReportEntry);\n};\n\nvar ConsumptionHorizonPromise = function ConsumptionHorizonPromise() {\n  (0, _classCallCheck3.default)(this, ConsumptionHorizonPromise);\n};\n/**\n * @classdesc Provides consumption horizon management functionality\n */\n\n\nvar ConsumptionHorizon = function () {\n  function ConsumptionHorizon(services) {\n    (0, _classCallCheck3.default)(this, ConsumptionHorizon);\n    this.services = services;\n    this.consumptionHorizonRequests = new _map2.default();\n    this.consumptionHorizonUpdateTimer = null;\n  }\n\n  (0, _createClass3.default)(ConsumptionHorizon, [{\n    key: \"getReportInterval\",\n    value: function getReportInterval() {\n      return this.services.session.getConsumptionReportInterval().then(function (seconds) {\n        return seconds * 1000;\n      });\n    }\n  }, {\n    key: \"delayedSendConsumptionHorizon\",\n    value: function delayedSendConsumptionHorizon(delay) {\n      var _this = this;\n\n      if (this.consumptionHorizonUpdateTimer !== null) {\n        return;\n      }\n\n      this.sendConsumptionReport(true);\n      this.consumptionHorizonUpdateTimer = setTimeout(function () {\n        _this.sendConsumptionReport(false);\n      }, delay);\n    }\n  }, {\n    key: \"sendConsumptionReport\",\n    value: function sendConsumptionReport(keepTimer) {\n      var _this2 = this;\n\n      var reports = [];\n      var promises = new _map2.default();\n      this.consumptionHorizonRequests.forEach(function (request, channelSid) {\n        reports.push(request.entry);\n        promises.set(channelSid, request.promises);\n      });\n\n      if (reports.length > 0) {\n        this.services.session.addCommand('consumptionReportV2', {\n          report: reports\n        }).then(function (response) {\n          return _this2.processConsumptionReportResponse(response, promises);\n        }).catch(function (err) {\n          return _this2.processConsumptionReportError(err, promises);\n        });\n      }\n\n      if (!keepTimer) {\n        this.consumptionHorizonUpdateTimer = null;\n      }\n\n      this.consumptionHorizonRequests.clear();\n    }\n  }, {\n    key: \"processConsumptionReportResponse\",\n    value: function processConsumptionReportResponse(response, promises) {\n      if (response && response.report && Array.isArray(response.report) && response.report.length > 0) {\n        response.report.forEach(function (entry) {\n          var responseEntry = entry;\n\n          if (promises.has(responseEntry.channelSid)) {\n            var unreadMessagesCount = null;\n\n            if (typeof responseEntry.unreadMessagesCount !== 'undefined' && responseEntry.unreadMessagesCount != null) {\n              unreadMessagesCount = responseEntry.unreadMessagesCount;\n            }\n\n            promises.get(responseEntry.channelSid).forEach(function (promise) {\n              return promise.resolve(unreadMessagesCount);\n            });\n            promises.delete(responseEntry.channelSid);\n          }\n        });\n      }\n\n      this.processConsumptionReportError(new sessionerror_1.SessionError('Error while setting LastConsumedMessageIndex', null), promises);\n    }\n  }, {\n    key: \"processConsumptionReportError\",\n    value: function processConsumptionReportError(err, promises) {\n      promises.forEach(function (channelPromises) {\n        return channelPromises.forEach(function (promise) {\n          return promise.reject(err);\n        });\n      });\n    }\n    /**\n     * Updates consumption horizon value without any checks\n     */\n\n  }, {\n    key: \"updateLastConsumedMessageIndexForChannel\",\n    value: function updateLastConsumedMessageIndexForChannel(channelSid, messageIdx) {\n      var _this3 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        _this3.addPendingConsumptionHorizonRequest(channelSid, {\n          channelSid: channelSid,\n          messageIdx: messageIdx\n        }, {\n          resolve: resolve,\n          reject: reject\n        });\n\n        _this3.getReportInterval().then(function (delay) {\n          return _this3.delayedSendConsumptionHorizon(delay);\n        });\n      });\n    }\n    /**\n     * Move consumption horizon forward\n     */\n\n  }, {\n    key: \"advanceLastConsumedMessageIndexForChannel\",\n    value: function advanceLastConsumedMessageIndexForChannel(channelSid, messageIdx, currentChannelLastConsumedIndex) {\n      var _this4 = this;\n\n      var currentHorizon = this.consumptionHorizonRequests.get(channelSid);\n      return new _promise2.default(function (resolve, reject) {\n        if (currentHorizon && currentHorizon.entry) {\n          if (currentHorizon.entry.messageIdx >= messageIdx) {\n            _this4.addPendingConsumptionHorizonRequest(channelSid, currentHorizon.entry, {\n              resolve: resolve,\n              reject: reject\n            });\n          } else {\n            _this4.addPendingConsumptionHorizonRequest(channelSid, {\n              channelSid: channelSid,\n              messageIdx: messageIdx\n            }, {\n              resolve: resolve,\n              reject: reject\n            });\n          }\n        } else {\n          if (currentChannelLastConsumedIndex !== null && messageIdx < currentChannelLastConsumedIndex) {\n            _this4.addPendingConsumptionHorizonRequest(channelSid, {\n              channelSid: channelSid,\n              messageIdx: currentChannelLastConsumedIndex\n            }, {\n              resolve: resolve,\n              reject: reject\n            });\n          } else {\n            _this4.addPendingConsumptionHorizonRequest(channelSid, {\n              channelSid: channelSid,\n              messageIdx: messageIdx\n            }, {\n              resolve: resolve,\n              reject: reject\n            });\n          }\n        }\n\n        _this4.getReportInterval().then(function (delay) {\n          return _this4.delayedSendConsumptionHorizon(delay);\n        });\n      });\n    }\n  }, {\n    key: \"addPendingConsumptionHorizonRequest\",\n    value: function addPendingConsumptionHorizonRequest(channelSid, entry, promise) {\n      if (this.consumptionHorizonRequests.has(channelSid)) {\n        var request = this.consumptionHorizonRequests.get(channelSid);\n        request.entry = entry;\n        request.promises.push(promise);\n      } else {\n        this.consumptionHorizonRequests.set(channelSid, {\n          entry: entry,\n          promises: [promise]\n        });\n      }\n    }\n  }]);\n  return ConsumptionHorizon;\n}();\n\nexports.ConsumptionHorizon = ConsumptionHorizon;","map":null,"metadata":{},"sourceType":"script"}