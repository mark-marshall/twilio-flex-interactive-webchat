{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subscriptions = void 0;\n\nvar operation_retrier_1 = require(\"operation-retrier\");\n\nvar syncerror_1 = require(\"./utils/syncerror\");\n\nvar logger_1 = require(\"./utils/logger\");\n\nvar twilsock_1 = require(\"twilsock\");\n/**\n * A data container used by the Subscriptions class to track subscribed entities' local\n * representations and their state.\n */\n\n\nvar SubscribedEntity = /*#__PURE__*/function () {\n  function SubscribedEntity(entity) {\n    _classCallCheck(this, SubscribedEntity);\n\n    this.localObject = entity;\n    this.pendingCorrelationId = null;\n    this.pendingAction = null;\n    this.established = false;\n    this.retryCount = 0;\n  }\n\n  _createClass(SubscribedEntity, [{\n    key: \"update\",\n    value: function update(event, isStrictlyOrdered) {\n      this.localObject._update(event, isStrictlyOrdered);\n    }\n  }, {\n    key: \"updatePending\",\n    value: function updatePending(action, correlationId) {\n      this.pendingAction = action;\n      this.pendingCorrelationId = correlationId;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.updatePending(null, null);\n      this.retryCount = 0;\n      this.established = false;\n      this.setSubscriptionState('none');\n    }\n  }, {\n    key: \"markAsFailed\",\n    value: function markAsFailed(message) {\n      this.rejectedWithError = message.error;\n      this.updatePending(null, null);\n      this.localObject.reportFailure(new syncerror_1.SyncError(\"Failed to subscribe on service events: \".concat(message.error.message), message.error.status, message.error.code));\n    }\n  }, {\n    key: \"complete\",\n    value: function complete(eventId) {\n      this.updatePending(null, null);\n      this.established = true;\n\n      this.localObject._advanceLastEventId(eventId);\n    }\n  }, {\n    key: \"setSubscriptionState\",\n    value: function setSubscriptionState(newState) {\n      this.localObject._setSubscriptionState(newState);\n    }\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.localObject.sid;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.localObject.type;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.localObject.lastEventId;\n    } // below properties are specific to Insights only\n\n  }, {\n    key: \"indexName\",\n    get: function get() {\n      return this.localObject.indexName;\n    }\n  }, {\n    key: \"queryString\",\n    get: function get() {\n      return this.localObject.queryString;\n    }\n  }, {\n    key: \"isEstablished\",\n    get: function get() {\n      return this.established;\n    }\n  }]);\n\n  return SubscribedEntity;\n}();\n/**\n * @class Subscriptions\n * @classdesc A manager which, in batches of varying size, continuously persists the\n *      subscription intent of the caller to the Sync backend until it achieves a\n *      converged state.\n */\n\n\nvar Subscriptions = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.\n   *\n   * @param {object} config may include a key 'backoffConfig', wherein any of the parameters\n   *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.\n   *\n   * @param {Network} must be a viable running Sync Network object, useful for routing requests.\n   */\n  function Subscriptions(services) {\n    var _this = this;\n\n    _classCallCheck(this, Subscriptions);\n\n    this.isConnected = false;\n    this.maxBatchSize = 100; // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration\n    // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.\n    // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.\n\n    this.subscriptionTtlTimer = null;\n    this.pendingPokeReason = null;\n    this.services = services;\n    this.subscriptions = new Map();\n    this.persisted = new Map();\n    this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();\n    var defaultBackoffConfig = {\n      randomisationFactor: 0.2,\n      initialDelay: 100,\n      maxDelay: 2 * 60 * 1000\n    };\n    this.backoff = operation_retrier_1.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig)); // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)\n    // backoff 'ready' event, at which point a new subscription set is calculated.\n\n    this.backoff.on('ready', function () {\n      var _this$getSubscription = _this.getSubscriptionUpdateBatch(),\n          action = _this$getSubscription.action,\n          subscriptionRequests = _this$getSubscription.subscriptions;\n\n      if (action) {\n        _this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);\n      } else {\n        _this.backoff.reset();\n\n        logger_1.default.debug('All subscriptions resolved.');\n      }\n    });\n  }\n\n  _createClass(Subscriptions, [{\n    key: \"getSubscriptionUpdateBatch\",\n    value: function getSubscriptionUpdateBatch() {\n      function subtract(these, those, action, limit) {\n        var result = [];\n\n        var _iterator = _createForOfIteratorHelper(these),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                thisKey = _step$value[0],\n                thisValue = _step$value[1];\n\n            var otherValue = those.get(thisKey);\n\n            if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {\n              result.push(thisValue);\n\n              if (limit && result.length >= limit) {\n                break;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return result;\n      }\n\n      var listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);\n\n      if (listToAdd.length > 0) {\n        return {\n          action: 'establish',\n          subscriptions: listToAdd\n        };\n      }\n\n      var listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);\n\n      if (listToRemove.length > 0) {\n        return {\n          action: 'cancel',\n          subscriptions: listToRemove\n        };\n      }\n\n      return {\n        action: null,\n        subscriptions: null\n      };\n    }\n  }, {\n    key: \"persist\",\n    value: function persist() {\n      this.backoff.backoff();\n    }\n  }, {\n    key: \"applyNewSubscriptionUpdateBatch\",\n    value: function () {\n      var _applyNewSubscriptionUpdateBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(action, requests) {\n        var _this2 = this;\n\n        var correlationId, _iterator2, _step2, subscribed, reason, response, newMaxBatchSize, subscriptionTtlInS, isNumeric, isValidTtl, estimatedDeliveryInMs, _isNumeric, isValidTimeout, _iterator3, _step3, attemptedSubscription;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.isConnected) {\n                  _context.next = 4;\n                  break;\n                }\n\n                logger_1.default.debug(\"Twilsock connection (required for subscription) not ready; waiting\\u2026\");\n                this.backoff.reset();\n                return _context.abrupt(\"return\");\n\n              case 4:\n                // Keeping in mind that events may begin flowing _before_ we receive the response\n                requests = this.processLocalActions(action, requests);\n                correlationId = new Date().getTime();\n                _iterator2 = _createForOfIteratorHelper(requests);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    subscribed = _step2.value;\n                    this.recordActionAttemptOn(subscribed, action, correlationId);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                reason = this.pendingPokeReason;\n                this.pendingPokeReason = null; // Send this batch to the service\n\n                _context.prev = 10;\n                _context.next = 13;\n                return this.request(action, correlationId, reason, requests);\n\n              case 13:\n                response = _context.sent;\n                newMaxBatchSize = response.body.max_batch_size;\n\n                if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {\n                  this.maxBatchSize = newMaxBatchSize;\n                }\n\n                if (!this.subscriptionTtlTimer) {\n                  subscriptionTtlInS = response.body.ttl_in_s;\n                  isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);\n                  isValidTtl = isNumeric && subscriptionTtlInS > 0;\n\n                  if (isValidTtl) {\n                    this.subscriptionTtlTimer = setTimeout(function () {\n                      return _this2.onSubscriptionTtlElapsed();\n                    }, subscriptionTtlInS * 1000);\n                  }\n                }\n\n                if (action === 'establish') {\n                  estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;\n                  _isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);\n                  isValidTimeout = _isNumeric && estimatedDeliveryInMs > 0;\n\n                  if (isValidTimeout) {\n                    setTimeout(function () {\n                      return _this2.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests);\n                    }, estimatedDeliveryInMs);\n                  } else {\n                    logger_1.default.error(\"Invalid timeout: \".concat(estimatedDeliveryInMs));\n                  }\n\n                  requests.filter(function (r) {\n                    return r.pendingCorrelationId === correlationId;\n                  }).forEach(function (r) {\n                    return r.setSubscriptionState('response_in_flight');\n                  });\n                }\n\n                this.backoff.reset();\n                _context.next = 26;\n                break;\n\n              case 21:\n                _context.prev = 21;\n                _context.t0 = _context[\"catch\"](10);\n                _iterator3 = _createForOfIteratorHelper(requests);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    attemptedSubscription = _step3.value;\n                    this.recordActionFailureOn(attemptedSubscription, action);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                if (_context.t0 instanceof twilsock_1.TransportUnavailableError) {\n                  logger_1.default.debug(\"Twilsock connection (required for subscription) not ready (c:\".concat(correlationId, \"); waiting\\u2026\"));\n                  this.backoff.reset();\n                } else {\n                  logger_1.default.debug(\"Failed an attempt to \".concat(action, \" subscriptions (c:\").concat(correlationId, \"); retrying\"), _context.t0);\n                  this.persist();\n                }\n\n              case 26:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[10, 21]]);\n      }));\n\n      function applyNewSubscriptionUpdateBatch(_x, _x2) {\n        return _applyNewSubscriptionUpdateBatch.apply(this, arguments);\n      }\n\n      return applyNewSubscriptionUpdateBatch;\n    }()\n  }, {\n    key: \"verifyPokeDelivery\",\n    value: function verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {\n      var _this3 = this;\n\n      var lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);\n      var silencePeriod = lastReceived ? new Date().getTime() - lastReceived : estimatedDeliveryInMs;\n\n      if (silencePeriod >= estimatedDeliveryInMs) {\n        // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again\n        requests.filter(function (r) {\n          return r.pendingCorrelationId === correlationId;\n        }).forEach(function (r) {\n          r.updatePending(null, null);\n          r.retryCount++;\n\n          _this3.persisted.delete(r.sid);\n        });\n        this.persist();\n        this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);\n      } else {\n        // Otherwise, the poke responses are probably in transit and we should wait for them\n        var timeoutExtension = estimatedDeliveryInMs - silencePeriod;\n        setTimeout(function () {\n          return _this3.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests);\n        }, timeoutExtension);\n      }\n    }\n  }, {\n    key: \"processLocalActions\",\n    value: function processLocalActions(action, requests) {\n      if (action === 'cancel') {\n        return requests.filter(function (request) {\n          return !request.rejectedWithError;\n        });\n      }\n\n      return requests;\n    }\n  }, {\n    key: \"recordActionAttemptOn\",\n    value: function recordActionAttemptOn(attemptedSubscription, action, correlationId) {\n      attemptedSubscription.setSubscriptionState('request_in_flight');\n\n      if (action === 'establish') {\n        this.persisted.set(attemptedSubscription.sid, attemptedSubscription);\n        attemptedSubscription.updatePending(action, correlationId);\n      } else {\n        // cancel\n        var persistedSubscription = this.persisted.get(attemptedSubscription.sid);\n\n        if (persistedSubscription) {\n          persistedSubscription.updatePending(action, correlationId);\n        }\n      }\n    }\n  }, {\n    key: \"recordActionFailureOn\",\n    value: function recordActionFailureOn(attemptedSubscription, action) {\n      attemptedSubscription.setSubscriptionState('none');\n      attemptedSubscription.updatePending(null, null);\n\n      if (action === 'establish') {\n        this.persisted.delete(attemptedSubscription.sid);\n      }\n    }\n  }, {\n    key: \"request\",\n    value: function request(action, correlationId, reason, objects) {\n      var requests = objects.map(function (object) {\n        return {\n          object_sid: object.sid,\n          object_type: object.type,\n          last_event_id: action === 'establish' ? object.lastEventId : undefined,\n          index_name: action === 'establish' ? object.indexName : undefined,\n          query_string: action === 'establish' ? object.queryString : undefined\n        };\n      });\n      var retriedRequests = objects.filter(function (a) {\n        return a.retryCount > 0;\n      }).length;\n      logger_1.default.debug(\"Attempting '\".concat(action, \"' request (c:\").concat(correlationId, \"):\"), requests);\n      var requestBody = {\n        event_protocol_version: 3,\n        action: action,\n        correlation_id: correlationId,\n        retried_requests: retriedRequests,\n        ttl_in_s: -1,\n        requests: requests\n      };\n\n      if (reason === 'ttl') {\n        requestBody.reason = reason;\n      }\n\n      return this.services.network.post(this.services.config.subscriptionsUri, requestBody);\n    }\n    /**\n     * Establishes intent to be subscribed to this entity. That subscription will be effected\n     * asynchronously.\n     * If subscription to the given sid already exists, it will be overwritten.\n     *\n     * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.\n     * @param {Object} entity should represent the (singular) local representation of this entity.\n     *      Incoming events and modifications to the entity will be directed at the _update() function\n     *      of this provided reference.\n     *\n     * @return undefined\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(sid, entity) {\n      logger_1.default.debug(\"Establishing intent to subscribe to \".concat(sid));\n      var existingSubscription = this.subscriptions.get(sid);\n\n      if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {\n        // If last event id is the same as before - we're fine\n        return;\n      }\n\n      this.persisted.delete(sid);\n      this.subscriptions.set(sid, new SubscribedEntity(entity));\n      this.persist();\n    }\n    /**\n     * Establishes the caller's intent to no longer be subscribed to this entity. Following this\n     * call, no further events shall be routed to the local representation of the entity, even\n     * though a server-side subscription may take more time to actually terminate.\n     *\n     * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.\n     *      This call only has meaningful effect if that entity is subscribed at the\n     *      time of call. Otherwise does nothing.\n     *\n     * @return undefined\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(sid) {\n      logger_1.default.debug(\"Establishing intent to unsubscribe from \".concat(sid));\n      var removed = this.subscriptions.delete(sid);\n\n      if (removed) {\n        this.persist();\n      }\n    }\n    /**\n     * The point of ingestion for remote incoming messages (e.g. new data was written to a map\n     * to which we are subscribed).\n     *\n     * @param {object} message is the full, unaltered body of the incoming notification.\n     *\n     * @return undefined\n     */\n\n  }, {\n    key: \"acceptMessage\",\n    value: function acceptMessage(message, isStrictlyOrdered) {\n      logger_1.default.trace('Subscriptions received', message);\n\n      if (message.correlation_id) {\n        this.latestPokeResponseArrivalTimestampByCorrelationId.set(message.correlation_id, new Date().getTime());\n      }\n\n      var event_type;\n\n      switch (message.event_type) {\n        case 'subscription_established':\n          this.applySubscriptionEstablishedMessage(message.event, message.correlation_id);\n          break;\n\n        case 'subscription_canceled':\n          this.applySubscriptionCancelledMessage(message.event, message.correlation_id);\n          break;\n\n        case 'subscription_failed':\n          this.applySubscriptionFailedMessage(message.event, message.correlation_id);\n          break;\n\n        case (event_type = message.event_type.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:\n          {\n            var typedSid;\n\n            switch (event_type[0]) {\n              case 'map_':\n                typedSid = message.event.map_sid;\n                break;\n\n              case 'list_':\n                typedSid = message.event.list_sid;\n                break;\n\n              case 'document_':\n                typedSid = message.event.document_sid;\n                break;\n\n              case 'stream_':\n                typedSid = message.event.stream_sid;\n                break;\n\n              case 'live_query_':\n                typedSid = message.event.query_id; // hack to mark replay events for LiveQuery as strictly ordered, due to lack of special type of notification for them\n                // (normally only replay events would have `twilio.sync.event` type, but LiveQuery non-replay events were also assigned\n                // to this type in legacy clients, which we have to support now; hence a hack)\n\n                isStrictlyOrdered = false; // explicitly override it due to code in router.ts does not know about LiveQueries\n\n                if (message.strictly_ordered === true) {\n                  isStrictlyOrdered = true;\n                }\n\n                break;\n\n              default:\n                typedSid = undefined;\n            }\n\n            this.applyEventToSubscribedEntity(typedSid, message, isStrictlyOrdered);\n          }\n          break;\n\n        default:\n          logger_1.default.debug(\"Dropping unknown message type \".concat(message.event_type));\n          break;\n      }\n    }\n  }, {\n    key: \"applySubscriptionEstablishedMessage\",\n    value: function applySubscriptionEstablishedMessage(message, correlationId) {\n      var sid = message.object_sid;\n      var subscriptionIntent = this.persisted.get(message.object_sid);\n\n      if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {\n        if (message.replay_status === 'interrupted') {\n          logger_1.default.debug(\"Event Replay for subscription to \".concat(sid, \" (c:\").concat(correlationId, \") interrupted; continuing eagerly.\"));\n          subscriptionIntent.updatePending(null, null);\n          this.persisted.delete(subscriptionIntent.sid);\n          this.backoff.reset();\n        } else if (message.replay_status === 'completed') {\n          logger_1.default.debug(\"Event Replay for subscription to \".concat(sid, \" (c:\").concat(correlationId, \") completed. Subscription is ready.\"));\n          subscriptionIntent.complete(message.last_event_id);\n          this.persisted.set(message.object_sid, subscriptionIntent);\n          subscriptionIntent.setSubscriptionState('established');\n          this.backoff.reset();\n        }\n      } else {\n        logger_1.default.debug(\"Late message for \".concat(message.object_sid, \" (c:\").concat(correlationId, \") dropped.\"));\n      }\n\n      this.persist();\n    }\n  }, {\n    key: \"applySubscriptionCancelledMessage\",\n    value: function applySubscriptionCancelledMessage(message, correlationId) {\n      var persistedSubscription = this.persisted.get(message.object_sid);\n\n      if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {\n        persistedSubscription.updatePending(null, null);\n        persistedSubscription.setSubscriptionState('none');\n        this.persisted.delete(message.object_sid);\n      } else {\n        logger_1.default.debug(\"Late message for \".concat(message.object_sid, \" (c:\").concat(correlationId, \") dropped.\"));\n      }\n\n      this.persist();\n    }\n  }, {\n    key: \"applySubscriptionFailedMessage\",\n    value: function applySubscriptionFailedMessage(message, correlationId) {\n      var sid = message.object_sid;\n      var subscriptionIntent = this.subscriptions.get(sid);\n      var subscription = this.persisted.get(sid);\n\n      if (subscriptionIntent && subscription) {\n        if (subscription.pendingCorrelationId === correlationId) {\n          logger_1.default.error(\"Failed to subscribe on \".concat(subscription.sid), message.error);\n          subscription.markAsFailed(message);\n          subscription.setSubscriptionState('none');\n        }\n      } else if (!subscriptionIntent && subscription) {\n        this.persisted.delete(sid);\n        subscription.setSubscriptionState('none');\n      }\n\n      this.persist();\n    }\n  }, {\n    key: \"applyEventToSubscribedEntity\",\n    value: function applyEventToSubscribedEntity(sid, message, isStrictlyOrdered) {\n      var _this4 = this;\n\n      if (!sid) {\n        return;\n      } // Looking for subscription descriptor to check if poke has been completed\n\n\n      isStrictlyOrdered = isStrictlyOrdered || function () {\n        var subscription = _this4.persisted.get(sid);\n\n        return subscription && subscription.isEstablished;\n      }(); // Still searching for subscriptionIntents. User could remove subscription already\n\n\n      var subscriptionIntent = this.subscriptions.get(sid);\n\n      if (subscriptionIntent) {\n        message.event.type = message.event_type;\n        subscriptionIntent.update(message.event, isStrictlyOrdered);\n      } else {\n        logger_1.default.debug(\"Message dropped for SID '\".concat(sid, \"', for which there is no subscription.\"));\n      }\n    }\n  }, {\n    key: \"onConnectionStateChanged\",\n    value: function onConnectionStateChanged(isConnected) {\n      this.isConnected = isConnected;\n\n      if (isConnected) {\n        this.poke('reconnect');\n      }\n    }\n  }, {\n    key: \"onSubscriptionTtlElapsed\",\n    value: function onSubscriptionTtlElapsed() {\n      if (this.isConnected) {\n        this.poke('ttl');\n      }\n    }\n    /**\n     * Prompts a playback of any missed changes made to any subscribed object. This method\n     * should be invoked whenever the connectivity layer has experienced cross-cutting\n     * delivery failures that would affect the entire local sync set. Any tangible result\n     * of this operation will result in calls to the _update() function of subscribed\n     * Sync entities.\n     */\n\n  }, {\n    key: \"poke\",\n    value: function poke(reason) {\n      logger_1.default.debug(\"Triggering event replay for all subscriptions, reason=\".concat(reason));\n      this.pendingPokeReason = reason;\n\n      if (this.subscriptionTtlTimer) {\n        clearTimeout(this.subscriptionTtlTimer);\n        this.subscriptionTtlTimer = null;\n      }\n\n      var failedSubscriptions = [];\n\n      var _iterator4 = _createForOfIteratorHelper(this.persisted.values()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _it = _step4.value;\n\n          _it.reset();\n\n          if (_it.rejectedWithError) {\n            failedSubscriptions.push(_it);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this.persisted.clear();\n\n      for (var _i = 0, _failedSubscriptions = failedSubscriptions; _i < _failedSubscriptions.length; _i++) {\n        var it = _failedSubscriptions[_i];\n        this.persisted.set(it.sid, it);\n      }\n\n      this.persist();\n    }\n    /**\n     * Stops all communication, clears any subscription intent, and returns.\n     */\n\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      this.backoff.reset();\n      this.subscriptions.clear();\n    }\n  }]);\n\n  return Subscriptions;\n}();\n\nexports.Subscriptions = Subscriptions;","map":null,"metadata":{},"sourceType":"script"}