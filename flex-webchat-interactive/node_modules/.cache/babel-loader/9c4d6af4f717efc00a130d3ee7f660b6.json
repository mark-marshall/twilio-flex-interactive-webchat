{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _inherits = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _createClass = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/mmarshall/Desktop/flex-webchat-interactive/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TwilsockImpl = exports.TwilsockChannel = exports.Response = void 0;\n\nvar events_1 = require(\"events\");\n\nvar StateMachine = require(\"javascript-state-machine\");\n\nvar logger_1 = require(\"./logger\");\n\nvar Messages = require(\"./protocol/messages\");\n\nvar parser_1 = require(\"./parser\");\n\nvar twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\n\nvar backoffretrier_1 = require(\"./backoffretrier\");\n\nvar DISCONNECTING_TIMEOUT = 3000; // Wraps asynchronous rescheduling\n// Just makes it simpler to find these hacks over the code\n\nfunction trampoline(f) {\n  setTimeout(f, 0);\n}\n/**\n * Makes sure that body is properly stringified\n */\n\n\nfunction preparePayload(payload) {\n  switch (typeof payload) {\n    case 'undefined':\n      return '';\n\n    case 'object':\n      return JSON.stringify(payload);\n\n    default:\n      return payload;\n  }\n}\n\nvar Request = /*#__PURE__*/_createClass(function Request() {\n  _classCallCheck(this, Request);\n});\n\nvar Response = /*#__PURE__*/_createClass(function Response() {\n  _classCallCheck(this, Response);\n});\n\nexports.Response = Response;\n/**\n * Twilsock channel level protocol implementation\n */\n\nvar TwilsockChannel = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(TwilsockChannel, _events_1$EventEmitte);\n\n  var _super = _createSuper(TwilsockChannel);\n\n  function TwilsockChannel(websocket, transport, config) {\n    var _this;\n\n    _classCallCheck(this, TwilsockChannel);\n\n    _this = _super.call(this);\n    _this.terminalStates = ['disconnected', 'rejected'];\n    _this.lastEmittedState = undefined;\n    _this.tokenExpiredSasCode = 20104;\n    _this.terminationReason = 'Connection is not initialized';\n    _this.websocket = websocket;\n\n    _this.websocket.on('connected', function () {\n      return _this.fsm.socketConnected();\n    });\n\n    _this.websocket.on('disconnected', function (e) {\n      return _this.fsm.socketClosed();\n    });\n\n    _this.websocket.on('message', function (message) {\n      return _this.onIncomingMessage(message);\n    });\n\n    _this.websocket.on('socketError', function (e) {\n      return _this.emit('connectionError', {\n        terminal: false,\n        message: e.message,\n        httpStatusCode: null,\n        errorCode: null\n      });\n    });\n\n    _this.transport = transport;\n    _this.config = config;\n    _this.retrier = new backoffretrier_1.BackoffRetrier(config.retryPolicy);\n\n    _this.retrier.on('attempt', function () {\n      return _this.retry();\n    });\n\n    _this.retrier.on('failed', function (err) {\n      logger_1.log.warn(\"Retrying failed: \".concat(err.message));\n\n      _this.disconnect();\n    });\n\n    if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n      window.addEventListener('online', function () {\n        logger_1.log.debug('Browser reported connectivity state: online');\n\n        _this.fsm.systemOnline();\n      });\n      window.addEventListener('offline', function () {\n        logger_1.log.debug('Browser reported connectivity state: offline');\n\n        _this.websocket.close();\n\n        _this.fsm.socketClosed();\n      });\n    }\n\n    _this.fsm = new StateMachine({\n      init: 'disconnected',\n      transitions: [{\n        name: 'userConnect',\n        from: ['disconnected', 'rejected'],\n        to: 'connecting'\n      }, {\n        name: 'userConnect',\n        from: ['connecting', 'connected']\n      }, {\n        name: 'userDisconnect',\n        from: ['connecting', 'initialising', 'connected', 'updating', 'retrying', 'rejected', 'waitSocketClosed', 'waitOffloadSocketClosed'],\n        to: 'disconnecting'\n      }, {\n        name: 'userRetry',\n        from: ['retrying'],\n        to: 'connecting'\n      }, {\n        name: 'socketConnected',\n        from: ['connecting'],\n        to: 'initialising'\n      }, {\n        name: 'socketClosed',\n        from: ['connecting', 'initialising', 'connected', 'updating', 'error', 'waitOffloadSocketClosed'],\n        to: 'retrying'\n      }, {\n        name: 'socketClosed',\n        from: ['disconnecting'],\n        to: 'disconnected'\n      }, {\n        name: 'socketClosed',\n        from: ['waitSocketClosed'],\n        to: 'disconnected'\n      }, {\n        name: 'socketClosed',\n        from: ['rejected'],\n        to: 'rejected'\n      }, {\n        name: 'initSuccess',\n        from: ['initialising'],\n        to: 'connected'\n      }, {\n        name: 'initError',\n        from: ['initialising'],\n        to: 'error'\n      }, {\n        name: 'tokenRejected',\n        from: ['initialising', 'updating'],\n        to: 'rejected'\n      }, {\n        name: 'protocolError',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'error'\n      }, {\n        name: 'receiveClose',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'waitSocketClosed'\n      }, {\n        name: 'receiveOffload',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'waitOffloadSocketClosed'\n      }, {\n        name: 'unsupportedProtocol',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'unsupported'\n      }, {\n        name: 'receiveFatalClose',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'unsupported'\n      }, {\n        name: 'userUpdateToken',\n        from: ['disconnected', 'rejected', 'connecting', 'retrying'],\n        to: 'connecting'\n      }, {\n        name: 'userUpdateToken',\n        from: ['connected'],\n        to: 'updating'\n      }, {\n        name: 'updateSuccess',\n        from: ['updating'],\n        to: 'connected'\n      }, {\n        name: 'updateError',\n        from: ['updating'],\n        to: 'error'\n      }, {\n        name: 'userSend',\n        from: ['connected'],\n        to: 'connected'\n      }, {\n        name: 'systemOnline',\n        from: ['retrying'],\n        to: 'connecting'\n      }],\n      methods: {\n        onConnecting: function onConnecting() {\n          _this.setupSocket();\n\n          _this.emit('connecting');\n        },\n        onEnterInitialising: function onEnterInitialising() {\n          _this.sendInit();\n        },\n        onLeaveInitialising: function onLeaveInitialising() {\n          _this.cancelInit();\n        },\n        onEnterUpdating: function onEnterUpdating() {\n          _this.sendUpdate();\n        },\n        onLeaveUpdating: function onLeaveUpdating() {\n          _this.cancelUpdate();\n        },\n        onEnterRetrying: function onEnterRetrying() {\n          _this.initRetry();\n\n          _this.emit('connecting');\n        },\n        onEnterConnected: function onEnterConnected() {\n          _this.resetBackoff();\n\n          _this.onConnected();\n        },\n        onUserUpdateToken: function onUserUpdateToken() {\n          _this.resetBackoff();\n        },\n        onTokenRejected: function onTokenRejected() {\n          _this.resetBackoff();\n\n          _this.closeSocket(true);\n\n          _this.finalizeSocket();\n        },\n        onUserDisconnect: function onUserDisconnect() {\n          _this.closeSocket(true);\n        },\n        onEnterDisconnecting: function onEnterDisconnecting() {\n          _this.startDisconnectTimer();\n        },\n        onLeaveDisconnecting: function onLeaveDisconnecting() {\n          _this.cancelDisconnectTimer();\n        },\n        onEnterWaitSocketClosed: function onEnterWaitSocketClosed() {\n          _this.startDisconnectTimer();\n        },\n        onLeaveWaitSocketClosed: function onLeaveWaitSocketClosed() {\n          _this.cancelDisconnectTimer();\n        },\n        onEnterWaitOffloadSocketClosed: function onEnterWaitOffloadSocketClosed() {\n          _this.startDisconnectTimer();\n        },\n        onLeaveWaitOffloadSocketClosed: function onLeaveWaitOffloadSocketClosed() {\n          _this.cancelDisconnectTimer();\n        },\n        onDisconnected: function onDisconnected() {\n          _this.resetBackoff();\n\n          _this.finalizeSocket();\n        },\n        onReceiveClose: function onReceiveClose(event, args) {\n          _this.onCloseReceived(args);\n        },\n        onReceiveOffload: function onReceiveOffload(event, args) {\n          logger_1.log.debug('onreceiveoffload: ', args);\n\n          _this.modifyBackoff(args.body);\n\n          _this.onCloseReceived(args.status);\n        },\n        onUnsupported: function onUnsupported() {\n          _this.closeSocket(true);\n\n          _this.finalizeSocket();\n        },\n        onError: function onError(lifecycle, graceful) {\n          _this.closeSocket(graceful);\n\n          _this.finalizeSocket();\n        },\n        onEnterState: function onEnterState(event) {\n          if (event.from !== 'none') {\n            _this.changeState(event);\n          }\n        },\n        onInvalidTransition: function onInvalidTransition(transition, from, to) {\n          logger_1.log.warn('FSM: unexpected transition', from, to);\n        }\n      }\n    });\n    return _this;\n  }\n\n  _createClass(TwilsockChannel, [{\n    key: \"changeState\",\n    value: function changeState(event) {\n      logger_1.log.debug(\"FSM: \".concat(event.transition, \": \").concat(event.from, \" --> \").concat(event.to));\n\n      if (this.lastEmittedState !== this.state) {\n        this.lastEmittedState = this.state;\n        this.emit('stateChanged', this.state);\n      }\n    }\n  }, {\n    key: \"resetBackoff\",\n    value: function resetBackoff() {\n      logger_1.log.trace('resetBackoff');\n      this.retrier.stop();\n    }\n  }, {\n    key: \"modifyBackoff\",\n    value: function modifyBackoff(body) {\n      logger_1.log.trace('modifyBackoff', body);\n      var backoffPolicy = body ? body.backoff_policy : null;\n\n      if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === 'number') {\n        this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);\n      }\n    }\n  }, {\n    key: \"startDisconnectTimer\",\n    value: function startDisconnectTimer() {\n      var _this2 = this;\n\n      logger_1.log.trace('startDisconnectTimer');\n\n      if (this.disconnectingTimer) {\n        clearTimeout(this.disconnectingTimer);\n        this.disconnectingTimer = null;\n      }\n\n      this.disconnectingTimer = setTimeout(function () {\n        logger_1.log.debug('disconnecting is timed out');\n\n        _this2.closeSocket(true);\n      }, DISCONNECTING_TIMEOUT);\n    }\n  }, {\n    key: \"cancelDisconnectTimer\",\n    value: function cancelDisconnectTimer() {\n      logger_1.log.trace('cancelDisconnectTimer');\n\n      if (this.disconnectingTimer) {\n        clearTimeout(this.disconnectingTimer);\n        this.disconnectingTimer = null;\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.state === 'connected' && this.websocket.isConnected;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      switch (this.fsm.state) {\n        case 'connecting':\n        case 'initialising':\n        case 'retrying':\n        case 'error':\n          return 'connecting';\n\n        case 'updating':\n        case 'connected':\n          return 'connected';\n\n        case 'rejected':\n          return 'rejected';\n\n        case 'disconnecting':\n        case 'waitSocketClosed':\n        case 'waitOffloadSocketClosed':\n          return 'disconnecting';\n\n        case 'disconnected':\n        default:\n          return 'disconnected';\n      }\n    }\n  }, {\n    key: \"initRetry\",\n    value: function initRetry() {\n      logger_1.log.debug('initRetry');\n\n      if (this.retrier.inProgress) {\n        this.retrier.attemptFailed();\n      } else {\n        this.retrier.start();\n      }\n    }\n  }, {\n    key: \"retry\",\n    value: function retry() {\n      if (this.fsm.state != 'connecting') {\n        logger_1.log.trace('retry');\n        this.websocket.close();\n        this.fsm.userRetry();\n      } else {\n        logger_1.log.trace('can\\t retry as already connecting');\n      }\n    }\n  }, {\n    key: \"onConnected\",\n    value: function onConnected() {\n      this.emit('connected');\n    }\n  }, {\n    key: \"finalizeSocket\",\n    value: function finalizeSocket() {\n      logger_1.log.trace('finalizeSocket');\n      this.websocket.close();\n      this.emit('disconnected');\n\n      if (this.disconnectedPromiseResolve) {\n        this.disconnectedPromiseResolve();\n        this.disconnectedPromiseResolve = null;\n      }\n    }\n  }, {\n    key: \"setupSocket\",\n    value: function setupSocket() {\n      logger_1.log.trace('setupSocket:', this.config.token);\n      this.emit('beforeConnect'); // This is used by client to record startup telemetry event\n\n      this.websocket.connect();\n    }\n  }, {\n    key: \"onIncomingMessage\",\n    value: function onIncomingMessage(message) {\n      var _parser_1$Parser$pars = parser_1.Parser.parse(message),\n          method = _parser_1$Parser$pars.method,\n          header = _parser_1$Parser$pars.header,\n          payload = _parser_1$Parser$pars.payload;\n\n      if (method !== 'reply') {\n        this.confirmReceiving(header);\n      }\n\n      if (method === 'notification') {\n        this.emit('message', header.message_type, payload);\n      } else if (header.method === 'reply') {\n        this.transport.processReply({\n          id: header.id,\n          status: header.status,\n          header: header,\n          body: payload\n        });\n      } else if (header.method === 'client_update') {\n        if (header.client_update_type === 'token_about_to_expire') {\n          this.emit('tokenAboutToExpire');\n        }\n      } else if (header.method === 'close') {\n        if (header.status.code === 308) {\n          logger_1.log.debug('Connection has been offloaded');\n          this.fsm.receiveOffload({\n            status: header.status.status,\n            body: payload\n          });\n        } else if (header.status.code === 406) {\n          // Not acceptable message\n          var _message = \"Server closed connection because can't parse protocol: \".concat(JSON.stringify(header.status));\n\n          this.emitReplyConnectionError(_message, header, true);\n          logger_1.log.error(_message);\n          this.fsm.receiveFatalClose();\n        } else if (header.status.code === 417) {\n          // Protocol error\n          logger_1.log.error(\"Server closed connection because can't parse client reply: \".concat(JSON.stringify(header.status)));\n          this.fsm.receiveFatalClose(header.status.status);\n        } else if (header.status.code === 410) {\n          // Expired token\n          logger_1.log.warn(\"Server closed connection: \".concat(JSON.stringify(header.status)));\n          this.fsm.receiveClose(header.status.status);\n          this.emit('tokenExpired');\n        } else if (header.status.code === 401) {\n          // Authentication fail\n          logger_1.log.error(\"Server closed connection: \".concat(JSON.stringify(header.status)));\n          this.fsm.receiveClose(header.status.status);\n        } else {\n          logger_1.log.warn('unexpected message: ', header.status); // Try to reconnect\n\n          this.fsm.receiveOffload({\n            status: header.status.status,\n            body: null\n          });\n        }\n      }\n    }\n  }, {\n    key: \"sendInit\",\n    value: function () {\n      var _sendInit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var reply, isTerminalError;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger_1.log.trace('sendInit');\n                _context.prev = 1;\n                this.emit('beforeSendInit'); // This is used by client to record startup telemetry event\n\n                _context.next = 5;\n                return this.transport.sendInit();\n\n              case 5:\n                reply = _context.sent;\n                this.config.updateContinuationToken(reply.continuationToken);\n                this.config.confirmedCapabilities = reply.confirmedCapabilities;\n                this.fsm.initSuccess(reply);\n                this.emit('initialized', reply);\n                this.emit('tokenUpdated');\n                _context.next = 17;\n                break;\n\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](1);\n\n                if (_context.t0 instanceof twilsockreplyerror_1.TwilsockReplyError) {\n                  isTerminalError = false;\n                  logger_1.log.warn(\"Init rejected by server: \".concat(JSON.stringify(_context.t0.reply.status)));\n                  this.emit('sendInitFailed'); // This is used by client to record startup telemetry event\n                  // @todo emit telemetry from inside \"if\" below for more granularity...\n\n                  if (_context.t0.reply.status.code === 401 || _context.t0.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(_context.t0.reply.status);\n\n                    if (_context.t0.reply.status.errorCode === this.tokenExpiredSasCode) {\n                      this.emit('tokenExpired');\n                    }\n                  } else if (_context.t0.reply.status.code === 429) {\n                    this.modifyBackoff(_context.t0.reply.body);\n                    this.fsm.initError(true);\n                  } else if (_context.t0.reply.status.code === 500) {\n                    this.fsm.initError(false);\n                  } else {\n                    this.fsm.initError(true);\n                  }\n\n                  this.emitReplyConnectionError(_context.t0.message, _context.t0.reply, isTerminalError);\n                } else {\n                  this.terminationReason = _context.t0.message;\n                  this.emit('connectionError', {\n                    terminal: true,\n                    message: _context.t0.message,\n                    httpStatusCode: null,\n                    errorCode: null\n                  });\n                  this.fsm.initError(true);\n                }\n\n                this.emit('tokenUpdated', _context.t0);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 13]]);\n      }));\n\n      function sendInit() {\n        return _sendInit.apply(this, arguments);\n      }\n\n      return sendInit;\n    }()\n  }, {\n    key: \"sendUpdate\",\n    value: function () {\n      var _sendUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var message, reply, isTerminalError;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger_1.log.trace('sendUpdate');\n                message = new Messages.Update(this.config.token);\n                _context2.prev = 2;\n                _context2.next = 5;\n                return this.transport.sendWithReply(message);\n\n              case 5:\n                reply = _context2.sent;\n                this.fsm.updateSuccess(reply.body);\n                this.emit('tokenUpdated');\n                _context2.next = 14;\n                break;\n\n              case 10:\n                _context2.prev = 10;\n                _context2.t0 = _context2[\"catch\"](2);\n\n                if (_context2.t0 instanceof twilsockreplyerror_1.TwilsockReplyError) {\n                  isTerminalError = false;\n                  logger_1.log.warn(\"Token update rejected by server: \".concat(JSON.stringify(_context2.t0.reply.status)));\n\n                  if (_context2.t0.reply.status.code === 401 || _context2.t0.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(_context2.t0.reply.status);\n\n                    if (_context2.t0.reply.status.errorCode === this.tokenExpiredSasCode) {\n                      this.emit('tokenExpired');\n                    }\n                  } else if (_context2.t0.reply.status.code === 429) {\n                    this.modifyBackoff(_context2.t0.reply.body);\n                    this.fsm.updateError(_context2.t0.reply.status);\n                  } else {\n                    this.fsm.updateError(_context2.t0.reply.status);\n                  }\n\n                  this.emitReplyConnectionError(_context2.t0.message, _context2.t0.reply, isTerminalError);\n                } else {\n                  this.emit('error', false, _context2.t0.message, null, null);\n                  this.fsm.updateError(_context2.t0);\n                }\n\n                this.emit('tokenUpdated', _context2.t0);\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 10]]);\n      }));\n\n      function sendUpdate() {\n        return _sendUpdate.apply(this, arguments);\n      }\n\n      return sendUpdate;\n    }()\n  }, {\n    key: \"emitReplyConnectionError\",\n    value: function emitReplyConnectionError(message, header, terminal) {\n      var description = header.status && header.status.description ? header.status.description : message;\n      var httpStatusCode = header.status.code;\n      var errorCode = header.status && header.status.errorCode ? header.status.errorCode : null;\n\n      if (terminal) {\n        this.terminationReason = description;\n      }\n\n      this.emit('connectionError', {\n        terminal: terminal,\n        message: description,\n        httpStatusCode: httpStatusCode,\n        errorCode: errorCode\n      });\n    }\n  }, {\n    key: \"cancelInit\",\n    value: function cancelInit() {\n      logger_1.log.trace('cancelInit'); // TODO: implement\n    }\n  }, {\n    key: \"cancelUpdate\",\n    value: function cancelUpdate() {\n      logger_1.log.trace('cancelUpdate'); // TODO: implement\n    }\n    /**\n     * Should be called for each message to confirm it received\n     */\n\n  }, {\n    key: \"confirmReceiving\",\n    value: function confirmReceiving(messageHeader) {\n      logger_1.log.trace('confirmReceiving');\n\n      try {\n        //@todo send telemetry events AnyEvents\n        this.transport.send(new Messages.Reply(messageHeader.id));\n      } catch (e) {\n        logger_1.log.debug('failed to confirm packet receiving', e);\n      }\n    }\n    /**\n     * Shutdown connection\n     */\n\n  }, {\n    key: \"closeSocket\",\n    value: function closeSocket(graceful) {\n      var _this3 = this;\n\n      logger_1.log.trace(\"closeSocket (graceful: \".concat(graceful, \")\"));\n\n      if (graceful && this.transport.isConnected) {\n        this.transport.sendClose();\n      }\n\n      this.websocket.close();\n      trampoline(function () {\n        return _this3.fsm.socketClosed();\n      });\n    }\n    /**\n     * Initiate the twilsock connection\n     * If already connected, it does nothing\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      logger_1.log.trace('connect');\n      this.fsm.userConnect();\n    }\n    /**\n     * Close twilsock connection\n     * If already disconnected, it does nothing\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var _this4 = this;\n\n      logger_1.log.trace('disconnect');\n\n      if (this.fsm.is('disconnected')) {\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve) {\n        _this4.disconnectedPromiseResolve = resolve;\n\n        _this4.fsm.userDisconnect();\n      });\n    }\n    /**\n     * Update fpa token for twilsock connection\n     */\n\n  }, {\n    key: \"updateToken\",\n    value: function updateToken(token) {\n      var _this5 = this;\n\n      logger_1.log.trace('updateToken:', token);\n      return new Promise(function (resolve, reject) {\n        _this5.once('tokenUpdated', function (e) {\n          if (e) {\n            reject(e);\n          } else {\n            resolve();\n          }\n        });\n\n        _this5.fsm.userUpdateToken();\n      });\n    }\n  }, {\n    key: \"isTerminalState\",\n    get: function get() {\n      return this.terminalStates.indexOf(this.fsm.state) !== -1;\n    }\n  }, {\n    key: \"getTerminationReason\",\n    get: function get() {\n      return this.terminationReason;\n    }\n  }, {\n    key: \"onCloseReceived\",\n    value: function onCloseReceived(reason) {\n      this.websocket.close();\n    }\n  }]);\n\n  return TwilsockChannel;\n}(events_1.EventEmitter);\n\nexports.TwilsockChannel = TwilsockChannel;\nexports.TwilsockImpl = TwilsockChannel;","map":null,"metadata":{},"sourceType":"script"}