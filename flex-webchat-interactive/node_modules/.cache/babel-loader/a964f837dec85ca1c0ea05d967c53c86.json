{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pointer = void 0;\n/**\nUnescape token part of a JSON Pointer string\n\n`token` should *not* contain any '/' characters.\n\n> Evaluation of each reference token begins by decoding any escaped\n> character sequence.  This is performed by first transforming any\n> occurrence of the sequence '~1' to '/', and then transforming any\n> occurrence of the sequence '~0' to '~'.  By performing the\n> substitutions in this order, an implementation avoids the error of\n> turning '~01' first into '~1' and then into '/', which would be\n> incorrect (the string '~01' correctly becomes '~1' after\n> transformation).\n\nHere's my take:\n\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\n*/\n\nfunction unescape(token) {\n  return token.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n/** Escape token part of a JSON Pointer string\n\n> '~' needs to be encoded as '~0' and '/'\n> needs to be encoded as '~1' when these characters appear in a\n> reference token.\n\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\n*/\n\n\nfunction escape(token) {\n  return token.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n/**\nJSON Pointer representation\n*/\n\n\nvar Pointer =\n/** @class */\nfunction () {\n  function Pointer(tokens) {\n    if (tokens === void 0) {\n      tokens = [''];\n    }\n\n    this.tokens = tokens;\n  }\n  /**\n  `path` *must* be a properly escaped string.\n  */\n\n\n  Pointer.fromJSON = function (path) {\n    var tokens = path.split('/').map(unescape);\n    if (tokens[0] !== '') throw new Error(\"Invalid JSON Pointer: \" + path);\n    return new Pointer(tokens);\n  };\n\n  Pointer.prototype.toString = function () {\n    return this.tokens.map(escape).join('/');\n  };\n  /**\n  Returns an object with 'parent', 'key', and 'value' properties.\n  In the special case that this Pointer's path == \"\",\n  this object will be {parent: null, key: '', value: object}.\n  Otherwise, parent and key will have the property such that parent[key] == value.\n  */\n\n\n  Pointer.prototype.evaluate = function (object) {\n    var parent = null;\n    var key = '';\n    var value = object;\n\n    for (var i = 1, l = this.tokens.length; i < l; i++) {\n      parent = value;\n      key = this.tokens[i]; // not sure if this the best way to handle non-existant paths...\n\n      value = (parent || {})[key];\n    }\n\n    return {\n      parent: parent,\n      key: key,\n      value: value\n    };\n  };\n\n  Pointer.prototype.get = function (object) {\n    return this.evaluate(object).value;\n  };\n\n  Pointer.prototype.set = function (object, value) {\n    var cursor = object;\n\n    for (var i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\n      // not sure if this the best way to handle non-existant paths...\n      cursor = (cursor || {})[token];\n    }\n\n    if (cursor) {\n      cursor[this.tokens[this.tokens.length - 1]] = value;\n    }\n  };\n\n  Pointer.prototype.push = function (token) {\n    // mutable\n    this.tokens.push(token);\n  };\n  /**\n  `token` should be a String. It'll be coerced to one anyway.\n     immutable (shallowly)\n  */\n\n\n  Pointer.prototype.add = function (token) {\n    var tokens = this.tokens.concat(String(token));\n    return new Pointer(tokens);\n  };\n\n  return Pointer;\n}();\n\nexports.Pointer = Pointer;","map":null,"metadata":{},"sourceType":"script"}