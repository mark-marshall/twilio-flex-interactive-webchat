{"ast":null,"code":"\"use strict\";\n\nvar _regenerator = require(\"babel-runtime/regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require(\"babel-runtime/helpers/asyncToGenerator\");\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _promise = require(\"babel-runtime/core-js/promise\");\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _map = require(\"babel-runtime/core-js/map\");\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar uuid = require(\"uuid\");\n\nvar platform = require(\"platform\");\n\nvar responsecodes_1 = require(\"./interfaces/responsecodes\");\n\nvar logger_1 = require(\"./logger\");\n\nvar sessionerror_1 = require(\"./sessionerror\");\n\nvar deferred_1 = require(\"./util/deferred\");\n\nvar iso8601_duration_1 = require(\"iso8601-duration\");\n\nvar SDK_VERSION = require('./../package.json').version;\n\nvar SESSION_PURPOSE = 'com.twilio.rtd.ipmsg';\nvar log = logger_1.Logger.scope('Session');\n\nvar Command = function Command() {\n  (0, _classCallCheck3.default)(this, Command);\n};\n\nfunction hasAllPropertiesSet(obj, properties) {\n  return !properties.some(function (prop) {\n    return !obj.hasOwnProperty(prop);\n  });\n}\n/**\n *  Constructs the instance of Session\n *\n *  @classdesc Provides the interface to send the command to the server\n *  It is reliable, which means that it tracks the command object state\n *  and waits the answer from the server.\n */\n\n\nvar Session = function () {\n  function Session(services, config) {\n    (0, _classCallCheck3.default)(this, Session);\n    var platformInfo = typeof navigator !== 'undefined' ? platform.parse(navigator.userAgent) : platform;\n    this.services = services;\n    this.config = config;\n    this.sessionInfo = new deferred_1.Deferred();\n    this.currentContext = {};\n    this.pendingCommands = new _map2.default();\n    this.sessionStreamPromise = null;\n    this.endpointPlatform = ['js', SDK_VERSION, platformInfo.os, platformInfo.name, platformInfo.version].join('|');\n  }\n\n  (0, _createClass3.default)(Session, [{\n    key: \"handleContextUpdate\",\n    value: function handleContextUpdate(updatedContext) {\n      log.info('Session context updated');\n      log.debug('new session context:', updatedContext);\n      this.currentContext = updatedContext;\n\n      if (!hasAllPropertiesSet(updatedContext, ['identity', 'userInfo', 'links', 'myChannels', 'channels'])) {\n        return; // not enough data to proceed, wait\n      }\n\n      log.info('new session context accepted');\n      this.sessionInfo.set(updatedContext);\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n\n      var context = {\n        type: 'IpMsgSession',\n        apiVersion: '3',\n        endpointPlatform: this.endpointPlatform\n      };\n      this.sessionStreamPromise = this.services.syncClient.list({\n        purpose: SESSION_PURPOSE,\n        context: context\n      }).then(function (list) {\n        log.info('Session created', list.sid);\n        list.on('itemAdded', function (args) {\n          return _this.processCommandResponse(args.item);\n        });\n        list.on('itemUpdated', function (args) {\n          return _this.processCommandResponse(args.item);\n        });\n        list.on('contextUpdated', function (args) {\n          return _this.handleContextUpdate(args.context);\n        });\n        return list;\n      }).catch(function (err) {\n        log.error('Failed to create session', err);\n        throw err;\n      });\n      return this.sessionStreamPromise;\n    }\n    /**\n     * Sends the command to the server\n     * @returns Promise the promise, which is being fulfilled only when service will reply\n     */\n\n  }, {\n    key: \"addCommand\",\n    value: function addCommand(action, params) {\n      return this.processCommand(action, params);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"processCommand\",\n    value: function processCommand(action, params) {\n      var _this2 = this;\n\n      var createSessionIfNotFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var command = new Command();\n      command.request = params;\n      command.request.action = action;\n      command.commandId = uuid.v4();\n      log.info('Adding command: ', action, command.commandId);\n      log.debug('command arguments:', params, createSessionIfNotFound);\n      return new _promise2.default(function (resolve, reject) {\n        _this2.sessionStreamPromise.then(function (list) {\n          _this2.pendingCommands.set(command.commandId, {\n            resolve: resolve,\n            reject: reject,\n            commandId: command.commandId,\n            request: command.request\n          });\n\n          return list.push(command);\n        }).then(function () {\n          return log.debug('Command accepted by server', command.commandId);\n        }).catch(function (err) {\n          _this2.pendingCommands.delete(command.commandId);\n\n          log.error('Failed to add a command to the session', err);\n\n          if ((err.code == responsecodes_1.ResponseCodes.ACCESS_FORBIDDEN_FOR_IDENTITY || err.code === responsecodes_1.ResponseCodes.LIST_NOT_FOUND) && createSessionIfNotFound) {\n            log.info('recreating session...');\n\n            _this2.initialize();\n\n            resolve(_this2.processCommand(action, params, false)); // second attempt\n          } else {\n            reject(new Error('Can\\'t add command: ' + err.message));\n          }\n        });\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"processCommandResponse\",\n    value: function processCommandResponse(entity) {\n      if (entity.value.hasOwnProperty('response') && entity.value.hasOwnProperty('commandId') && this.pendingCommands.has(entity.value.commandId)) {\n        var value = entity.value;\n        var commandId = entity.value.commandId;\n\n        if (value.response.status === responsecodes_1.ResponseCodes.HTTP_200_OK) {\n          log.debug('Command succeeded: ', value);\n          var resolve = this.pendingCommands.get(commandId).resolve;\n          this.pendingCommands.delete(commandId);\n          resolve(value.response);\n        } else {\n          log.error('Command failed: ', value);\n          var reject = this.pendingCommands.get(commandId).reject;\n          this.pendingCommands.delete(commandId);\n          reject(new sessionerror_1.SessionError(value.response.statusText, value.response.status));\n        }\n      }\n    }\n  }, {\n    key: \"getSessionContext\",\n    value: function getSessionContext() {\n      return this.sessionStreamPromise.then(function (stream) {\n        return stream.getContext();\n      });\n    }\n  }, {\n    key: \"getSessionLinks\",\n    value: function () {\n      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {\n        var info;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.sessionInfo.promise;\n\n              case 2:\n                info = _context.sent;\n                return _context.abrupt(\"return\", {\n                  publicChannelsUrl: this.config.baseUrl + info.links.publicChannelsUrl,\n                  myChannelsUrl: this.config.baseUrl + info.links.myChannelsUrl,\n                  typingUrl: this.config.baseUrl + info.links.typingUrl,\n                  syncListUrl: this.config.baseUrl + info.links.syncListUrl,\n                  usersUrl: this.config.baseUrl + info.links.usersUrl,\n                  mediaServiceUrl: info.links.mediaServiceUrl\n                });\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getSessionLinks() {\n        return _ref.apply(this, arguments);\n      }\n\n      return getSessionLinks;\n    }()\n  }, {\n    key: \"getChannelsId\",\n    value: function () {\n      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {\n        var info;\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.sessionInfo.promise;\n\n              case 2:\n                info = _context2.sent;\n                return _context2.abrupt(\"return\", info.channels);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getChannelsId() {\n        return _ref2.apply(this, arguments);\n      }\n\n      return getChannelsId;\n    }()\n  }, {\n    key: \"getMyChannelsId\",\n    value: function () {\n      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {\n        var info;\n        return _regenerator2.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.sessionInfo.promise;\n\n              case 2:\n                info = _context3.sent;\n                return _context3.abrupt(\"return\", info.myChannels);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getMyChannelsId() {\n        return _ref3.apply(this, arguments);\n      }\n\n      return getMyChannelsId;\n    }()\n  }, {\n    key: \"getMaxUserInfosToSubscribe\",\n    value: function () {\n      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {\n        var info;\n        return _regenerator2.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.sessionInfo.promise;\n\n              case 2:\n                info = _context4.sent;\n                return _context4.abrupt(\"return\", this.config.userInfosToSubscribeOverride || info.userInfosToSubscribe || this.config.userInfosToSubscribeDefault);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getMaxUserInfosToSubscribe() {\n        return _ref4.apply(this, arguments);\n      }\n\n      return getMaxUserInfosToSubscribe;\n    }()\n  }, {\n    key: \"getUsersData\",\n    value: function getUsersData() {\n      return this.sessionInfo.promise.then(function (info) {\n        return {\n          user: info.userInfo,\n          identity: info.identity\n        };\n      });\n    }\n  }, {\n    key: \"getConsumptionReportInterval\",\n    value: function () {\n      var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {\n        var context, consumptionIntervalToUse;\n        return _regenerator2.default.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.getSessionContext();\n\n              case 2:\n                context = _context5.sent;\n                consumptionIntervalToUse = this.config.consumptionReportIntervalOverride || context.consumptionReportInterval || this.config.consumptionReportIntervalDefault;\n                _context5.prev = 4;\n                return _context5.abrupt(\"return\", iso8601_duration_1.toSeconds(iso8601_duration_1.parse(consumptionIntervalToUse)));\n\n              case 8:\n                _context5.prev = 8;\n                _context5.t0 = _context5[\"catch\"](4);\n                log.error('Failed to parse consumption report interval', consumptionIntervalToUse, 'using default value', this.config.consumptionReportIntervalDefault);\n                return _context5.abrupt(\"return\", iso8601_duration_1.toSeconds(iso8601_duration_1.parse(this.config.consumptionReportIntervalDefault)));\n\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[4, 8]]);\n      }));\n\n      function getConsumptionReportInterval() {\n        return _ref5.apply(this, arguments);\n      }\n\n      return getConsumptionReportInterval;\n    }()\n  }, {\n    key: \"getHttpCacheInterval\",\n    value: function () {\n      var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {\n        var context, cacheIntervalToUse;\n        return _regenerator2.default.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.getSessionContext();\n\n              case 2:\n                context = _context6.sent;\n                cacheIntervalToUse = this.config.httpCacheIntervalOverride || context.httpCacheInterval || this.config.httpCacheIntervalDefault;\n                _context6.prev = 4;\n                return _context6.abrupt(\"return\", iso8601_duration_1.toSeconds(iso8601_duration_1.parse(cacheIntervalToUse)));\n\n              case 8:\n                _context6.prev = 8;\n                _context6.t0 = _context6[\"catch\"](4);\n                log.error('Failed to parse cache interval', cacheIntervalToUse, 'using default value', this.config.httpCacheIntervalDefault);\n                return _context6.abrupt(\"return\", iso8601_duration_1.toSeconds(iso8601_duration_1.parse(this.config.httpCacheIntervalDefault)));\n\n              case 12:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[4, 8]]);\n      }));\n\n      function getHttpCacheInterval() {\n        return _ref6.apply(this, arguments);\n      }\n\n      return getHttpCacheInterval;\n    }()\n  }, {\n    key: \"identity\",\n    get: function get() {\n      return this.sessionInfo.current.identity;\n    }\n  }, {\n    key: \"reachabilityEnabled\",\n    get: function get() {\n      return this.currentContext.reachabilityEnabled;\n    }\n  }]);\n  return Session;\n}();\n\nexports.Session = Session;","map":null,"metadata":{},"sourceType":"script"}