{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {\n    to[j] = from[i];\n  }\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFunctionName = exports.getBaseClassDependencyCount = exports.getDependencies = void 0;\n\nvar inject_1 = require(\"../annotation/inject\");\n\nvar ERROR_MSGS = require(\"../constants/error_msgs\");\n\nvar literal_types_1 = require(\"../constants/literal_types\");\n\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\n\nvar serialization_1 = require(\"../utils/serialization\");\n\nObject.defineProperty(exports, \"getFunctionName\", {\n  enumerable: true,\n  get: function get() {\n    return serialization_1.getFunctionName;\n  }\n});\n\nvar target_1 = require(\"./target\");\n\nfunction getDependencies(metadataReader, func) {\n  var constructorName = serialization_1.getFunctionName(func);\n  var targets = getTargets(metadataReader, constructorName, func, false);\n  return targets;\n}\n\nexports.getDependencies = getDependencies;\n\nfunction getTargets(metadataReader, constructorName, func, isBaseClass) {\n  var metadata = metadataReader.getConstructorMetadata(func);\n  var serviceIdentifiers = metadata.compilerGeneratedMetadata;\n\n  if (serviceIdentifiers === undefined) {\n    var msg = ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION + \" \" + constructorName + \".\";\n    throw new Error(msg);\n  }\n\n  var constructorArgsMetadata = metadata.userGeneratedMetadata;\n  var keys = Object.keys(constructorArgsMetadata);\n  var hasUserDeclaredUnknownInjections = func.length === 0 && keys.length > 0;\n  var hasOptionalParameters = keys.length > func.length;\n  var iterations = hasUserDeclaredUnknownInjections || hasOptionalParameters ? keys.length : func.length;\n  var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);\n  var propertyTargets = getClassPropsAsTargets(metadataReader, func);\n\n  var targets = __spreadArray(__spreadArray([], constructorTargets), propertyTargets);\n\n  return targets;\n}\n\nfunction getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {\n  var targetMetadata = constructorArgsMetadata[index.toString()] || [];\n  var metadata = formatTargetMetadata(targetMetadata);\n  var isManaged = metadata.unmanaged !== true;\n  var serviceIdentifier = serviceIdentifiers[index];\n  var injectIdentifier = metadata.inject || metadata.multiInject;\n  serviceIdentifier = injectIdentifier ? injectIdentifier : serviceIdentifier;\n\n  if (serviceIdentifier instanceof inject_1.LazyServiceIdentifer) {\n    serviceIdentifier = serviceIdentifier.unwrap();\n  }\n\n  if (isManaged) {\n    var isObject = serviceIdentifier === Object;\n    var isFunction = serviceIdentifier === Function;\n    var isUndefined = serviceIdentifier === undefined;\n    var isUnknownType = isObject || isFunction || isUndefined;\n\n    if (!isBaseClass && isUnknownType) {\n      var msg = ERROR_MSGS.MISSING_INJECT_ANNOTATION + \" argument \" + index + \" in class \" + constructorName + \".\";\n      throw new Error(msg);\n    }\n\n    var target = new target_1.Target(literal_types_1.TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);\n    target.metadata = targetMetadata;\n    return target;\n  }\n\n  return null;\n}\n\nfunction getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {\n  var targets = [];\n\n  for (var i = 0; i < iterations; i++) {\n    var index = i;\n    var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);\n\n    if (target !== null) {\n      targets.push(target);\n    }\n  }\n\n  return targets;\n}\n\nfunction getClassPropsAsTargets(metadataReader, constructorFunc) {\n  var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);\n  var targets = [];\n  var keys = Object.keys(classPropsMetadata);\n\n  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n    var key = keys_1[_i];\n    var targetMetadata = classPropsMetadata[key];\n    var metadata = formatTargetMetadata(classPropsMetadata[key]);\n    var targetName = metadata.targetName || key;\n    var serviceIdentifier = metadata.inject || metadata.multiInject;\n    var target = new target_1.Target(literal_types_1.TargetTypeEnum.ClassProperty, targetName, serviceIdentifier);\n    target.metadata = targetMetadata;\n    targets.push(target);\n  }\n\n  var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;\n\n  if (baseConstructor !== Object) {\n    var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor);\n    targets = __spreadArray(__spreadArray([], targets), baseTargets);\n  }\n\n  return targets;\n}\n\nfunction getBaseClassDependencyCount(metadataReader, func) {\n  var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;\n\n  if (baseConstructor !== Object) {\n    var baseConstructorName = serialization_1.getFunctionName(baseConstructor);\n    var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);\n    var metadata = targets.map(function (t) {\n      return t.metadata.filter(function (m) {\n        return m.key === METADATA_KEY.UNMANAGED_TAG;\n      });\n    });\n    var unmanagedCount = [].concat.apply([], metadata).length;\n    var dependencyCount = targets.length - unmanagedCount;\n\n    if (dependencyCount > 0) {\n      return dependencyCount;\n    } else {\n      return getBaseClassDependencyCount(metadataReader, baseConstructor);\n    }\n  } else {\n    return 0;\n  }\n}\n\nexports.getBaseClassDependencyCount = getBaseClassDependencyCount;\n\nfunction formatTargetMetadata(targetMetadata) {\n  var targetMetadataMap = {};\n  targetMetadata.forEach(function (m) {\n    targetMetadataMap[m.key.toString()] = m.value;\n  });\n  return {\n    inject: targetMetadataMap[METADATA_KEY.INJECT_TAG],\n    multiInject: targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG],\n    targetName: targetMetadataMap[METADATA_KEY.NAME_TAG],\n    unmanaged: targetMetadataMap[METADATA_KEY.UNMANAGED_TAG]\n  };\n}","map":null,"metadata":{},"sourceType":"script"}