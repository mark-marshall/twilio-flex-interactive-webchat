{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compare = void 0;\n\nvar util_1 = require(\"./util\");\n/**\nEvaluate `left === right`, treating `left` and `right` as ordered lists.\n\n@returns true iff `left` and `right` have identical lengths, and every element\n         of `left` is equal to the corresponding element of `right`. Equality is\n         determined recursivly, via `compare`.\n*/\n\n\nfunction compareArrays(left, right) {\n  var length = left.length;\n\n  if (length !== right.length) {\n    return false;\n  }\n\n  for (var i = 0; i < length; i++) {\n    if (!compare(left[i], right[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\nEvaluate `left === right`, treating `left` and `right` as property maps.\n\n@returns true iff every property in `left` has a value equal to the value of the\n         corresponding property in `right`, and vice-versa, stopping as soon as\n         possible. Equality is determined recursivly, via `compare`.\n*/\n\n\nfunction compareObjects(left, right) {\n  var left_keys = Object.keys(left);\n  var right_keys = Object.keys(right);\n  var length = left_keys.length; // quick exit if the number of keys don't match up\n\n  if (length !== right_keys.length) {\n    return false;\n  } // we don't know for sure that Set(left_keys) is equal to Set(right_keys),\n  // much less that their values in left and right are equal, but if right\n  // contains each key in left, we know it can't have any additional keys\n\n\n  for (var i = 0; i < length; i++) {\n    var key = left_keys[i];\n\n    if (!util_1.hasOwnProperty.call(right, key) || !compare(left[key], right[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n`compare()` returns true if `left` and `right` are materially equal\n(i.e., would produce equivalent JSON), false otherwise.\n\n> Here, \"equal\" means that the value at the target location and the\n> value conveyed by \"value\" are of the same JSON type, and that they\n> are considered equal by the following rules for that type:\n> o  strings: are considered equal if they contain the same number of\n>    Unicode characters and their code points are byte-by-byte equal.\n> o  numbers: are considered equal if their values are numerically\n>    equal.\n> o  arrays: are considered equal if they contain the same number of\n>    values, and if each value can be considered equal to the value at\n>    the corresponding position in the other array, using this list of\n>    type-specific rules.\n> o  objects: are considered equal if they contain the same number of\n>    members, and if each member can be considered equal to a member in\n>    the other object, by comparing their keys (as strings) and their\n>    values (using this list of type-specific rules).\n> o  literals (false, true, and null): are considered equal if they are\n>    the same.\n*/\n\n\nfunction compare(left, right) {\n  // strict equality handles literals, numbers, and strings (a sufficient but not necessary cause)\n  if (left === right) {\n    return true;\n  }\n\n  var left_type = util_1.objectType(left);\n  var right_type = util_1.objectType(right); // check arrays\n\n  if (left_type == 'array' && right_type == 'array') {\n    return compareArrays(left, right);\n  } // check objects\n\n\n  if (left_type == 'object' && right_type == 'object') {\n    return compareObjects(left, right);\n  } // mismatched arrays & objects, etc., are always inequal\n\n\n  return false;\n}\n\nexports.compare = compare;","map":null,"metadata":{},"sourceType":"script"}