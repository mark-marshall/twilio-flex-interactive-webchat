{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTests = exports.createPatch = exports.applyPatch = void 0;\n\nvar pointer_1 = require(\"./pointer\");\n\nvar patch_1 = require(\"./patch\");\n\nvar diff_1 = require(\"./diff\");\n/**\nApply a 'application/json-patch+json'-type patch to an object.\n\n`patch` *must* be an array of operations.\n\n> Operation objects MUST have exactly one \"op\" member, whose value\n> indicates the operation to perform.  Its value MUST be one of \"add\",\n> \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are\n> errors.\n\nThis method mutates the target object in-place.\n\n@returns list of results, one for each operation: `null` indicated success,\n         otherwise, the result will be an instance of one of the Error classes:\n         MissingError, InvalidOperationError, or TestError.\n*/\n\n\nfunction applyPatch(object, patch) {\n  return patch.map(function (operation) {\n    return patch_1.apply(object, operation);\n  });\n}\n\nexports.applyPatch = applyPatch;\n\nfunction wrapVoidableDiff(diff) {\n  function wrappedDiff(input, output, ptr) {\n    var custom_patch = diff(input, output, ptr); // ensure an array is always returned\n\n    return Array.isArray(custom_patch) ? custom_patch : diff_1.diffAny(input, output, ptr, wrappedDiff);\n  }\n\n  return wrappedDiff;\n}\n/**\nProduce a 'application/json-patch+json'-type patch to get from one object to\nanother.\n\nThis does not alter `input` or `output` unless they have a property getter with\nside-effects (which is not a good idea anyway).\n\n`diff` is called on each pair of comparable non-primitive nodes in the\n`input`/`output` object trees, producing nested patches. Return `undefined`\nto fall back to default behaviour.\n\nReturns list of operations to perform on `input` to produce `output`.\n*/\n\n\nfunction createPatch(input, output, diff) {\n  var ptr = new pointer_1.Pointer(); // a new Pointer gets a default path of [''] if not specified\n\n  return (diff ? wrapVoidableDiff(diff) : diff_1.diffAny)(input, output, ptr);\n}\n\nexports.createPatch = createPatch;\n/**\nCreate a test operation based on `input`'s current evaluation of the JSON\nPointer `path`; if such a pointer cannot be resolved, returns undefined.\n*/\n\nfunction createTest(input, path) {\n  var endpoint = pointer_1.Pointer.fromJSON(path).evaluate(input);\n\n  if (endpoint !== undefined) {\n    return {\n      op: 'test',\n      path: path,\n      value: endpoint.value\n    };\n  }\n}\n/**\nProduce an 'application/json-patch+json'-type list of tests, to verify that\nexisting values in an object are identical to the those captured at some\ncheckpoint (whenever this function is called).\n\nThis does not alter `input` or `output` unless they have a property getter with\nside-effects (which is not a good idea anyway).\n\nReturns list of test operations.\n*/\n\n\nfunction createTests(input, patch) {\n  var tests = new Array();\n  patch.filter(diff_1.isDestructive).forEach(function (operation) {\n    var pathTest = createTest(input, operation.path);\n    if (pathTest) tests.push(pathTest);\n\n    if ('from' in operation) {\n      var fromTest = createTest(input, operation.from);\n      if (fromTest) tests.push(fromTest);\n    }\n  });\n  return tests;\n}\n\nexports.createTests = createTests;","map":null,"metadata":{},"sourceType":"script"}