"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const index_1 = require("./util/index");
const logger_1 = require("./logger");
const media_1 = require("./media");
const log = logger_1.Logger.scope('Message');
function parseAttributes(msgSid, attributes) {
    try {
        return attributes ? JSON.parse(attributes) : {};
    }
    catch (e) {
        log.warn('Got malformed attributes for the message', msgSid);
        return {};
    }
}
/**
 * @classdesc A Message represents a Message in a Channel.
 * @property {String} author - The name of the user that sent Message
 * @property {String} body - The body of the Message. Is null if Message is Media Message
 * @property {Object} attributes - Message custom attributes
 * @property {Channel} channel - Channel Message belongs to
 * @property {Date} dateUpdated - When Message was updated
 * @property {Number} index - Index of Message in the Channel's messages list
 * @property {String} lastUpdatedBy - Identity of the last user that updated Message
 * @property {Media} media - Contains Media information (if present)
 * @property {String} memberSid - Authoring Member's server-assigned unique identifier
 * @property {String} sid - The server-assigned unique identifier for Message
 * @property {Date} timestamp - When Message was created
 * @property {'text' | 'media' } type - Type of message: 'text' or 'media'
 * @fires Message#updated
 */
class Message extends events_1.EventEmitter {
    /**
     * The update reason for <code>updated</code> event emitted on Message
     * @typedef {('body' | 'lastUpdatedBy' | 'dateUpdated' | 'timestamp' | 'attributes' | 'author')} Message#UpdateReason
     */
    constructor(channel, services, index, data) {
        super();
        this.channel = channel;
        this.services = services;
        this.state = {
            sid: data.sid,
            index: index,
            author: data.author == null ? null : data.author,
            body: data.text,
            timestamp: data.timestamp ? new Date(data.timestamp) : null,
            dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,
            lastUpdatedBy: data.lastUpdatedBy ? data.lastUpdatedBy : null,
            attributes: parseAttributes(data.sid, data.attributes),
            type: data.type ? data.type : 'text',
            media: (data.type && data.type === 'media' && data.media)
                ? new media_1.Media(data.media, this.services) : null,
            memberSid: data.memberSid == null ? null : data.memberSid
        };
    }
    get sid() { return this.state.sid; }
    get author() { return this.state.author; }
    get body() {
        if (this.type === 'media') {
            return null;
        }
        return this.state.body;
    }
    get dateUpdated() { return this.state.dateUpdated; }
    get index() { return this.state.index; }
    get lastUpdatedBy() { return this.state.lastUpdatedBy; }
    get timestamp() { return this.state.timestamp; }
    get attributes() { return this.state.attributes; }
    get type() { return this.state.type; }
    get media() { return this.state.media; }
    get memberSid() { return this.state.memberSid; }
    _update(data) {
        let updateReasons = [];
        if ((data.text || ((typeof data.text) === 'string')) && data.text !== this.state.body) {
            this.state.body = data.text;
            updateReasons.push('body');
        }
        if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {
            this.state.lastUpdatedBy = data.lastUpdatedBy;
            updateReasons.push('lastUpdatedBy');
        }
        if (data.author && data.author !== this.state.author) {
            this.state.author = data.author;
            updateReasons.push('author');
        }
        if (data.dateUpdated &&
            new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
            this.state.dateUpdated = new Date(data.dateUpdated);
            updateReasons.push('dateUpdated');
        }
        if (data.timestamp &&
            new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {
            this.state.timestamp = new Date(data.timestamp);
            updateReasons.push('timestamp');
        }
        let updatedAttributes = parseAttributes(this.sid, data.attributes);
        if (!index_1.isDeepEqual(this.state.attributes, updatedAttributes)) {
            this.state.attributes = updatedAttributes;
            updateReasons.push('attributes');
        }
        if (updateReasons.length > 0) {
            this.emit('updated', { message: this, updateReasons: updateReasons });
        }
    }
    /**
     * Get Member who is author of the Message
     * @returns {Promise<Member>}
     */
    async getMember() {
        let member = null;
        if (this.state.memberSid) {
            member = await this.channel.getMemberBySid(this.memberSid)
                .catch(() => {
                log.debug('Member with sid "' + this.memberSid + '" not found for message ' + this.sid);
                return null;
            });
        }
        if (!member && this.state.author) {
            member = await this.channel.getMemberByIdentity(this.state.author)
                .catch(() => {
                log.debug('Member with identity "' + this.author + '" not found for message ' + this.sid);
                return null;
            });
        }
        if (member) {
            return member;
        }
        let errorMesage = 'Member with ';
        if (this.state.memberSid) {
            errorMesage += 'SID \'' + this.state.memberSid + '\' ';
        }
        if (this.state.author) {
            if (this.state.memberSid) {
                errorMesage += 'or ';
            }
            errorMesage += 'identity \'' + this.state.author + '\' ';
        }
        if (errorMesage === 'Member with ') {
            errorMesage = 'Member ';
        }
        errorMesage += 'was not found';
        throw new Error(errorMesage);
    }
    /**
     * Remove the Message.
     * @returns {Promise<Message|SessionError>}
     */
    async remove() {
        await this.services.session.addCommand('deleteMessage', {
            channelSid: this.channel.sid,
            messageIdx: this.index.toString()
        });
        return this;
    }
    /**
     * Edit message body.
     * @param {String} body - new body of Message.
     * @returns {Promise<Message|Error|SessionError>}
     */
    async updateBody(body) {
        if (typeof body !== 'string') {
            throw new Error('Body <String> is a required parameter for updateBody');
        }
        await this.services.session.addCommand('editMessage', {
            channelSid: this.channel.sid,
            messageIdx: this.index.toString(),
            text: body
        });
        return this;
    }
    /**
     * Edit message attributes.
     * @param {Object} attributes new attributes for Message.
     * @returns {Promise<Message|Error|SessionError>}
     */
    async updateAttributes(attributes) {
        if (typeof attributes === 'undefined') {
            throw new Error('Attributes is required parameter');
        }
        else if (attributes === null) {
            throw new Error('Attributes can\'t be null');
        }
        else if (attributes.constructor !== Object) {
            throw new Error('Attributes must be a valid JSON object');
        }
        await this.services.session.addCommand('editMessageAttributes', {
            channelSid: this.channel.sid,
            messageIdx: this.index,
            attributes: JSON.stringify(attributes)
        });
        return this;
    }
}
exports.Message = Message;
/**
 * Fired when the Message's properties or body has been updated.
 * @event Message#updated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
