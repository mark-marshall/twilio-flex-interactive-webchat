"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../logger");
const notificationtypes_1 = require("../interfaces/notificationtypes");
const log = logger_1.Logger.scope('TypingIndicator');
/**
 * An important note in regards to typing timeout timers. There are two places that the SDK can get the "typing_timeout" attribute from. The first
 * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the
 * "typing_timeout" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a
 * notification of type "twilio.ipmsg.typing_indicator". In this case, the "typing_timeout" value will be +1 of that in the console. This
 * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,
 * the timeout returned from the notification should be used as the timeout for the "typingEnded" event, +1 is to account for latency.
 *
 * @private
 */
/**
 * @class TypingIndicator
 *
 * @constructor
 * @private
 */
class TypingIndicator {
    constructor(config, services, getChannel) {
        this.config = config;
        this.services = services;
        this.getChannel = getChannel;
        this.serviceTypingTimeout = null;
        this.sentUpdates = new Map();
    }
    get typingTimeout() {
        return this.config.typingIndicatorTimeoutOverride
            || this.serviceTypingTimeout
            || this.config.typingIndicatorTimeoutDefault;
    }
    /**
     * Initialize TypingIndicator controller
     * Registers for needed message types and sets listeners
     * @private
     */
    initialize() {
        this.services.notificationClient.subscribe(notificationtypes_1.NotificationTypes.TYPING_INDICATOR, 'twilsock');
        this.services.notificationClient.on('message', (type, message) => {
            if (type === notificationtypes_1.NotificationTypes.TYPING_INDICATOR) {
                this.handleRemoteTyping(message);
            }
        });
    }
    /**
     * Remote members typing events handler
     * @private
     */
    handleRemoteTyping(message) {
        log.trace('Got new typing indicator ', message);
        this.getChannel(message.channel_sid)
            .then(channel => {
            if (!channel) {
                return;
            }
            channel.members.forEach(member => {
                if (member.identity !== message.identity) {
                    return;
                }
                const timeout = this.config.typingIndicatorTimeoutOverride + 1000 || message.typing_timeout * 1000;
                member._startTyping(timeout);
            });
        })
            .catch(err => {
            log.error(err);
            throw err;
        });
    }
    /**
     * Send typing event for the given channel sid
     * @param {String} channelSid
     */
    send(channelSid) {
        const lastUpdate = this.sentUpdates.get(channelSid);
        if (lastUpdate && lastUpdate > (Date.now() - this.typingTimeout)) {
            return Promise.resolve();
        }
        this.sentUpdates.set(channelSid, Date.now());
        return this._send(channelSid);
    }
    _send(channelSid) {
        log.trace('Sending typing indicator');
        const url = this.config.typingIndicatorUri;
        const headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        };
        const body = 'ChannelSid=' + channelSid;
        return this.services.transport.post(url, headers, body)
            .then(response => {
            if (response.body.hasOwnProperty('typing_timeout')) {
                this.serviceTypingTimeout = response.body.typing_timeout * 1000;
            }
        }).catch(err => {
            log.error('Failed to send typing indicator:', err);
            throw err;
        });
    }
}
exports.TypingIndicator = TypingIndicator;
