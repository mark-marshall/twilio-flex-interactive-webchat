"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sessionerror_1 = require("../sessionerror");
class ConsumptionReportRequest {
}
class ConsumptionReportEntry {
}
class ConsumptionHorizonPromise {
}
/**
 * @classdesc Provides consumption horizon management functionality
 */
class ConsumptionHorizon {
    constructor(services) {
        this.services = services;
        this.consumptionHorizonRequests = new Map();
        this.consumptionHorizonUpdateTimer = null;
    }
    getReportInterval() {
        return this.services.session.getConsumptionReportInterval().then(seconds => seconds * 1000);
    }
    delayedSendConsumptionHorizon(delay) {
        if (this.consumptionHorizonUpdateTimer !== null) {
            return;
        }
        this.sendConsumptionReport(true);
        this.consumptionHorizonUpdateTimer = setTimeout(() => {
            this.sendConsumptionReport(false);
        }, delay);
    }
    sendConsumptionReport(keepTimer) {
        let reports = [];
        let promises = new Map();
        this.consumptionHorizonRequests.forEach((request, channelSid) => {
            reports.push(request.entry);
            promises.set(channelSid, request.promises);
        });
        if (reports.length > 0) {
            this.services.session.addCommand('consumptionReportV2', { report: reports })
                .then(response => this.processConsumptionReportResponse(response, promises))
                .catch(err => this.processConsumptionReportError(err, promises));
        }
        if (!keepTimer) {
            this.consumptionHorizonUpdateTimer = null;
        }
        this.consumptionHorizonRequests.clear();
    }
    processConsumptionReportResponse(response, promises) {
        if (response && response.report && Array.isArray(response.report) && response.report.length > 0) {
            response.report.forEach(entry => {
                let responseEntry = entry;
                if (promises.has(responseEntry.channelSid)) {
                    let unreadMessagesCount = null;
                    if ((typeof responseEntry.unreadMessagesCount !== 'undefined') && responseEntry.unreadMessagesCount != null) {
                        unreadMessagesCount = responseEntry.unreadMessagesCount;
                    }
                    promises.get(responseEntry.channelSid).forEach(promise => promise.resolve(unreadMessagesCount));
                    promises.delete(responseEntry.channelSid);
                }
            });
        }
        this.processConsumptionReportError(new sessionerror_1.SessionError('Error while setting LastConsumedMessageIndex', null), promises);
    }
    processConsumptionReportError(err, promises) {
        promises.forEach(channelPromises => channelPromises.forEach(promise => promise.reject(err)));
    }
    /**
     * Updates consumption horizon value without any checks
     */
    updateLastConsumedMessageIndexForChannel(channelSid, messageIdx) {
        return new Promise((resolve, reject) => {
            this.addPendingConsumptionHorizonRequest(channelSid, { channelSid, messageIdx }, { resolve, reject });
            this.getReportInterval().then(delay => this.delayedSendConsumptionHorizon(delay));
        });
    }
    /**
     * Move consumption horizon forward
     */
    advanceLastConsumedMessageIndexForChannel(channelSid, messageIdx, currentChannelLastConsumedIndex) {
        let currentHorizon = this.consumptionHorizonRequests.get(channelSid);
        return new Promise((resolve, reject) => {
            if (currentHorizon && currentHorizon.entry) {
                if (currentHorizon.entry.messageIdx >= messageIdx) {
                    this.addPendingConsumptionHorizonRequest(channelSid, currentHorizon.entry, { resolve, reject });
                }
                else {
                    this.addPendingConsumptionHorizonRequest(channelSid, { channelSid, messageIdx }, { resolve, reject });
                }
            }
            else {
                if ((currentChannelLastConsumedIndex !== null) && messageIdx < currentChannelLastConsumedIndex) {
                    this.addPendingConsumptionHorizonRequest(channelSid, { channelSid, messageIdx: currentChannelLastConsumedIndex }, { resolve, reject });
                }
                else {
                    this.addPendingConsumptionHorizonRequest(channelSid, { channelSid, messageIdx }, { resolve, reject });
                }
            }
            this.getReportInterval().then(delay => this.delayedSendConsumptionHorizon(delay));
        });
    }
    addPendingConsumptionHorizonRequest(channelSid, entry, promise) {
        if (this.consumptionHorizonRequests.has(channelSid)) {
            let request = this.consumptionHorizonRequests.get(channelSid);
            request.entry = entry;
            request.promises.push(promise);
        }
        else {
            this.consumptionHorizonRequests.set(channelSid, { entry, promises: [promise] });
        }
    }
}
exports.ConsumptionHorizon = ConsumptionHorizon;
