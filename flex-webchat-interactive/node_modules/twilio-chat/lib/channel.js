"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const logger_1 = require("./logger");
const members_1 = require("./data/members");
const member_1 = require("./member");
const messages_1 = require("./data/messages");
const util_1 = require("./util");
const log = logger_1.Logger.scope('Channel');
const fieldMappings = {
    lastMessage: 'lastMessage',
    attributes: 'attributes',
    createdBy: 'createdBy',
    dateCreated: 'dateCreated',
    dateUpdated: 'dateUpdated',
    friendlyName: 'friendlyName',
    lastConsumedMessageIndex: 'lastConsumedMessageIndex',
    notificationLevel: 'notificationLevel',
    sid: 'sid',
    status: 'status',
    type: 'type',
    uniqueName: 'uniqueName',
    state: 'state'
};
function parseTime(timeString) {
    try {
        return new Date(timeString);
    }
    catch (e) {
        return null;
    }
}
function filterStatus(status) {
    switch (status) {
        case 'notParticipating':
            return 'known';
        default:
            return status;
    }
}
exports.filterStatus = filterStatus;
/**
 * @classdesc A Channel represents a remote channel of communication between multiple Programmable Chat Clients
 * @property {Object} attributes - The Channel's custom attributes
 * @property {String} createdBy - The identity of the User that created this Channel
 * @property {Date} dateCreated - The Date this Channel was created
 * @property {Date} dateUpdated - The Date this Channel was last updated
 * @property {String} friendlyName - The Channel's name
 * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)
 * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in this Channel
 * @property {Channel#LastMessage} lastMessage - Last Message sent to this Channel
 * @property {Channel#NotificationLevel} notificationLevel - User Notification level for this Channel
 * @property {String} sid - The Channel's unique system identifier
 * @property {Channel#State} state - The Channel's state
 * @property {Channel#Status} status - The Channel's status
 * @property {Channel#Type} type - The Channel's type
 * @property {String} uniqueName - The Channel's unique name (tag)
 * @fires Channel#memberJoined
 * @fires Channel#memberLeft
 * @fires Channel#memberUpdated
 * @fires Channel#messageAdded
 * @fires Channel#messageRemoved
 * @fires Channel#messageUpdated
 * @fires Channel#typingEnded
 * @fires Channel#typingStarted
 * @fires Channel#updated
 * @fires Channel#removed
 */
class Channel extends events_1.EventEmitter {
    /**
     * These options can be passed to {@link Channel#sendMessage}.
     * @typedef {Object} Channel#SendMediaOptions
     * @property {String} contentType - content type of media
     * @property {String | Buffer} media - content to post
     */
    /**
     * The update reason for <code>updated</code> event emitted on Channel
     * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |
      'friendlyName' | 'lastConsumedMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' |
      'notificationLevel' )} Channel#UpdateReason
     */
    /**
     * The status of the Channel, relative to the Client: whether the Channel
     * is <code>known</code> to local Client, Client is <code>invited</code> to or
     * is <code>joined</code> to this Channel
     * @typedef {('unknown' | 'known' | 'invited' | 'joined')} Channel#Status
     */
    /**
     * The type of Channel (<code>public</code> or <code>private</code>).
     * @typedef {('public' | 'private')} Channel#Type
     */
    /**
     * The User's Notification level for Channel, determines whether the currently logged-in User will receive
     * pushes for events in this Channel. Can be either <code>muted</code> or <code>default</code>,
     * where <code>default</code> defers to global Service push configuration.
     * @typedef {('default' | 'muted')} Channel#NotificationLevel
     */
    /**
     * The Channel's state. Set to undefined if the channel is not a conversation.
     * @typedef {Object | undefined} Channel#State
     * @property {('active' | 'inactive' | 'closed')} current - the current state
     * @property {Date} dateUpdated - date at which the latest channel state update happened
     */
    constructor(services, descriptor, sid) {
        super();
        let attributes = descriptor.attributes || {};
        let createdBy = descriptor.createdBy;
        let dateCreated = parseTime(descriptor.dateCreated);
        let dateUpdated = parseTime(descriptor.dateUpdated);
        let friendlyName = descriptor.friendlyName || null;
        let lastConsumedMessageIndex = Number.isInteger(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;
        let uniqueName = descriptor.uniqueName || null;
        try {
            JSON.stringify(attributes);
        }
        catch (e) {
            throw new Error('Attributes must be a valid JSON object.');
        }
        this.services = services;
        this.sid = sid;
        this.entityName = descriptor.channel;
        this.channelState = {
            uniqueName,
            status: 'known',
            type: descriptor.type,
            attributes,
            createdBy,
            dateCreated,
            dateUpdated,
            friendlyName,
            lastConsumedMessageIndex
        };
        if (descriptor.notificationLevel) {
            this.channelState.notificationLevel = descriptor.notificationLevel;
        }
        this.members = new Map();
        this.membersEntity = new members_1.Members(this, this.services, this.members);
        this.membersEntity.on('memberJoined', this.emit.bind(this, 'memberJoined'));
        this.membersEntity.on('memberLeft', this.emit.bind(this, 'memberLeft'));
        this.membersEntity.on('memberUpdated', (args) => this.emit('memberUpdated', args));
        this.messagesEntity = new messages_1.Messages(this, services);
        this.messagesEntity.on('messageAdded', message => this._onMessageAdded(message));
        this.messagesEntity.on('messageUpdated', (args) => this.emit('messageUpdated', args));
        this.messagesEntity.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
    }
    get status() { return this.channelState.status; }
    get type() { return this.channelState.type; }
    get uniqueName() { return this.channelState.uniqueName; }
    get isPrivate() { return this.channelState.type === 'private'; }
    get friendlyName() { return this.channelState.friendlyName; }
    get dateUpdated() { return this.channelState.dateUpdated; }
    get dateCreated() { return this.channelState.dateCreated; }
    get createdBy() { return this.channelState.createdBy; }
    get attributes() { return this.channelState.attributes; }
    get lastConsumedMessageIndex() { return this.channelState.lastConsumedMessageIndex; }
    get lastMessage() { return this.channelState.lastMessage; }
    get notificationLevel() { return this.channelState.notificationLevel; }
    get state() { return this.channelState.state; }
    /**
     * The Channel's last message's information.
     * @typedef {Object} Channel#LastMessage
     * @property {Number} index - Message's index
     * @property {Date} timestamp - Message's creation timestamp
     */
    /**
     * Load and Subscribe to this Channel and do not subscribe to its Members and Messages.
     * This or _subscribeStreams will need to be called before any events on Channel will fire.
     * @returns {Promise}
     * @private
     */
    _subscribe() {
        if (this.entityPromise) {
            return this.entityPromise;
        }
        return this.entityPromise = this.entityPromise ||
            this.services.syncClient.document({ id: this.entityName, mode: 'open_existing' })
                .then(entity => {
                this.entity = entity;
                this.entity.on('updated', args => { this._update(args.value); });
                this.entity.on('removed', () => this.emit('removed', this));
                this._update(this.entity.value);
                return entity;
            })
                .catch(err => {
                this.entity = null;
                this.entityPromise = null;
                if (this.services.syncClient.connectionState != 'disconnected') {
                    log.error('Failed to get channel object', err);
                }
                log.debug('ERROR: Failed to get channel object', err);
                throw err;
            });
    }
    /**
     * Load the attributes of this Channel and instantiate its Members and Messages.
     * This or _subscribe will need to be called before any events on Channel will fire.
     * This will need to be called before any events on Members or Messages will fire
     * @returns {Promise}
     * @private
     */
    async _subscribeStreams() {
        try {
            await this._subscribe();
            log.trace('_subscribeStreams, this.entity.value=', this.entity.value);
            const messagesObjectName = this.entity.value.messages;
            const rosterObjectName = this.entity.value.roster;
            await Promise.all([
                this.messagesEntity.subscribe(messagesObjectName),
                this.membersEntity.subscribe(rosterObjectName)
            ]);
        }
        catch (err) {
            if (this.services.syncClient.connectionState !== 'disconnected') {
                log.error('Failed to subscribe on channel objects', this.sid, err);
            }
            log.debug('ERROR: Failed to subscribe on channel objects', this.sid, err);
            throw err;
        }
    }
    /**
     * Stop listening for and firing events on this Channel.
     * @returns {Promise}
     * @private
     */
    async _unsubscribe() {
        // Keep our subscription to public channels objects
        if (this.isPrivate && this.entity) {
            await this.entity.close();
            this.entity = null;
            this.entityPromise = null;
        }
        return Promise.all([
            this.membersEntity.unsubscribe(),
            this.messagesEntity.unsubscribe()
        ]);
    }
    /**
     * Set channel status
     * @private
     */
    _setStatus(status, source) {
        this.statusSource = source;
        if (this.channelState.status === status) {
            return;
        }
        this.channelState.status = status;
        if (status === 'joined') {
            this._subscribeStreams()
                .catch(err => {
                log.debug('ERROR while setting channel status ' + status, err);
                if (this.services.syncClient.connectionState !== 'disconnected') {
                    throw err;
                }
            });
        }
        else if (status === 'invited') {
            this._subscribe()
                .catch(err => {
                log.debug('ERROR while setting channel status ' + status, err);
                if (this.services.syncClient.connectionState !== 'disconnected') {
                    throw err;
                }
            });
        }
        else if (this.entityPromise) {
            this._unsubscribe().catch(err => {
                log.debug('ERROR while setting channel status ' + status, err);
                if (this.services.syncClient.connectionState !== 'disconnected') {
                    throw err;
                }
            });
        }
    }
    /**
     * If channel's status update source
     * @private
     * @return {Channels.DataSource}
     */
    _statusSource() {
        return this.statusSource;
    }
    static preprocessUpdate(update, channelSid) {
        try {
            if (typeof update.attributes === 'string') {
                update.attributes = JSON.parse(update.attributes);
            }
            else if (update.attributes) {
                JSON.stringify(update.attributes);
            }
        }
        catch (e) {
            log.warn('Retrieved malformed attributes from the server for channel: ' + channelSid);
            update.attributes = {};
        }
        try {
            if (update.dateCreated) {
                update.dateCreated = new Date(update.dateCreated);
            }
        }
        catch (e) {
            log.warn('Retrieved malformed dateCreated from the server for channel: ' + channelSid);
            delete update.dateCreated;
        }
        try {
            if (update.dateUpdated) {
                update.dateUpdated = new Date(update.dateUpdated);
            }
        }
        catch (e) {
            log.warn('Retrieved malformed dateUpdated from the server for channel: ' + channelSid);
            delete update.dateUpdated;
        }
        try {
            if (update.lastMessage && update.lastMessage.timestamp) {
                update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);
            }
        }
        catch (e) {
            log.warn('Retrieved malformed lastMessage.timestamp from the server for channel: ' + channelSid);
            delete update.lastMessage.timestamp;
        }
    }
    /**
     * Updates local channel object with new values
     * @private
     */
    _update(update) {
        var _a, _b, _c, _d, _e;
        log.trace('_update', update);
        Channel.preprocessUpdate(update, this.sid);
        const updateReasons = new Set();
        for (const key of Object.keys(update)) {
            const localKey = fieldMappings[key];
            if (!localKey) {
                continue;
            }
            switch (localKey) {
                case fieldMappings.status:
                    if (!update.status || update.status === 'unknown'
                        || this.channelState.status === filterStatus(update.status)) {
                        break;
                    }
                    this.channelState.status = filterStatus(update.status);
                    updateReasons.add(localKey);
                    break;
                case fieldMappings.attributes:
                    if (util_1.isDeepEqual(this.channelState.attributes, update.attributes)) {
                        break;
                    }
                    this.channelState.attributes = update.attributes;
                    updateReasons.add(localKey);
                    break;
                case fieldMappings.lastConsumedMessageIndex:
                    if (update.lastConsumedMessageIndex === undefined
                        || update.lastConsumedMessageIndex === this.channelState.lastConsumedMessageIndex) {
                        break;
                    }
                    this.channelState.lastConsumedMessageIndex = update.lastConsumedMessageIndex;
                    updateReasons.add(localKey);
                    break;
                case fieldMappings.lastMessage:
                    if (this.channelState.lastMessage && !update.lastMessage) {
                        delete this.channelState.lastMessage;
                        updateReasons.add(localKey);
                        break;
                    }
                    this.channelState.lastMessage = this.channelState.lastMessage || {};
                    if (((_a = update.lastMessage) === null || _a === void 0 ? void 0 : _a.index) !== undefined
                        && update.lastMessage.index !== this.channelState.lastMessage.index) {
                        this.channelState.lastMessage.index = update.lastMessage.index;
                        updateReasons.add(localKey);
                    }
                    if (((_b = update.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp) !== undefined
                        && ((_d = (_c = this.channelState.lastMessage) === null || _c === void 0 ? void 0 : _c.timestamp) === null || _d === void 0 ? void 0 : _d.getTime()) !== update.lastMessage.timestamp.getTime()) {
                        this.channelState.lastMessage.timestamp = update.lastMessage.timestamp;
                        updateReasons.add(localKey);
                    }
                    if (util_1.isDeepEqual(this.channelState.lastMessage, {})) {
                        delete this.channelState.lastMessage;
                    }
                    break;
                case fieldMappings.state:
                    const state = update.state || undefined;
                    if (state !== undefined) {
                        state.dateUpdated = new Date(state.dateUpdated);
                    }
                    if (util_1.isDeepEqual(this.channelState.state, state)) {
                        break;
                    }
                    this.channelState.state = state;
                    updateReasons.add(localKey);
                    break;
                default:
                    const isDate = update[key] instanceof Date;
                    const keysMatchAsDates = isDate && ((_e = this.channelState[localKey]) === null || _e === void 0 ? void 0 : _e.getTime()) === update[key].getTime();
                    const keysMatchAsNonDates = !isDate && this[localKey] === update[key];
                    if (keysMatchAsDates || keysMatchAsNonDates) {
                        break;
                    }
                    this.channelState[localKey] = update[key];
                    updateReasons.add(localKey);
            }
        }
        if (updateReasons.size > 0) {
            this.emit('updated', { channel: this, updateReasons: [...updateReasons] });
        }
    }
    /**
     * @private
     */
    _onMessageAdded(message) {
        for (let member of this.members.values()) {
            if (member.identity === message.author) {
                member._endTyping();
                break;
            }
        }
        this.emit('messageAdded', message);
    }
    /**
     * Add a participant to the Channel by its Identity.
     * @param {String} identity - Identity of the Client to add
     * @returns {Promise<void|Error|SessionError>}
     */
    async add(identity) {
        if (!identity || typeof identity !== 'string') {
            throw new Error('Channel.add requires an <String>identity parameter');
        }
        return this.membersEntity.add(identity);
    }
    /**
     * Advance last consumed Channel's Message index to current consumption horizon.
     * Rejects if User is not Member of Channel.
     * Last consumed Message index is updated only if new index value is higher than previous.
     * @param {Number} index - Message index to advance to as last read
     * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
     */
    async advanceLastConsumedMessageIndex(index) {
        if (!Number.isInteger(index)) {
            throw new Error('Channel.advanceLastConsumedMessageIndex requires an integral <Number>index parameter');
        }
        await this._subscribeStreams();
        return this.services.consumptionHorizon.advanceLastConsumedMessageIndexForChannel(this.sid, index, this.lastConsumedMessageIndex);
    }
    /**
     * Decline an invitation to the Channel and unsubscribe from its events.
     * @returns {Promise<Channel|SessionError>}
     */
    async decline() {
        await this.services.session.addCommand('declineInvitation', {
            channelSid: this.sid
        });
        return this;
    }
    /**
     * Delete the Channel and unsubscribe from its events.
     * @returns {Promise<Channel|SessionError>}
     */
    async delete() {
        await this.services.session.addCommand('destroyChannel', {
            channelSid: this.sid
        });
        return this;
    }
    /**
     * Get the custom attributes of this Channel.<br/>
     *
     * <i>NOTE: {@link Channel}'s <code>attributes</code> property will be empty for public channels until this function is called.</i>
     * @returns {Promise<Object>}
     */
    async getAttributes() {
        await this._subscribe();
        return this.attributes;
    }
    /**
     * Returns messages from channel using paginator interface.
     * @param {Number} [pageSize=30] Number of messages to return in single chunk
     * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default
     * @param {String} [direction=backwards] - Query direction. By default it query backwards
     *                                         from newer to older. 'forward' will query in opposite direction
     * @returns {Promise<Paginator<Message>>} page of messages
     */
    async getMessages(pageSize, anchor, direction) {
        if (typeof anchor !== 'undefined' && !Number.isInteger(anchor)) {
            throw new Error('Anchor should be a valid message index');
        }
        await this._subscribeStreams();
        return this.messagesEntity.getMessages(pageSize, anchor, direction);
    }
    /**
     * Get a list of all Members joined to this Channel.
     * @returns {Promise<Array<Member>>}
     */
    async getMembers() {
        await this._subscribeStreams();
        return this.membersEntity.getMembers();
    }
    /**
     * Get channel members count.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Chat system does not
     * provide real time events for counter values changes.
     * <br/>
     * So this is quite useful for any UI badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number|Error>}
     */
    async getMembersCount() {
        let links = await this.services.session.getSessionLinks();
        let url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();
        let response = await this.services.network.get(url);
        return response.body.members_count;
    }
    /**
     * Get a Member by its SID.
     * @param {String} memberSid - Member sid
     * @returns {Promise<Member>}
     */
    async getMemberBySid(memberSid) {
        if (!memberSid || typeof memberSid !== 'string') {
            throw new Error('Channel.getMemberBySid requires a <String>memberSid parameter');
        }
        return this.membersEntity.getMemberBySid(memberSid);
    }
    /**
     * Get a Member by its identity.
     * @param {String} identity - Member identity
     * @returns {Promise<Member>}
     */
    async getMemberByIdentity(identity) {
        if (!identity || typeof identity !== 'string') {
            throw new Error('Channel.getMemberByIdentity requires a <String>identity parameter');
        }
        return this.membersEntity.getMemberByIdentity(identity);
    }
    /**
     * Get total message count in a channel.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Chat system does not
     * provide real time events for counter values changes.
     * <br/>
     * So this is quite useful for any UI badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number|Error>}
     */
    async getMessagesCount() {
        let links = await this.services.session.getSessionLinks();
        let url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();
        let response = await this.services.network.get(url);
        return response.body.messages_count;
    }
    /**
     * Get unconsumed messages count for User if he is Member of this Channel.
     * Rejects if User is not Member of Channel.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Chat system does not
     * provide real time events for counter values changes.
     * <br/>
     * So this is quite useful for any “unread messages count” badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number|Error>}
     */
    async getUnconsumedMessagesCount() {
        let links = await this.services.session.getSessionLinks();
        let url = new util_1.UriBuilder(links.myChannelsUrl).arg('ChannelSid', this.sid).build();
        let response = await this.services.network.get(url);
        if (response.body.channels.length && response.body.channels[0].channel_sid == this.sid) {
            if ((typeof response.body.channels[0].unread_messages_count !== 'undefined') && response.body.channels[0].unread_messages_count != null) {
                return response.body.channels[0].unread_messages_count;
            }
            return null;
        }
        throw new Error('Channel is not in user channels list');
    }
    /**
     * Invite a user to the Channel by their Identity.
     * @param {String} identity - Identity of the user to invite
     * @returns {Promise<void|Error|SessionError>}
     */
    async invite(identity) {
        if (typeof identity !== 'string' || !identity.length) {
            throw new Error('Channel.invite requires an <String>identity parameter');
        }
        await this.membersEntity.invite(identity);
    }
    /**
     * Join the Channel and subscribe to its events.
     * @returns {Promise<Channel|SessionError>}
     */
    async join() {
        await this.services.session.addCommand('joinChannelV2', { channelSid: this.sid });
        return this;
    }
    /**
     * Leave the Channel.
     * @returns {Promise<Channel|SessionError>}
     */
    async leave() {
        if (this.channelState.status === 'joined') {
            await this.services.session.addCommand('leaveChannel', { channelSid: this.sid });
        }
        return this;
    }
    /**
     * Remove a Member from the Channel.
     * @param {String} member - identity of member to remove
     * @returns {Promise<void|Error|SessionError>}
     */
    async removeMember(member) {
        if (!member || (typeof member !== 'string' && !(member instanceof member_1.Member))) {
            throw new Error('Channel.removeMember requires a <String|Member>member parameter.');
        }
        if (member instanceof member_1.Member) {
            await this.membersEntity.removeBySid(member.sid);
        }
        else {
            await this.membersEntity.removeByIdentity(member);
        }
    }
    /**
     * Send a Message in the Channel.
     * @param {String | FormData | Channel#SendMediaOptions} message - The message body for text message,
     * FormData or MediaOptions for media content. Sending FormData supported only with browser engine
     * @param {Object} messageAttributes - attributes for the message
     * @returns {Promise<number|Error|SessionError>} new Message's index in the Channel's messages list
     */
    async sendMessage(message, messageAttributes) {
        if (typeof message === 'undefined') {
            throw new Error('Message is required parameter');
        }
        if (typeof message === 'string' || message === null) {
            let response = await this.messagesEntity.send(message, messageAttributes);
            return util_1.parseToNumber(response.messageId);
        }
        else {
            let response = await this.messagesEntity.sendMedia(message, messageAttributes);
            return util_1.parseToNumber(response.messageId);
        }
    }
    /**
     * Set last consumed Channel's Message index to last known Message's index in this Channel.
     * @returns {Promise<number|SessionError>} resulting unread messages count in the channel
     */
    async setAllMessagesConsumed() {
        await this._subscribeStreams();
        let messagesPage = await this.getMessages(1);
        if (messagesPage.items.length > 0) {
            return this.advanceLastConsumedMessageIndex(messagesPage.items[0].index);
        }
        return Promise.resolve(0);
    }
    /**
     * Set all messages in the channel unread.
     * @returns {Promise<number|SessionError>} resulting unread messages count in the channel
     */
    async setNoMessagesConsumed() {
        await this._subscribeStreams();
        return this.services.consumptionHorizon.updateLastConsumedMessageIndexForChannel(this.sid, null);
    }
    /**
     * Set User Notification level for this channel.
     * @param {Channel#NotificationLevel} notificationLevel - The new user notification level
     * @returns {Promise<void|Error|SessionError>}
     */
    async setUserNotificationLevel(notificationLevel) {
        if (!notificationLevel) {
            throw new Error('notificationLevel can\'t be null');
        }
        await this.services.session.addCommand('editNotificationLevel', { channelSid: this.sid, notificationLevel: notificationLevel });
    }
    /**
     * Send a notification to the server indicating that this Client is currently typing in this Channel.
     * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.
     * @returns {Promise<void|SessionError>}
     */
    typing() {
        return this.services.typingIndicator.send(this.sid);
    }
    /**
     * Update the Channel's attributes.
     * @param {Object} attributes - The new attributes object
     * @returns {Promise<Channel|Error|SessionError>}
     */
    async updateAttributes(attributes) {
        if (typeof attributes === 'undefined') {
            throw new Error('Attributes is required parameter');
        }
        else if (attributes === null) {
            throw new Error('Attributes can\'t be null');
        }
        else if (attributes.constructor !== Object) {
            throw new Error('Attributes must be a valid JSON object.');
        }
        await this.services.session.addCommand('editAttributes', {
            channelSid: this.sid,
            attributes: JSON.stringify(attributes)
        });
        return this;
    }
    /**
     * Update the Channel's friendlyName.
     * @param {String} name - The new Channel friendlyName
     * @returns {Promise<Channel|SessionError>}
     */
    async updateFriendlyName(name) {
        if (this.channelState.friendlyName !== name) {
            await this.services.session.addCommand('editFriendlyName', {
                channelSid: this.sid,
                friendlyName: name
            });
        }
        return this;
    }
    /**
     * Set last consumed Channel's Message index to current consumption horizon.
     * @param {Number|null} index - Message index to set as last read.
     * If null provided, then the behavior is identical to {@link Channel#setNoMessagesConsumed}
     * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
     */
    async updateLastConsumedMessageIndex(index) {
        if (!(Number.isInteger(index) || index === null)) {
            throw new Error('Incorrect argument "index": integer number or null expected');
        }
        await this._subscribeStreams();
        return this.services.consumptionHorizon.updateLastConsumedMessageIndexForChannel(this.sid, index);
    }
    /**
     * Update the Channel's unique name.
     * @param {String} uniqueName - The new Channel uniqueName
     * @returns {Promise<Channel|SessionError>}
     */
    async updateUniqueName(uniqueName) {
        if (this.channelState.uniqueName !== uniqueName) {
            if (!uniqueName) {
                uniqueName = '';
            }
            await this.services.session.addCommand('editUniqueName', {
                channelSid: this.sid,
                uniqueName: uniqueName
            });
        }
        return this;
    }
    /**
     * Gets User Descriptors for this channel.
     * @returns {Promise<Paginator<UserDescriptor>>}
     */
    async getUserDescriptors() {
        return this.services.users.getChannelUserDescriptors(this.sid);
    }
}
exports.Channel = Channel;
/**
 * Fired when a Member has joined the Channel.
 * @event Channel#memberJoined
 * @type {Member}
 */
/**
 * Fired when a Member has left the Channel.
 * @event Channel#memberLeft
 * @type {Member}
 */
/**
 * Fired when a Member's fields has been updated.
 * @event Channel#memberUpdated
 * @type {Object}
 * @property {Member} member - Updated Member
 * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Channel.
 * @event Channel#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Channel's message list.
 * @event Channel#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Channel#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when a Member has stopped typing.
 * @event Channel#typingEnded
 * @type {Member}
 */
/**
 * Fired when a Member has started typing.
 * @event Channel#typingStarted
 * @type {Member}
 */
/**
 * Fired when a Channel's attributes or metadata have been updated.
 * During Channel's {@link Client.create | creation and initialization} this event might be fired multiple times
 * for same joined or created Channel as new data is arriving from different sources.
 * @event Channel#updated
 * @type {Object}
 * @property {Channel} channel - Updated Channel
 * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons
 */
/**
 * Fired when the Channel was destroyed or currently logged in User has left private Channel
 * @event Channel#removed
 * @type {Channel}
 */
