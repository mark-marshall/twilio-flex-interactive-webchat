"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid");
const platform = require("platform");
const responsecodes_1 = require("./interfaces/responsecodes");
const logger_1 = require("./logger");
const sessionerror_1 = require("./sessionerror");
const deferred_1 = require("./util/deferred");
const iso8601_duration_1 = require("iso8601-duration");
const SDK_VERSION = require('./../package.json').version;
const SESSION_PURPOSE = 'com.twilio.rtd.ipmsg';
const log = logger_1.Logger.scope('Session');
class Command {
}
function hasAllPropertiesSet(obj, properties) {
    return !(properties.some(prop => !obj.hasOwnProperty(prop)));
}
/**
 *  Constructs the instance of Session
 *
 *  @classdesc Provides the interface to send the command to the server
 *  It is reliable, which means that it tracks the command object state
 *  and waits the answer from the server.
 */
class Session {
    constructor(services, config) {
        let platformInfo = typeof navigator !== 'undefined' ?
            platform.parse(navigator.userAgent) : platform;
        this.services = services;
        this.config = config;
        this.sessionInfo = new deferred_1.Deferred();
        this.currentContext = {};
        this.pendingCommands = new Map();
        this.sessionStreamPromise = null;
        this.endpointPlatform = [
            'js',
            SDK_VERSION,
            platformInfo.os,
            platformInfo.name,
            platformInfo.version
        ].join('|');
    }
    get identity() { return this.sessionInfo.current.identity; }
    get reachabilityEnabled() { return this.currentContext.reachabilityEnabled; }
    handleContextUpdate(updatedContext) {
        log.info('Session context updated');
        log.debug('new session context:', updatedContext);
        this.currentContext = updatedContext;
        if (!hasAllPropertiesSet(updatedContext, ['identity', 'userInfo', 'links', 'myChannels', 'channels'])) {
            return; // not enough data to proceed, wait
        }
        log.info('new session context accepted');
        this.sessionInfo.set(updatedContext);
    }
    initialize() {
        let context = {
            type: 'IpMsgSession',
            apiVersion: '3',
            endpointPlatform: this.endpointPlatform
        };
        this.sessionStreamPromise = this.services.syncClient.list({ purpose: SESSION_PURPOSE, context })
            .then(list => {
            log.info('Session created', list.sid);
            list.on('itemAdded', args => this.processCommandResponse(args.item));
            list.on('itemUpdated', args => this.processCommandResponse(args.item));
            list.on('contextUpdated', args => this.handleContextUpdate(args.context));
            return list;
        }).catch(function (err) {
            log.error('Failed to create session', err);
            throw err;
        });
        return this.sessionStreamPromise;
    }
    /**
     * Sends the command to the server
     * @returns Promise the promise, which is being fulfilled only when service will reply
     */
    addCommand(action, params) {
        return this.processCommand(action, params);
    }
    /**
     * @private
     */
    processCommand(action, params, createSessionIfNotFound = true) {
        let command = new Command();
        command.request = params;
        command.request.action = action;
        command.commandId = uuid.v4();
        log.info('Adding command: ', action, command.commandId);
        log.debug('command arguments:', params, createSessionIfNotFound);
        return new Promise((resolve, reject) => {
            this.sessionStreamPromise.then(list => {
                this.pendingCommands.set(command.commandId, { resolve, reject, commandId: command.commandId, request: command.request });
                return list.push(command);
            })
                .then(() => log.debug('Command accepted by server', command.commandId))
                .catch(err => {
                this.pendingCommands.delete(command.commandId);
                log.error('Failed to add a command to the session', err);
                if ((err.code == responsecodes_1.ResponseCodes.ACCESS_FORBIDDEN_FOR_IDENTITY || err.code === responsecodes_1.ResponseCodes.LIST_NOT_FOUND) && createSessionIfNotFound) {
                    log.info('recreating session...');
                    this.initialize();
                    resolve(this.processCommand(action, params, false)); // second attempt
                }
                else {
                    reject(new Error('Can\'t add command: ' + err.message));
                }
            });
        });
    }
    /**
     * @private
     */
    processCommandResponse(entity) {
        if (entity.value.hasOwnProperty('response') &&
            entity.value.hasOwnProperty('commandId') &&
            this.pendingCommands.has(entity.value.commandId)) {
            const value = entity.value;
            const commandId = entity.value.commandId;
            if (value.response.status === responsecodes_1.ResponseCodes.HTTP_200_OK) {
                log.debug('Command succeeded: ', value);
                let resolve = this.pendingCommands.get(commandId).resolve;
                this.pendingCommands.delete(commandId);
                resolve(value.response);
            }
            else {
                log.error('Command failed: ', value);
                let reject = this.pendingCommands.get(commandId).reject;
                this.pendingCommands.delete(commandId);
                reject(new sessionerror_1.SessionError(value.response.statusText, value.response.status));
            }
        }
    }
    getSessionContext() {
        return this.sessionStreamPromise
            .then(stream => stream.getContext());
    }
    async getSessionLinks() {
        let info = await this.sessionInfo.promise;
        return {
            publicChannelsUrl: this.config.baseUrl + info.links.publicChannelsUrl,
            myChannelsUrl: this.config.baseUrl + info.links.myChannelsUrl,
            typingUrl: this.config.baseUrl + info.links.typingUrl,
            syncListUrl: this.config.baseUrl + info.links.syncListUrl,
            usersUrl: this.config.baseUrl + info.links.usersUrl,
            mediaServiceUrl: info.links.mediaServiceUrl
        };
    }
    async getChannelsId() {
        let info = await this.sessionInfo.promise;
        return info.channels;
    }
    async getMyChannelsId() {
        let info = await this.sessionInfo.promise;
        return info.myChannels;
    }
    async getMaxUserInfosToSubscribe() {
        let info = await this.sessionInfo.promise;
        return this.config.userInfosToSubscribeOverride
            || info.userInfosToSubscribe
            || this.config.userInfosToSubscribeDefault;
    }
    getUsersData() {
        return this.sessionInfo.promise.then(info => ({
            user: info.userInfo,
            identity: info.identity
        }));
    }
    async getConsumptionReportInterval() {
        let context = await this.getSessionContext();
        let consumptionIntervalToUse = this.config.consumptionReportIntervalOverride
            || context.consumptionReportInterval
            || this.config.consumptionReportIntervalDefault;
        try {
            return iso8601_duration_1.toSeconds(iso8601_duration_1.parse(consumptionIntervalToUse));
        }
        catch (e) {
            log.error('Failed to parse consumption report interval', consumptionIntervalToUse, 'using default value', this.config.consumptionReportIntervalDefault);
            return iso8601_duration_1.toSeconds(iso8601_duration_1.parse(this.config.consumptionReportIntervalDefault));
        }
    }
    async getHttpCacheInterval() {
        let context = await this.getSessionContext();
        let cacheIntervalToUse = this.config.httpCacheIntervalOverride
            || context.httpCacheInterval
            || this.config.httpCacheIntervalDefault;
        try {
            return iso8601_duration_1.toSeconds(iso8601_duration_1.parse(cacheIntervalToUse));
        }
        catch (e) {
            log.error('Failed to parse cache interval', cacheIntervalToUse, 'using default value', this.config.httpCacheIntervalDefault);
            return iso8601_duration_1.toSeconds(iso8601_duration_1.parse(this.config.httpCacheIntervalDefault));
        }
    }
}
exports.Session = Session;
