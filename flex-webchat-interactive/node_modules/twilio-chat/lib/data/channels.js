"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const logger_1 = require("../logger");
const channel_1 = require("../channel");
exports.Channel = channel_1.Channel;
const deferred_1 = require("../util/deferred");
const util_1 = require("../util");
const log = logger_1.Logger.scope('Channels');
/**
 * Represents channels collection
 * {@see Channel}
 */
class Channels extends events_1.EventEmitter {
    constructor(services) {
        super();
        this.services = services;
        this.channels = new Map();
        this.thumbstones = new Set();
        this.syncListFetched = false;
        this.syncListRead = new deferred_1.Deferred();
    }
    getMap() {
        return this.services.session.getMyChannelsId()
            .then(name => this.services.syncClient.map({ id: name, mode: 'open_existing' }));
    }
    /**
     * Add channel to server
     * @private
     * @returns {Promise<Channel|SessionError>} Channel
     */
    async addChannel(options) {
        let attributes;
        if (typeof options.attributes === 'undefined') {
            attributes = {};
        }
        else {
            attributes = options.attributes;
        }
        if (attributes === null) {
            throw new Error('Attributes can\'t be null');
        }
        if (attributes.constructor !== Object) {
            throw new Error('Attributes must be a valid JSON object');
        }
        let response = await this.services.session.addCommand('createChannel', {
            friendlyName: options.friendlyName,
            uniqueName: options.uniqueName,
            type: options.isPrivate ? 'private' : 'public',
            attributes: JSON.stringify(attributes)
        });
        let channelSid = 'channelSid' in response ? response['channelSid'] : null;
        let channelDocument = 'channel' in response ? response['channel'] : null;
        let existingChannel = this.channels.get(channelSid);
        if (existingChannel) {
            await existingChannel._subscribe();
            return existingChannel;
        }
        let channel = new channel_1.Channel(this.services, {
            channel: channelDocument,
            entityName: null,
            uniqueName: null,
            attributes: null,
            createdBy: null,
            friendlyName: null,
            lastConsumedMessageIndex: null,
            type: options.isPrivate ? 'private' : 'public',
            dateCreated: null,
            dateUpdated: null
        }, channelSid);
        this.channels.set(channel.sid, channel);
        this.registerForEvents(channel);
        await channel._subscribe();
        this.emit('channelAdded', channel);
        return channel;
    }
    /**
     * Fetch channels list and instantiate all necessary objects
     */
    fetchChannels() {
        this.getMap()
            .then(async (map) => {
            map.on('itemAdded', args => {
                log.debug('itemAdded: ' + args.item.key);
                this.upsertChannel('sync', args.item.key, args.item.value);
            });
            map.on('itemRemoved', args => {
                log.debug('itemRemoved: ' + args.key);
                let sid = args.key;
                if (!this.syncListFetched) {
                    this.thumbstones.add(sid);
                }
                let channel = this.channels.get(sid);
                if (channel) {
                    if (channel.status === 'joined' || channel.status === 'invited') {
                        channel._setStatus('known', 'sync');
                        this.emit('channelLeft', channel);
                    }
                    if (channel.isPrivate) {
                        this.channels.delete(sid);
                        this.emit('channelRemoved', channel);
                        channel.emit('removed', channel);
                    }
                }
            });
            map.on('itemUpdated', args => {
                log.debug('itemUpdated: ' + args.item.key);
                this.upsertChannel('sync', args.item.key, args.item.value);
            });
            let upserts = [];
            let paginator = await this.services.syncList.getPage();
            let items = paginator.items;
            items.forEach(item => {
                upserts.push(this.upsertChannel('synclist', item.channel_sid, item));
            });
            while (paginator.hasNextPage) {
                paginator = await paginator.nextPage();
                paginator.items.forEach(item => {
                    upserts.push(this.upsertChannel('synclist', item.channel_sid, item));
                });
            }
            this.syncListRead.set(true);
            return Promise.all(upserts);
        })
            .then(() => {
            this.syncListFetched = true;
            this.thumbstones.clear();
            log.debug('Channels list fetched');
        })
            .then(() => this)
            .catch(e => {
            if (this.services.syncClient.connectionState != 'disconnected') {
                log.error('Failed to get channels list', e);
            }
            log.debug('ERROR: Failed to get channels list', e);
            throw e;
        });
    }
    _wrapPaginator(page, op) {
        return op(page.items)
            .then(items => ({
            items: items,
            hasNextPage: page.hasNextPage,
            hasPrevPage: page.hasPrevPage,
            nextPage: () => page.nextPage().then(x => this._wrapPaginator(x, op)),
            prevPage: () => page.prevPage().then(x => this._wrapPaginator(x, op))
        }));
    }
    getChannels(args) {
        return this.getMap()
            .then(channelsMap => channelsMap.getItems(args))
            .then(page => this._wrapPaginator(page, items => Promise.all(items.map(item => this.upsertChannel('sync', item.key, item.value)))));
    }
    getChannel(sid) {
        return this.getMap()
            .then(channelsMap => channelsMap.getItems({ key: sid }))
            .then(page => page.items.map(item => this.upsertChannel('sync', item.key, item.value)))
            .then(items => items.length > 0 ? items[0] : null);
    }
    pushChannel(descriptor) {
        const sid = descriptor.sid;
        const data = {
            entityName: null,
            lastConsumedMessageIndex: descriptor.lastConsumedMessageIndex,
            type: descriptor.type,
            status: descriptor.status,
            friendlyName: descriptor.friendlyName,
            dateUpdated: descriptor.dateUpdated,
            dateCreated: descriptor.dateCreated,
            uniqueName: descriptor.uniqueName,
            createdBy: descriptor.createdBy,
            attributes: descriptor.attributes,
            channel: descriptor.channel,
            notificationLevel: descriptor.notificationLevel,
            sid: sid
        };
        return this.upsertChannel('chat', sid, data);
    }
    upsertChannel(source, sid, data) {
        log.trace('upsertChannel(sid=' + sid + ', data=', data);
        let channel = this.channels.get(sid);
        // Update the Channel's status if we know about it
        if (channel) {
            log.trace('upsertChannel: channel ' + sid + ' is known and it\'s' +
                ' status is known from source ' + channel._statusSource() +
                ' and update came from source ' + source, channel);
            if (typeof channel._statusSource() === 'undefined'
                || source === channel._statusSource()
                || (source === 'synclist' && channel._statusSource() !== 'sync')
                || source === 'sync') {
                if (data.status === 'joined' && channel.status !== 'joined') {
                    channel._setStatus('joined', source);
                    let updateData = {};
                    if (typeof data.notificationLevel !== 'undefined') {
                        updateData.notificationLevel = data.notificationLevel;
                    }
                    if (typeof data.lastConsumedMessageIndex !== 'undefined') {
                        updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;
                    }
                    if (!util_1.isDeepEqual(updateData, {})) {
                        channel._update(updateData);
                    }
                    channel._subscribe().then(() => { this.emit('channelJoined', channel); });
                }
                else if (data.status === 'invited' && channel.status !== 'invited') {
                    channel._setStatus('invited', source);
                    let updateData = {};
                    if (typeof data.notificationLevel !== 'undefined') {
                        updateData.notificationLevel = data.notificationLevel;
                    }
                    if (typeof data.lastConsumedMessageIndex !== 'undefined') {
                        updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;
                    }
                    if (!util_1.isDeepEqual(updateData, {})) {
                        channel._update(updateData);
                    }
                    channel._subscribe().then(() => { this.emit('channelInvited', channel); });
                }
                else if (data.status === 'known' &&
                    (channel.status === 'invited' || channel.status === 'joined')) {
                    channel._setStatus('known', source);
                    channel._update(data);
                    channel._subscribe().then(() => { this.emit('channelLeft', channel); });
                }
                else if ((data.status === 'notParticipating' || data.status === 'known') && data.type === 'private') {
                    channel._subscribe();
                }
                else {
                    channel._update(data);
                }
            }
            else {
                log.trace('upsertChannel: channel is known from sync and came from chat, ignoring', {
                    sid: sid,
                    data: data.status,
                    channel: channel.status
                });
            }
            return channel._subscribe().then(() => channel);
        }
        if ((source === 'chat' || source === 'synclist') && this.thumbstones.has(sid)) {
            // if channel was deleted, we ignore it
            log.trace('upsertChannel: channel is deleted and came again from chat, ignoring', sid);
            return;
        }
        // Fetch the Channel if we don't know about it
        log.trace('upsertChannel: creating local channel object with sid ' + sid, data);
        channel = new channel_1.Channel(this.services, data, sid);
        this.channels.set(sid, channel);
        return channel._subscribe().then(() => {
            this.registerForEvents(channel);
            this.emit('channelAdded', channel);
            if (data.status === 'joined') {
                channel._setStatus('joined', source);
                this.emit('channelJoined', channel);
            }
            else if (data.status === 'invited') {
                channel._setStatus('invited', source);
                this.emit('channelInvited', channel);
            }
            return channel;
        });
    }
    onChannelRemoved(sid) {
        let channel = this.channels.get(sid);
        if (channel) {
            this.channels.delete(sid);
            this.emit('channelRemoved', channel);
        }
    }
    registerForEvents(channel) {
        channel.on('removed', () => this.onChannelRemoved(channel.sid));
        channel.on('updated', (args) => this.emit('channelUpdated', args));
        channel.on('memberJoined', this.emit.bind(this, 'memberJoined'));
        channel.on('memberLeft', this.emit.bind(this, 'memberLeft'));
        channel.on('memberUpdated', (args) => this.emit('memberUpdated', args));
        channel.on('messageAdded', this.emit.bind(this, 'messageAdded'));
        channel.on('messageUpdated', (args) => this.emit('messageUpdated', args));
        channel.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
        channel.on('typingStarted', this.emit.bind(this, 'typingStarted'));
        channel.on('typingEnded', this.emit.bind(this, 'typingEnded'));
    }
}
exports.Channels = Channels;
