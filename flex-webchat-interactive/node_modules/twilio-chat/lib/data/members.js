"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const member_1 = require("../member");
const logger_1 = require("../logger");
const log = logger_1.Logger.scope('Members');
/**
 * @classdesc Represents the collection of members for the channel
 * @fires Members#memberJoined
 * @fires Members#memberLeft
 * @fires Members#memberUpdated
 */
class Members extends events_1.EventEmitter {
    constructor(channel, services, members) {
        super();
        this.services = services;
        this.channel = channel;
        this.members = members;
    }
    async unsubscribe() {
        if (this.rosterEntityPromise) {
            let entity = await this.rosterEntityPromise;
            entity.close();
            this.rosterEntityPromise = null;
        }
    }
    subscribe(rosterObjectName) {
        return this.rosterEntityPromise = this.rosterEntityPromise
            || this.services.syncClient.map({ id: rosterObjectName, mode: 'open_existing' })
                .then(rosterMap => {
                rosterMap.on('itemAdded', args => {
                    log.debug(this.channel.sid + ' itemAdded: ' + args.item.key);
                    this.upsertMember(args.item.key, args.item.value)
                        .then(member => {
                        this.emit('memberJoined', member);
                    });
                });
                rosterMap.on('itemRemoved', args => {
                    log.debug(this.channel.sid + ' itemRemoved: ' + args.key);
                    let memberSid = args.key;
                    if (!this.members.has(memberSid)) {
                        return;
                    }
                    let leftMember = this.members.get(memberSid);
                    this.members.delete(memberSid);
                    this.emit('memberLeft', leftMember);
                });
                rosterMap.on('itemUpdated', args => {
                    log.debug(this.channel.sid + ' itemUpdated: ' + args.item.key);
                    this.upsertMember(args.item.key, args.item.value);
                });
                let membersPromises = [];
                let that = this;
                const rosterMapHandler = function (paginator) {
                    paginator.items.forEach(item => { membersPromises.push(that.upsertMember(item.key, item.value)); });
                    return paginator.hasNextPage ? paginator.nextPage().then(rosterMapHandler) : null;
                };
                return rosterMap
                    .getItems()
                    .then(rosterMapHandler)
                    .then(() => Promise.all(membersPromises))
                    .then(() => rosterMap);
            })
                .catch(err => {
                this.rosterEntityPromise = null;
                if (this.services.syncClient.connectionState != 'disconnected') {
                    log.error('Failed to get roster object for channel', this.channel.sid, err);
                }
                log.debug('ERROR: Failed to get roster object for channel', this.channel.sid, err);
                throw err;
            });
    }
    async upsertMember(memberSid, data) {
        let member = this.members.get(memberSid);
        if (member) {
            return member._update(data);
        }
        member = new member_1.Member(this.services, this.channel, data, memberSid);
        this.members.set(memberSid, member);
        member.on('updated', (args) => this.emit('memberUpdated', args));
        return member;
    }
    /**
     * @returns {Promise<Array<Member>>} returns list of members {@see Member}
     */
    getMembers() {
        return this.rosterEntityPromise.then(() => {
            let members = [];
            this.members.forEach((member) => members.push(member));
            return members;
        });
    }
    /**
     * Get member by SID from channel
     * @returns {Promise<|Error>}
     */
    async getMemberBySid(memberSid) {
        return this.rosterEntityPromise.then(() => {
            let member = this.members.get(memberSid);
            if (!member) {
                throw new Error('Member with SID ' + memberSid + ' was not found');
            }
            return member;
        });
    }
    /**
     * Get member by identity from channel
     * @returns {Promise<|Error>}
     */
    async getMemberByIdentity(identity) {
        let foundMember = null;
        return this.rosterEntityPromise.then(() => {
            this.members.forEach((member) => {
                if (member.identity === identity) {
                    foundMember = member;
                }
            });
            if (!foundMember) {
                throw new Error('Member with identity ' + identity + ' was not found');
            }
            return foundMember;
        });
    }
    /**
     * Add user to the channel
     * @returns {Promise<void|SessionError>}
     */
    add(identity) {
        return this.services.session.addCommand('addMemberV2', {
            channelSid: this.channel.sid,
            username: identity
        });
    }
    /**
     * Invites user to the channel
     * User can choose either to join or not
     * @returns {Promise<|SessionError>}
     */
    invite(identity) {
        return this.services.session.addCommand('inviteMember', {
            channelSid: this.channel.sid,
            username: identity
        });
    }
    /**
     * Remove member from channel by Identity
     * @returns {Promise<|SessionError>}
     */
    removeByIdentity(identity) {
        return this.services.session.addCommand('removeMember', {
            channelSid: this.channel.sid,
            username: identity
        });
    }
    /**
     * Remove member from channel by sid
     * @returns {Promise<|SessionError>}
     */
    removeBySid(sid) {
        return this.services.session.addCommand('removeMember', {
            channelSid: this.channel.sid,
            memberSid: sid
        });
    }
}
exports.Members = Members;
/**
 * Fired when member joined channel
 * @event Members#memberJoined
 * @type {Member}
 */
/**
 * Fired when member left channel
 * @event Members#memberLeft
 * @type {Member}
 */
/**
 * Fired when member updated
 * @event Members#memberUpdated
 * @type {Object}
 * @property {Member} member - Updated Member
 * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons
 */
