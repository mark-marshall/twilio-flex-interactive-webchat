"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const logger_1 = require("../logger");
const message_1 = require("../message");
const log = logger_1.Logger.scope('Messages');
/**
 * Represents the collection of messages in a channel
 */
class Messages extends events_1.EventEmitter {
    constructor(channel, services) {
        super();
        this.channel = channel;
        this.services = services;
        this.messagesByIndex = new Map();
        this.messagesListPromise = null;
    }
    /**
     * Subscribe to the Messages Event Stream
     * @param {String} name - The name of Sync object for the Messages resource.
     * @returns {Promise}
     */
    subscribe(name) {
        return this.messagesListPromise =
            this.messagesListPromise ||
                this.services.syncClient.list({ id: name, mode: 'open_existing' })
                    .then(list => {
                    list.on('itemAdded', args => {
                        log.debug(this.channel.sid + ' itemAdded: ' + args.item.index);
                        let message = new message_1.Message(this.channel, this.services, args.item.index, args.item.value);
                        if (this.messagesByIndex.has(message.index)) {
                            log.debug('Message arrived, but already known and ignored', this.channel.sid, message.index);
                            return;
                        }
                        this.messagesByIndex.set(message.index, message);
                        message.on('updated', (args) => this.emit('messageUpdated', args));
                        this.emit('messageAdded', message);
                    });
                    list.on('itemRemoved', args => {
                        log.debug(this.channel.sid + ' itemRemoved: ' + args.index);
                        let index = args.index;
                        if (this.messagesByIndex.has(index)) {
                            let message = this.messagesByIndex.get(index);
                            this.messagesByIndex.delete(message.index);
                            message.removeAllListeners('updated');
                            this.emit('messageRemoved', message);
                        }
                    });
                    list.on('itemUpdated', args => {
                        log.debug(this.channel.sid + ' itemUpdated: ' + args.item.index);
                        let message = this.messagesByIndex.get(args.item.index);
                        if (message) {
                            message._update(args.item.value);
                        }
                    });
                    return list;
                })
                    .catch(err => {
                    this.messagesListPromise = null;
                    if (this.services.syncClient.connectionState != 'disconnected') {
                        log.error('Failed to get messages object for channel', this.channel.sid, err);
                    }
                    log.debug('ERROR: Failed to get messages object for channel', this.channel.sid, err);
                    throw err;
                });
    }
    async unsubscribe() {
        if (this.messagesListPromise) {
            let entity = await this.messagesListPromise;
            entity.close();
            this.messagesListPromise = null;
        }
    }
    /**
     * Send Message to the channel
     * @param {String} message - Message to post
     * @param {Object} attributes Message attributes
     * @returns Returns promise which can fail
     */
    async send(message, attributes = {}) {
        log.debug('Sending text message', message, attributes);
        if (attributes === null) {
            throw new Error('Attributes can\'t be null');
        }
        if (attributes.constructor !== Object) {
            throw new Error('Attributes must be a valid JSON object');
        }
        return this.services.session.addCommand('sendMessage', {
            channelSid: this.channel.sid,
            text: message,
            attributes: JSON.stringify(attributes)
        });
    }
    /**
     * Send Media Message to the channel
     * @param {FormData | Channel#SendMediaOptions} mediaContent - Media content to post
     * @param {Object} attributes Message attributes
     * @returns Returns promise which can fail
     */
    async sendMedia(mediaContent, attributes = {}) {
        log.debug('Sending media message', mediaContent, attributes);
        if (attributes.constructor !== Object) {
            throw new Error('Attributes must be a valid JSON object');
        }
        let media;
        if (typeof FormData !== 'undefined' && (mediaContent instanceof FormData)) {
            log.debug('Sending media message as FormData', mediaContent, attributes);
            media = await this.services.mcsClient.postFormData(mediaContent);
        }
        else {
            log.debug('Sending media message as SendMediaOptions', mediaContent, attributes);
            let mediaOptions = mediaContent;
            if (!mediaOptions.contentType || !mediaOptions.media) {
                throw new Error('Media content <Channel#SendMediaOptions> must contain non-empty contentType and media');
            }
            media = await this.services.mcsClient.post(mediaOptions.contentType, mediaOptions.media);
        }
        return this.services.session.addCommand('sendMediaMessage', {
            channelSid: this.channel.sid,
            mediaSid: media.sid,
            attributes: JSON.stringify(attributes)
        });
    }
    /**
     * Returns messages from channel using paginator interface
     * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.
     * @param {String} [anchor] Most early message id which is already known, or 'end' by default
     * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default
     * @returns {Promise<Paginator<Message>>} last page of messages by default
     */
    getMessages(pageSize, anchor, direction) {
        anchor = (typeof anchor !== 'undefined') ? anchor : 'end';
        direction = direction || 'backwards';
        return this._getMessages(pageSize, anchor, direction);
    }
    wrapPaginator(order, page, op) {
        // We should swap next and prev page here, because of misfit of Sync and Chat paging conceptions
        let shouldReverse = order === 'desc';
        let np = () => page.nextPage().then(x => this.wrapPaginator(order, x, op));
        let pp = () => page.prevPage().then(x => this.wrapPaginator(order, x, op));
        return op(page.items).then(items => ({
            items: items.sort((x, y) => { return x.index - y.index; }),
            hasPrevPage: shouldReverse ? page.hasNextPage : page.hasPrevPage,
            hasNextPage: shouldReverse ? page.hasPrevPage : page.hasNextPage,
            prevPage: shouldReverse ? np : pp,
            nextPage: shouldReverse ? pp : np
        }));
    }
    _upsertMessage(index, value) {
        let cachedMessage = this.messagesByIndex.get(index);
        if (cachedMessage) {
            return cachedMessage;
        }
        let message = new message_1.Message(this.channel, this.services, index, value);
        this.messagesByIndex.set(message.index, message);
        message.on('updated', (args) => this.emit('messageUpdated', args));
        return message;
    }
    /**
     * Returns last messages from channel
     * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.
     * @param {String} [anchor] Most early message id which is already known, or 'end' by default
     * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default
     * @returns {Promise<SyncPaginator<Message>>} last page of messages by default
     * @private
     */
    _getMessages(pageSize, anchor, direction) {
        anchor = (typeof anchor !== 'undefined') ? anchor : 'end';
        pageSize = pageSize || 30;
        let order = direction === 'backwards' ? 'desc' : 'asc';
        return this.messagesListPromise
            .then(messagesList => messagesList.getItems({
            from: anchor !== 'end' ? anchor : void (0),
            pageSize,
            order
        }))
            .then(page => this.wrapPaginator(order, page, items => Promise.all(items.map(item => this._upsertMessage(item.index, item.value)))));
    }
}
exports.Messages = Messages;
