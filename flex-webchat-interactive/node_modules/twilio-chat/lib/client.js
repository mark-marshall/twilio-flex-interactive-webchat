"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const logger_1 = require("./logger");
const configuration_1 = require("./configuration");
const user_1 = require("./user");
exports.User = user_1.User;
const publicchannels_1 = require("./data/publicchannels");
const network_1 = require("./services/network");
const notificationtypes_1 = require("./interfaces/notificationtypes");
const synclist_1 = require("./synclist");
const twilsock_1 = require("twilsock");
const twilio_notifications_1 = require("twilio-notifications");
const twilio_sync_1 = require("twilio-sync");
const twilio_mcs_client_1 = require("twilio-mcs-client");
const session_1 = require("./session");
const channels_1 = require("./data/channels");
const users_1 = require("./data/users");
const typingindicator_1 = require("./services/typingindicator");
const consumptionhorizon_1 = require("./services/consumptionhorizon");
const userchannels_1 = require("./data/userchannels");
const pushnotification_1 = require("./pushnotification");
exports.PushNotification = pushnotification_1.PushNotification;
const util_1 = require("./util");
const log = logger_1.Logger.scope('Client');
const SDK_VERSION = require('./../package.json').version;
const MSG_NO_TOKEN = 'A valid Twilio token should be provided';
class ClientServices {
}
/**
 * A Client is a starting point to access Twilio Programmable Chat functionality.
 *
 * @property {Client#ConnectionState} connectionState - Client connection state
 * @property {Boolean} reachabilityEnabled - Client reachability state
 * @property {User} user - Information for logged in user
 * @property {String} version - Current version of Chat client
 *
 * @fires Client#connectionError
 * @fires Client#connectionStateChanged
 * @fires Client#channelAdded
 * @fires Client#channelInvited
 * @fires Client#channelJoined
 * @fires Client#channelLeft
 * @fires Client#channelRemoved
 * @fires Client#channelUpdated
 * @fires Client#memberJoined
 * @fires Client#memberLeft
 * @fires Client#memberUpdated
 * @fires Client#messageAdded
 * @fires Client#messageRemoved
 * @fires Client#messageUpdated
 * @fires Client#pushNotification
 * @fires Client#tokenAboutToExpire
 * @fires Client#tokenExpired
 * @fires Client#typingEnded
 * @fires Client#typingStarted
 * @fires Client#userSubscribed
 * @fires Client#userUnsubscribed
 * @fires Client#userUpdated
 */
class Client extends events_1.EventEmitter {
    /**
     * These options can be passed to Client constructor.
     * @typedef {Object} Client#ClientOptions
     * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
     *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
     */
    /**
     * These options can be passed to {@link Client#createChannel}.
     * @typedef {Object} Client#CreateChannelOptions
     * @property {Object} [attributes] - Any custom attributes to attach to the Channel
     * @property {String} [friendlyName] - The non-unique display name of the Channel
     * @property {Boolean} [isPrivate] - Whether or not this Channel should be visible to uninvited Clients
     * @property {String} [uniqueName] - The unique identity name of the Channel
     */
    /**
     * Connection state of Client.
     * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState
     */
    /**
     * Notifications channel type.
     * @typedef {('gcm'|'fcm'|'apn')} Client#NotificationsChannelType
     */
    /**
     * These options can be passed to {@link Client#getLocalChannels}.
     * @typedef {Object} Client#ChannelSortingOptions
     * @property {('lastMessage'|'friendlyName'|'uniqueName')} criteria - Sorting criteria for Channels array
     * @property {('ascending'|'descending')} [order] - Sorting order. If not present, then default is <code>ascending</code>
     */
    constructor(token, options) {
        super();
        this.connectionState = 'connecting';
        this.sessionPromise = null;
        this.channelsPromise = null;
        this.version = SDK_VERSION;
        this.parsePushNotification = Client.parsePushNotification;
        this.options = (options || {});
        if (!this.options.disableDeepClone) {
            this.options = util_1.deepClone(this.options);
        }
        this.options.logLevel = this.options.logLevel || 'silent';
        log.setLevel(this.options.logLevel);
        const productId = this.options.productId = 'ip_messaging';
        // Filling ClientMetadata
        this.options.clientMetadata = this.options.clientMetadata || {};
        if (!this.options.clientMetadata.hasOwnProperty('type')) {
            this.options.clientMetadata.type = 'chat';
        }
        if (!this.options.clientMetadata.hasOwnProperty('sdk')) {
            this.options.clientMetadata.sdk = 'JS';
            this.options.clientMetadata.sdkv = SDK_VERSION;
        }
        // Enable session local storage for Sync
        this.options.Sync = this.options.Sync || {};
        if (typeof this.options.Sync.enableSessionStorage === 'undefined') {
            this.options.Sync.enableSessionStorage = true;
        }
        if (this.options.region) {
            this.options.Sync.region = this.options.region;
        }
        if (!token) {
            throw new Error(MSG_NO_TOKEN);
        }
        this.services = new ClientServices();
        this.config = new configuration_1.Configuration(this.options);
        this.options.twilsockClient = this.options.twilsockClient || new twilsock_1.Twilsock(token, productId, this.options);
        this.options.transport = this.options.transport || this.options.twilsockClient;
        this.options.notificationsClient = this.options.notificationsClient || new twilio_notifications_1.Notifications(token, this.options);
        this.options.syncClient = this.options.syncClient || new twilio_sync_1.SyncClient(token, this.options);
        this.services.syncClient = this.options.syncClient;
        this.services.transport = this.options.transport;
        this.services.twilsockClient = this.options.twilsockClient;
        this.services.notificationClient = this.options.notificationsClient;
        this.services.session = new session_1.Session(this.services, this.config);
        this.sessionPromise = this.services.session.initialize();
        this.services.network = new network_1.Network(this.config, this.services);
        this.services.users = new users_1.Users({
            session: this.services.session,
            network: this.services.network,
            syncClient: this.services.syncClient
        });
        this.services.users.on('userSubscribed', this.emit.bind(this, 'userSubscribed'));
        this.services.users.on('userUpdated', (args) => this.emit('userUpdated', args));
        this.services.users.on('userUnsubscribed', this.emit.bind(this, 'userUnsubscribed'));
        this.services.twilsockClient.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));
        this.services.twilsockClient.on('tokenExpired', () => this.emit('tokenExpired'));
        this.services.twilsockClient.on('connectionError', (error) => this.emit('connectionError', error));
        this.services.consumptionHorizon = new consumptionhorizon_1.ConsumptionHorizon(this.services);
        this.services.typingIndicator = new typingindicator_1.TypingIndicator(this.config, {
            transport: this.services.twilsockClient,
            notificationClient: this.services.notificationClient
        }, this.getChannelBySid.bind(this));
        this.services.syncList = new synclist_1.SyncList(this.services);
        this.channels = new channels_1.Channels(this.services);
        this.channelsPromise = this.sessionPromise.then(() => {
            this.channels.on('channelAdded', this.emit.bind(this, 'channelAdded'));
            this.channels.on('channelRemoved', this.emit.bind(this, 'channelRemoved'));
            this.channels.on('channelInvited', this.emit.bind(this, 'channelInvited'));
            this.channels.on('channelJoined', this.emit.bind(this, 'channelJoined'));
            this.channels.on('channelLeft', this.emit.bind(this, 'channelLeft'));
            this.channels.on('channelUpdated', (args) => this.emit('channelUpdated', args));
            this.channels.on('memberJoined', this.emit.bind(this, 'memberJoined'));
            this.channels.on('memberLeft', this.emit.bind(this, 'memberLeft'));
            this.channels.on('memberUpdated', (args) => this.emit('memberUpdated', args));
            this.channels.on('messageAdded', this.emit.bind(this, 'messageAdded'));
            this.channels.on('messageUpdated', (args) => this.emit('messageUpdated', args));
            this.channels.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
            this.channels.on('typingStarted', this.emit.bind(this, 'typingStarted'));
            this.channels.on('typingEnded', this.emit.bind(this, 'typingEnded'));
            return this.channels.fetchChannels();
        }).then(() => this.channels);
        this.services.notificationClient.on('connectionStateChanged', (state) => {
            let changedConnectionState = null;
            switch (state) {
                case 'connected':
                    changedConnectionState = 'connected';
                    break;
                case 'denied':
                    changedConnectionState = 'denied';
                    break;
                case 'disconnecting':
                    changedConnectionState = 'disconnecting';
                    break;
                case 'disconnected':
                    changedConnectionState = 'disconnected';
                    break;
                default:
                    changedConnectionState = 'connecting';
            }
            if (changedConnectionState !== this.connectionState) {
                this.connectionState = changedConnectionState;
                this.emit('connectionStateChanged', this.connectionState);
            }
        });
        this.fpaToken = token;
    }
    /**
     * Factory method to create Chat client instance.
     *
     * @param {String} token - Access token
     * @param {Client#ClientOptions} options - Options to customize the Client
     * @returns {Promise<Client>}
     */
    static async create(token, options) {
        let client = new Client(token, options);
        await client.initialize();
        return client;
    }
    get user() { return this.services.users.myself; }
    get reachabilityEnabled() { return this.services.session.reachabilityEnabled; }
    get token() { return this.fpaToken; }
    subscribeToPushNotifications(channelType) {
        let subscriptions = [];
        [notificationtypes_1.NotificationTypes.NEW_MESSAGE,
            notificationtypes_1.NotificationTypes.ADDED_TO_CHANNEL,
            notificationtypes_1.NotificationTypes.INVITED_TO_CHANNEL,
            notificationtypes_1.NotificationTypes.REMOVED_FROM_CHANNEL,
            notificationtypes_1.NotificationTypes.TYPING_INDICATOR,
            notificationtypes_1.NotificationTypes.CONSUMPTION_UPDATE]
            .forEach(messageType => {
            subscriptions.push(this.services.notificationClient.subscribe(messageType, channelType));
        });
        return Promise.all(subscriptions);
    }
    unsubscribeFromPushNotifications(channelType) {
        let subscriptions = [];
        [notificationtypes_1.NotificationTypes.NEW_MESSAGE,
            notificationtypes_1.NotificationTypes.ADDED_TO_CHANNEL,
            notificationtypes_1.NotificationTypes.INVITED_TO_CHANNEL,
            notificationtypes_1.NotificationTypes.REMOVED_FROM_CHANNEL,
            notificationtypes_1.NotificationTypes.TYPING_INDICATOR,
            notificationtypes_1.NotificationTypes.CONSUMPTION_UPDATE]
            .forEach(messageType => {
            subscriptions.push(this.services.notificationClient.unsubscribe(messageType, channelType));
        });
        return Promise.all(subscriptions);
    }
    async initialize() {
        await this.sessionPromise;
        Client.supportedPushChannels.forEach(channelType => this.subscribeToPushNotifications(channelType));
        let links = await this.services.session.getSessionLinks();
        this.services.publicChannels = new publicchannels_1.PublicChannels(this, this.services, links.publicChannelsUrl);
        this.services.userChannels = new userchannels_1.UserChannels(this, this.services, links.myChannelsUrl);
        let options = Object.assign(this.options);
        options.transport = null;
        this.services.mcsClient = new twilio_mcs_client_1.McsClient(this.fpaToken, links.mediaServiceUrl, options);
        await this.services.typingIndicator.initialize();
    }
    /**
     * Gracefully shutting down library instance.
     * @public
     * @returns {Promise<void>}
     */
    async shutdown() {
        await this.services.twilsockClient.disconnect();
    }
    /**
     * Update the token used by the Client and re-register with Programmable Chat services.
     * @param {String} token - Access token
     * @public
     * @returns {Promise<Client>}
     */
    async updateToken(token) {
        log.info('updateToken');
        if (!token) {
            throw new Error(MSG_NO_TOKEN);
        }
        if (this.fpaToken === token) {
            return this;
        }
        await this.services.twilsockClient.updateToken(token)
            .then(() => this.fpaToken = token)
            .then(() => this.services.mcsClient.updateToken(token))
            .then(() => this.sessionPromise);
        return this;
    }
    /**
     * Get a known Channel by its SID.
     * @param {String} channelSid - Channel sid
     * @returns {Promise<Channel>}
     */
    async getChannelBySid(channelSid) {
        if (!channelSid || typeof channelSid !== 'string') {
            throw new Error('Client.getChannelBySid requires a <String>channelSid parameter');
        }
        return this.channels.syncListRead.promise.then(() => this.channels.getChannel(channelSid)
            .then(channel => channel || this.services.publicChannels.getChannelBySid(channelSid).then(x => this.channels.pushChannel(x))));
    }
    /**
     * Get a known Channel by its unique identifier name.
     * @param {String} uniqueName - The unique identifier name of the Channel to get
     * @returns {Promise<Channel>}
     */
    async getChannelByUniqueName(uniqueName) {
        if (!uniqueName || typeof uniqueName !== 'string') {
            throw new Error('Client.getChannelByUniqueName requires a <String>uniqueName parameter');
        }
        return this.channels.syncListRead.promise.then(() => this.services.publicChannels.getChannelByUniqueName(uniqueName).then(x => this.channels.pushChannel(x)));
    }
    /**
     * Get the current list of all subscribed Channels.
     * @returns {Promise<Paginator<Channel>>}
     */
    getSubscribedChannels(args) {
        return this.channelsPromise.then(channels => channels.getChannels(args));
    }
    /**
     * Get array of Channels locally known to Client in provided sorting order.
     * Locally known channels are the ones created and/or joined during client runtime and currently logged in User subscribed Channels.
     * To ensure full list of subscribed Channels fetched - call the {@link Client#getSubscribedChannels} method
     * and fetch all pages with help of {@link Paginator#nextPage} method.
     * @param {Client#ChannelSortingOptions} [sortingOptions] - Options for the Channel sorting
     * @returns {Promise<Array<Channel>>}
     */
    getLocalChannels(sortingOptions) {
        return this.channelsPromise.then(channels => {
            let result = [];
            channels.channels.forEach(value => {
                result.push(value);
            });
            let sortingOrder = 'ascending';
            if (sortingOptions && sortingOptions.order) {
                if (sortingOptions.order === 'descending') {
                    sortingOrder = 'descending';
                }
                else if (sortingOptions.order !== 'ascending') {
                    throw new Error('Sorting order should be `ascending` or `descending`');
                }
            }
            if (sortingOptions && sortingOptions.criteria) {
                if (sortingOptions.criteria === 'lastMessage') {
                    result.sort((a, b) => Client.compareChannelsByLastMessage(a, b, sortingOrder));
                }
                else if (sortingOptions.criteria === 'uniqueName') {
                    result.sort((a, b) => Client.compareChannelsByStringProperty(a.uniqueName, b.uniqueName, sortingOrder));
                }
                else if (sortingOptions.criteria === 'friendlyName') {
                    result.sort((a, b) => Client.compareChannelsByStringProperty(a.friendlyName, b.friendlyName, sortingOrder));
                }
                else {
                    throw new Error('Sorting criteria should be one of `lastMessage`, `uniqueName` or `friendlyName`');
                }
            }
            return result;
        });
    }
    static compareChannelsByLastMessage(a, b, order) {
        if (a.lastMessage && b.lastMessage) {
            if (a.lastMessage.timestamp && b.lastMessage.timestamp) {
                if (a.lastMessage.timestamp.getTime() < b.lastMessage.timestamp.getTime()) {
                    return (order === 'ascending') ? -1 : 1;
                }
                else {
                    return (order === 'ascending') ? 1 : -1;
                }
            }
            else {
                if (a.lastMessage.timestamp) {
                    return -1;
                }
                else if (b.lastMessage.timestamp) {
                    return 1;
                }
            }
        }
        if (a.lastMessage) {
            return -1;
        }
        else if (b.lastMessage) {
            return 1;
        }
        return 0;
    }
    static compareChannelsByStringProperty(str1, str2, order) {
        if (str1 && str2) {
            return (order === 'ascending') ? str1.localeCompare(str2) : -1 * str1.localeCompare(str2);
        }
        else if (str1) {
            return -1;
        }
        else if (str2) {
            return 1;
        }
        return 0;
    }
    /**
     * Get the public channels directory content.
     * @returns {Promise<Paginator<ChannelDescriptor>>}
     */
    getPublicChannelDescriptors() {
        return this.services.publicChannels.getChannels();
    }
    /**
     * Get the User's (created by, joined or invited to) channels directory content.
     * @returns {Promise<Paginator<ChannelDescriptor>>}
     */
    getUserChannelDescriptors() {
        return this.services.userChannels.getChannels();
    }
    /**
     * Create a Channel on the server and subscribe to its events.
     * Default options are public Channel type with empty uniqueName and friendlyName.
     * @param {Client#CreateChannelOptions} [options] - Options for the Channel
     * @returns {Promise<Channel>}
     */
    createChannel(options) {
        options = options || {};
        return this.channelsPromise.then((channelsEntity) => channelsEntity.addChannel(options));
    }
    /**
     * Registers for push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported
     * @param {string} registrationId - Push notification id provided by platform
     * @returns {Promise<void>}
     */
    async setPushRegistrationId(channelType, registrationId) {
        if (Client.supportedPushChannels.indexOf(channelType) === -1) {
            throw new Error('Invalid or unsupported channelType: ' + channelType);
        }
        await this.subscribeToPushNotifications(channelType)
            .then(() => {
            return this.services.notificationClient.setPushRegistrationId(registrationId, channelType);
        });
    }
    /**
     * Unregisters from push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported
     * @returns {Promise<void>}
     */
    async unsetPushRegistrationId(channelType) {
        if (Client.supportedPushChannels.indexOf(channelType) === -1) {
            throw new Error('Invalid or unsupported channelType: ' + channelType);
        }
        await this.unsubscribeFromPushNotifications(channelType);
    }
    static parsePushNotificationChatData(data) {
        let result = {};
        for (let key in Client.supportedPushDataFields) {
            if (typeof data[key] !== 'undefined' && data[key] !== null) {
                if (key === 'message_index') {
                    if (util_1.parseToNumber(data[key]) !== null) {
                        result[Client.supportedPushDataFields[key]] = Number(data[key]);
                    }
                }
                else {
                    result[Client.supportedPushDataFields[key]] = data[key];
                }
            }
        }
        return result;
    }
    /**
     * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object
     * @param {Object} notificationPayload - Push notification payload
     * @returns {PushNotification|Error}
     */
    static parsePushNotification(notificationPayload) {
        log.debug('parsePushNotification, notificationPayload=', notificationPayload);
        if (typeof notificationPayload === 'undefined' || notificationPayload === null) {
            throw new Error('Push notification payload should be provided');
        }
        // APNS specifics
        if (typeof notificationPayload.aps !== 'undefined') {
            if (!notificationPayload.twi_message_type) {
                throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
            }
            let data = Client.parsePushNotificationChatData(notificationPayload);
            let apsPayload = notificationPayload.aps;
            let body = null;
            let title = null;
            if (typeof apsPayload.alert === 'string') {
                body = apsPayload.alert || null;
            }
            else {
                body = apsPayload.alert.body || null;
                title = apsPayload.alert.title || null;
            }
            return new pushnotification_1.PushNotification({
                title: title,
                body: body,
                sound: apsPayload.sound || null,
                badge: apsPayload.badge || null,
                action: apsPayload.category || null,
                type: notificationPayload.twi_message_type,
                data: data
            });
        }
        // FCM/GCM specifics
        if (typeof notificationPayload.data !== 'undefined') {
            let dataPayload = notificationPayload.data;
            if (!dataPayload.twi_message_type) {
                throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
            }
            let data = Client.parsePushNotificationChatData(notificationPayload.data);
            return new pushnotification_1.PushNotification({
                title: dataPayload.twi_title || null,
                body: dataPayload.twi_body || null,
                sound: dataPayload.twi_sound || null,
                badge: null,
                action: dataPayload.twi_action || null,
                type: dataPayload.twi_message_type,
                data: data
            });
        }
        throw new Error('Provided push notification payload is not Programmable Chat notification');
    }
    /**
     * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.
     * @param {Object} notificationPayload - Push notification payload
     * @returns {void|Error}
     */
    async handlePushNotification(notificationPayload) {
        log.debug('handlePushNotification, notificationPayload=', notificationPayload);
        this.emit('pushNotification', Client.parsePushNotification(notificationPayload));
    }
    /**
     * Gets user for given identity, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the subscribed list.
     * @param {String} identity - Identity of User
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity) {
        return this.services.users.getUser(identity);
    }
    /**
     * Gets user descriptor for given identity.
     * @param {String} identity - Identity of User
     * @returns {Promise<UserDescriptor>} User descriptor
     */
    async getUserDescriptor(identity) {
        return this.services.users.getUserDescriptor(identity);
    }
    /**
     * @returns {Promise<Array<User>>} List of subscribed User objects
     */
    async getSubscribedUsers() {
        return this.services.users.getSubscribedUsers();
    }
}
exports.Client = Client;
Client.version = SDK_VERSION;
Client.supportedPushChannels = ['fcm', 'apn', 'gcm'];
Client.supportedPushDataFields = {
    'channel_sid': 'channelSid',
    'message_sid': 'messageSid',
    'message_index': 'messageIndex'
};
exports.default = Client;
/**
 * Fired when a Channel becomes visible to the Client.
 * Fired for created and not joined private channels and for all type of channels Client has joined or invited to.
 * @event Client#channelAdded
 * @type {Channel}
 */
/**
 * Fired when the Client is invited to a Channel.
 * @event Client#channelInvited
 * @type {Channel}
 */
/**
 * Fired when the Client joins a Channel.
 * @event Client#channelJoined
 * @type {Channel}
 */
/**
 * Fired when the Client leaves a Channel.
 * @event Client#channelLeft
 * @type {Channel}
 */
/**
 * Fired when a Channel is no longer visible to the Client.
 * @event Client#channelRemoved
 * @type {Channel}
 */
/**
 * Fired when a Channel's attributes or metadata have been updated.
 * During Channel's {@link Client.create| creation and initialization} this event might be fired multiple times
 * for same joined or created Channel as new data is arriving from different sources.
 * @event Client#channelUpdated
 * @type {Object}
 * @property {Channel} channel - Updated Channel
 * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons
 */
/**
 * Fired when Client's connection state has been changed.
 * @event Client#connectionStateChanged
 * @type {Client#ConnectionState}
 */
/**
 * Fired when a Member has joined the Channel.
 * @event Client#memberJoined
 * @type {Member}
 */
/**
 * Fired when a Member has left the Channel.
 * @event Client#memberLeft
 * @type {Member}
 */
/**
 * Fired when a Member's fields has been updated.
 * @event Client#memberUpdated
 * @type {Object}
 * @property {Member} member - Updated Member
 * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Channel on the server.
 * @event Client#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Channel's message list.
 * @event Client#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Client#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when token is about to expire and needs to be updated.
 * @event Client#tokenAboutToExpire
 * @type {void}
 */
/**
 * Fired when token is expired.
 * @event Client#tokenExpired
 * @type {void}
 */
/**
 * Fired when a Member has stopped typing.
 * @event Client#typingEnded
 * @type {Member}
 */
/**
 * Fired when a Member has started typing.
 * @event Client#typingStarted
 * @type {Member}
 */
/**
 * Fired when client received (and parsed) push notification via one of push channels (apn, gcm, fcm).
 * @event Client#pushNotification
 * @type {PushNotification}
 */
/**
 * Fired when the Client is subscribed to a User.
 * @event Client#userSubscribed
 * @type {User}
 */
/**
 * Fired when the Client is unsubscribed from a User.
 * @event Client#userUnsubscribed
 * @type {User}
 */
/**
 * Fired when the User's properties or reachability status have been updated.
 * @event Client#userUpdated
 * @type {Object}
 * @property {User} user - Updated User
 * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons
 */
/**
 * Fired when connection is interrupted by unexpected reason
 * @event Client#connectionError
 * @type {Object}
 * @property {Boolean} terminal - twilsock will stop connection attempts
 * @property {String} message - root cause
 * @property {Number} [httpStatusCode] - http status code if available
 * @property {Number} [errorCode] - Twilio public error code if available
 */
