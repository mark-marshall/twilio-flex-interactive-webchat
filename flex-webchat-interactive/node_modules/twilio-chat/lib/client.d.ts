/// <reference types="node" />
import { EventEmitter } from 'events';
import { User } from './user';
import { Transport } from './interfaces/transport';
import { Twilsock as TwilsockClient } from 'twilsock';
import { Notifications as NotificationClient, ChannelType, ConnectionState as NotificationConnectionState } from 'twilio-notifications';
import { SyncClient } from 'twilio-sync';
import { Channel } from './data/channels';
import { UserDescriptor } from './userdescriptor';
import { ChannelDescriptor } from './channeldescriptor';
import { Paginator } from './interfaces/paginator';
import { PushNotification } from './pushnotification';
declare namespace Client {
    type ConnectionState = NotificationConnectionState;
    type NotificationsChannelType = ChannelType;
    type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent' | null;
    interface Options {
        region?: string;
        logLevel?: Client.LogLevel;
        productId?: string;
        twilsockClient?: TwilsockClient;
        transport?: Transport;
        notificationsClient?: NotificationClient;
        syncClient?: SyncClient;
        typingIndicatorTimeoutOverride?: number;
        consumptionReportIntervalOverride?: string;
        httpCacheIntervalOverride?: string;
        userInfosToSubscribeOverride?: number;
        retryWhenThrottledOverride?: boolean;
        backoffConfigOverride?: any;
        Chat?: any;
        Sync?: any;
        Notification?: any;
        Twilsock?: any;
        clientMetadata?: any;
    }
    interface CreateChannelOptions {
        attributes?: Object;
        friendlyName?: string;
        isPrivate?: boolean;
        uniqueName?: string;
    }
    type ChannelSortingCriteria = 'lastMessage' | 'friendlyName' | 'uniqueName';
    type ChannelSortingOrder = 'ascending' | 'descending';
    interface ChannelSortingOptions {
        criteria: ChannelSortingCriteria;
        order?: ChannelSortingOrder;
    }
}
/**
 * A Client is a starting point to access Twilio Programmable Chat functionality.
 *
 * @property {Client#ConnectionState} connectionState - Client connection state
 * @property {Boolean} reachabilityEnabled - Client reachability state
 * @property {User} user - Information for logged in user
 * @property {String} version - Current version of Chat client
 *
 * @fires Client#connectionError
 * @fires Client#connectionStateChanged
 * @fires Client#channelAdded
 * @fires Client#channelInvited
 * @fires Client#channelJoined
 * @fires Client#channelLeft
 * @fires Client#channelRemoved
 * @fires Client#channelUpdated
 * @fires Client#memberJoined
 * @fires Client#memberLeft
 * @fires Client#memberUpdated
 * @fires Client#messageAdded
 * @fires Client#messageRemoved
 * @fires Client#messageUpdated
 * @fires Client#pushNotification
 * @fires Client#tokenAboutToExpire
 * @fires Client#tokenExpired
 * @fires Client#typingEnded
 * @fires Client#typingStarted
 * @fires Client#userSubscribed
 * @fires Client#userUnsubscribed
 * @fires Client#userUpdated
 */
declare class Client extends EventEmitter {
    connectionState: Client.ConnectionState;
    private sessionPromise;
    private channelsPromise;
    private fpaToken;
    private config;
    private channels;
    private options;
    private services;
    static readonly version: string;
    readonly version: string;
    private static readonly supportedPushChannels;
    private static readonly supportedPushDataFields;
    /**
     * These options can be passed to Client constructor.
     * @typedef {Object} Client#ClientOptions
     * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
     *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
     */
    /**
     * These options can be passed to {@link Client#createChannel}.
     * @typedef {Object} Client#CreateChannelOptions
     * @property {Object} [attributes] - Any custom attributes to attach to the Channel
     * @property {String} [friendlyName] - The non-unique display name of the Channel
     * @property {Boolean} [isPrivate] - Whether or not this Channel should be visible to uninvited Clients
     * @property {String} [uniqueName] - The unique identity name of the Channel
     */
    /**
     * Connection state of Client.
     * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState
     */
    /**
     * Notifications channel type.
     * @typedef {('gcm'|'fcm'|'apn')} Client#NotificationsChannelType
     */
    /**
     * These options can be passed to {@link Client#getLocalChannels}.
     * @typedef {Object} Client#ChannelSortingOptions
     * @property {('lastMessage'|'friendlyName'|'uniqueName')} criteria - Sorting criteria for Channels array
     * @property {('ascending'|'descending')} [order] - Sorting order. If not present, then default is <code>ascending</code>
     */
    private constructor();
    /**
     * Factory method to create Chat client instance.
     *
     * @param {String} token - Access token
     * @param {Client#ClientOptions} options - Options to customize the Client
     * @returns {Promise<Client>}
     */
    static create(token: string, options?: Client.Options): Promise<Client>;
    get user(): User;
    get reachabilityEnabled(): boolean;
    get token(): string;
    private subscribeToPushNotifications;
    private unsubscribeFromPushNotifications;
    private initialize;
    /**
     * Gracefully shutting down library instance.
     * @public
     * @returns {Promise<void>}
     */
    shutdown(): Promise<void>;
    /**
     * Update the token used by the Client and re-register with Programmable Chat services.
     * @param {String} token - Access token
     * @public
     * @returns {Promise<Client>}
     */
    updateToken(token: string): Promise<Client>;
    /**
     * Get a known Channel by its SID.
     * @param {String} channelSid - Channel sid
     * @returns {Promise<Channel>}
     */
    getChannelBySid(channelSid: string): Promise<Channel>;
    /**
     * Get a known Channel by its unique identifier name.
     * @param {String} uniqueName - The unique identifier name of the Channel to get
     * @returns {Promise<Channel>}
     */
    getChannelByUniqueName(uniqueName: string): Promise<Channel>;
    /**
     * Get the current list of all subscribed Channels.
     * @returns {Promise<Paginator<Channel>>}
     */
    getSubscribedChannels(args?: any): Promise<Paginator<Channel>>;
    /**
     * Get array of Channels locally known to Client in provided sorting order.
     * Locally known channels are the ones created and/or joined during client runtime and currently logged in User subscribed Channels.
     * To ensure full list of subscribed Channels fetched - call the {@link Client#getSubscribedChannels} method
     * and fetch all pages with help of {@link Paginator#nextPage} method.
     * @param {Client#ChannelSortingOptions} [sortingOptions] - Options for the Channel sorting
     * @returns {Promise<Array<Channel>>}
     */
    getLocalChannels(sortingOptions?: Client.ChannelSortingOptions): Promise<Array<Channel>>;
    private static compareChannelsByLastMessage;
    private static compareChannelsByStringProperty;
    /**
     * Get the public channels directory content.
     * @returns {Promise<Paginator<ChannelDescriptor>>}
     */
    getPublicChannelDescriptors(): Promise<Paginator<ChannelDescriptor>>;
    /**
     * Get the User's (created by, joined or invited to) channels directory content.
     * @returns {Promise<Paginator<ChannelDescriptor>>}
     */
    getUserChannelDescriptors(): Promise<Paginator<ChannelDescriptor>>;
    /**
     * Create a Channel on the server and subscribe to its events.
     * Default options are public Channel type with empty uniqueName and friendlyName.
     * @param {Client#CreateChannelOptions} [options] - Options for the Channel
     * @returns {Promise<Channel>}
     */
    createChannel(options?: Client.CreateChannelOptions): Promise<Channel>;
    /**
     * Registers for push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported
     * @param {string} registrationId - Push notification id provided by platform
     * @returns {Promise<void>}
     */
    setPushRegistrationId(channelType: Client.NotificationsChannelType, registrationId: string): Promise<void>;
    /**
     * Unregisters from push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported
     * @returns {Promise<void>}
     */
    unsetPushRegistrationId(channelType: Client.NotificationsChannelType): Promise<void>;
    private static parsePushNotificationChatData;
    /**
     * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object
     * @param {Object} notificationPayload - Push notification payload
     * @returns {PushNotification|Error}
     */
    static parsePushNotification(notificationPayload: any): PushNotification;
    parsePushNotification: typeof Client.parsePushNotification;
    /**
     * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.
     * @param {Object} notificationPayload - Push notification payload
     * @returns {void|Error}
     */
    handlePushNotification(notificationPayload: any): Promise<void>;
    /**
     * Gets user for given identity, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the subscribed list.
     * @param {String} identity - Identity of User
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity: string): Promise<User>;
    /**
     * Gets user descriptor for given identity.
     * @param {String} identity - Identity of User
     * @returns {Promise<UserDescriptor>} User descriptor
     */
    getUserDescriptor(identity: string): Promise<UserDescriptor>;
    /**
     * @returns {Promise<Array<User>>} List of subscribed User objects
     */
    getSubscribedUsers(): Promise<Array<User>>;
}
export { User, Client, PushNotification };
export default Client;
/**
 * Fired when a Channel becomes visible to the Client.
 * Fired for created and not joined private channels and for all type of channels Client has joined or invited to.
 * @event Client#channelAdded
 * @type {Channel}
 */
/**
 * Fired when the Client is invited to a Channel.
 * @event Client#channelInvited
 * @type {Channel}
 */
/**
 * Fired when the Client joins a Channel.
 * @event Client#channelJoined
 * @type {Channel}
 */
/**
 * Fired when the Client leaves a Channel.
 * @event Client#channelLeft
 * @type {Channel}
 */
/**
 * Fired when a Channel is no longer visible to the Client.
 * @event Client#channelRemoved
 * @type {Channel}
 */
/**
 * Fired when a Channel's attributes or metadata have been updated.
 * During Channel's {@link Client.create| creation and initialization} this event might be fired multiple times
 * for same joined or created Channel as new data is arriving from different sources.
 * @event Client#channelUpdated
 * @type {Object}
 * @property {Channel} channel - Updated Channel
 * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons
 */
/**
 * Fired when Client's connection state has been changed.
 * @event Client#connectionStateChanged
 * @type {Client#ConnectionState}
 */
/**
 * Fired when a Member has joined the Channel.
 * @event Client#memberJoined
 * @type {Member}
 */
/**
 * Fired when a Member has left the Channel.
 * @event Client#memberLeft
 * @type {Member}
 */
/**
 * Fired when a Member's fields has been updated.
 * @event Client#memberUpdated
 * @type {Object}
 * @property {Member} member - Updated Member
 * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Channel on the server.
 * @event Client#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Channel's message list.
 * @event Client#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Client#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when token is about to expire and needs to be updated.
 * @event Client#tokenAboutToExpire
 * @type {void}
 */
/**
 * Fired when token is expired.
 * @event Client#tokenExpired
 * @type {void}
 */
/**
 * Fired when a Member has stopped typing.
 * @event Client#typingEnded
 * @type {Member}
 */
/**
 * Fired when a Member has started typing.
 * @event Client#typingStarted
 * @type {Member}
 */
/**
 * Fired when client received (and parsed) push notification via one of push channels (apn, gcm, fcm).
 * @event Client#pushNotification
 * @type {PushNotification}
 */
/**
 * Fired when the Client is subscribed to a User.
 * @event Client#userSubscribed
 * @type {User}
 */
/**
 * Fired when the Client is unsubscribed from a User.
 * @event Client#userUnsubscribed
 * @type {User}
 */
/**
 * Fired when the User's properties or reachability status have been updated.
 * @event Client#userUpdated
 * @type {Object}
 * @property {User} user - Updated User
 * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons
 */
/**
 * Fired when connection is interrupted by unexpected reason
 * @event Client#connectionError
 * @type {Object}
 * @property {Boolean} terminal - twilsock will stop connection attempts
 * @property {String} message - root cause
 * @property {Number} [httpStatusCode] - http status code if available
 * @property {Number} [errorCode] - Twilio public error code if available
 */
