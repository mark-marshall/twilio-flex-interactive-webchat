"use strict";

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _set = require("babel-runtime/core-js/set");

var _set2 = _interopRequireDefault(_set);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _isInteger = require("babel-runtime/core-js/number/is-integer");

var _isInteger2 = _interopRequireDefault(_isInteger);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var logger_1 = require("./logger");
var members_1 = require("./data/members");
var member_1 = require("./member");
var messages_1 = require("./data/messages");
var util_1 = require("./util");
var log = logger_1.Logger.scope('Channel');
var fieldMappings = {
    lastMessage: 'lastMessage',
    attributes: 'attributes',
    createdBy: 'createdBy',
    dateCreated: 'dateCreated',
    dateUpdated: 'dateUpdated',
    friendlyName: 'friendlyName',
    lastConsumedMessageIndex: 'lastConsumedMessageIndex',
    notificationLevel: 'notificationLevel',
    sid: 'sid',
    status: 'status',
    type: 'type',
    uniqueName: 'uniqueName',
    state: 'state'
};
function parseTime(timeString) {
    try {
        return new Date(timeString);
    } catch (e) {
        return null;
    }
}
function filterStatus(status) {
    switch (status) {
        case 'notParticipating':
            return 'known';
        default:
            return status;
    }
}
exports.filterStatus = filterStatus;
/**
 * @classdesc A Channel represents a remote channel of communication between multiple Programmable Chat Clients
 * @property {Object} attributes - The Channel's custom attributes
 * @property {String} createdBy - The identity of the User that created this Channel
 * @property {Date} dateCreated - The Date this Channel was created
 * @property {Date} dateUpdated - The Date this Channel was last updated
 * @property {String} friendlyName - The Channel's name
 * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)
 * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in this Channel
 * @property {Channel#LastMessage} lastMessage - Last Message sent to this Channel
 * @property {Channel#NotificationLevel} notificationLevel - User Notification level for this Channel
 * @property {String} sid - The Channel's unique system identifier
 * @property {Channel#State} state - The Channel's state
 * @property {Channel#Status} status - The Channel's status
 * @property {Channel#Type} type - The Channel's type
 * @property {String} uniqueName - The Channel's unique name (tag)
 * @fires Channel#memberJoined
 * @fires Channel#memberLeft
 * @fires Channel#memberUpdated
 * @fires Channel#messageAdded
 * @fires Channel#messageRemoved
 * @fires Channel#messageUpdated
 * @fires Channel#typingEnded
 * @fires Channel#typingStarted
 * @fires Channel#updated
 * @fires Channel#removed
 */

var Channel = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Channel, _events_1$EventEmitte);

    /**
     * These options can be passed to {@link Channel#sendMessage}.
     * @typedef {Object} Channel#SendMediaOptions
     * @property {String} contentType - content type of media
     * @property {String | Buffer} media - content to post
     */
    /**
     * The update reason for <code>updated</code> event emitted on Channel
     * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |
      'friendlyName' | 'lastConsumedMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' |
      'notificationLevel' )} Channel#UpdateReason
     */
    /**
     * The status of the Channel, relative to the Client: whether the Channel
     * is <code>known</code> to local Client, Client is <code>invited</code> to or
     * is <code>joined</code> to this Channel
     * @typedef {('unknown' | 'known' | 'invited' | 'joined')} Channel#Status
     */
    /**
     * The type of Channel (<code>public</code> or <code>private</code>).
     * @typedef {('public' | 'private')} Channel#Type
     */
    /**
     * The User's Notification level for Channel, determines whether the currently logged-in User will receive
     * pushes for events in this Channel. Can be either <code>muted</code> or <code>default</code>,
     * where <code>default</code> defers to global Service push configuration.
     * @typedef {('default' | 'muted')} Channel#NotificationLevel
     */
    /**
     * The Channel's state. Set to undefined if the channel is not a conversation.
     * @typedef {Object | undefined} Channel#State
     * @property {('active' | 'inactive' | 'closed')} current - the current state
     * @property {Date} dateUpdated - date at which the latest channel state update happened
     */
    function Channel(services, descriptor, sid) {
        (0, _classCallCheck3.default)(this, Channel);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Channel.__proto__ || (0, _getPrototypeOf2.default)(Channel)).call(this));

        var attributes = descriptor.attributes || {};
        var createdBy = descriptor.createdBy;
        var dateCreated = parseTime(descriptor.dateCreated);
        var dateUpdated = parseTime(descriptor.dateUpdated);
        var friendlyName = descriptor.friendlyName || null;
        var lastConsumedMessageIndex = (0, _isInteger2.default)(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;
        var uniqueName = descriptor.uniqueName || null;
        try {
            (0, _stringify2.default)(attributes);
        } catch (e) {
            throw new Error('Attributes must be a valid JSON object.');
        }
        _this.services = services;
        _this.sid = sid;
        _this.entityName = descriptor.channel;
        _this.channelState = {
            uniqueName: uniqueName,
            status: 'known',
            type: descriptor.type,
            attributes: attributes,
            createdBy: createdBy,
            dateCreated: dateCreated,
            dateUpdated: dateUpdated,
            friendlyName: friendlyName,
            lastConsumedMessageIndex: lastConsumedMessageIndex
        };
        if (descriptor.notificationLevel) {
            _this.channelState.notificationLevel = descriptor.notificationLevel;
        }
        _this.members = new _map2.default();
        _this.membersEntity = new members_1.Members(_this, _this.services, _this.members);
        _this.membersEntity.on('memberJoined', _this.emit.bind(_this, 'memberJoined'));
        _this.membersEntity.on('memberLeft', _this.emit.bind(_this, 'memberLeft'));
        _this.membersEntity.on('memberUpdated', function (args) {
            return _this.emit('memberUpdated', args);
        });
        _this.messagesEntity = new messages_1.Messages(_this, services);
        _this.messagesEntity.on('messageAdded', function (message) {
            return _this._onMessageAdded(message);
        });
        _this.messagesEntity.on('messageUpdated', function (args) {
            return _this.emit('messageUpdated', args);
        });
        _this.messagesEntity.on('messageRemoved', _this.emit.bind(_this, 'messageRemoved'));
        return _this;
    }

    (0, _createClass3.default)(Channel, [{
        key: "_subscribe",

        /**
         * The Channel's last message's information.
         * @typedef {Object} Channel#LastMessage
         * @property {Number} index - Message's index
         * @property {Date} timestamp - Message's creation timestamp
         */
        /**
         * Load and Subscribe to this Channel and do not subscribe to its Members and Messages.
         * This or _subscribeStreams will need to be called before any events on Channel will fire.
         * @returns {Promise}
         * @private
         */
        value: function _subscribe() {
            var _this2 = this;

            if (this.entityPromise) {
                return this.entityPromise;
            }
            return this.entityPromise = this.entityPromise || this.services.syncClient.document({ id: this.entityName, mode: 'open_existing' }).then(function (entity) {
                _this2.entity = entity;
                _this2.entity.on('updated', function (args) {
                    _this2._update(args.value);
                });
                _this2.entity.on('removed', function () {
                    return _this2.emit('removed', _this2);
                });
                _this2._update(_this2.entity.value);
                return entity;
            }).catch(function (err) {
                _this2.entity = null;
                _this2.entityPromise = null;
                if (_this2.services.syncClient.connectionState != 'disconnected') {
                    log.error('Failed to get channel object', err);
                }
                log.debug('ERROR: Failed to get channel object', err);
                throw err;
            });
        }
        /**
         * Load the attributes of this Channel and instantiate its Members and Messages.
         * This or _subscribe will need to be called before any events on Channel will fire.
         * This will need to be called before any events on Members or Messages will fire
         * @returns {Promise}
         * @private
         */

    }, {
        key: "_subscribeStreams",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var messagesObjectName, rosterObjectName;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.prev = 0;
                                _context.next = 3;
                                return this._subscribe();

                            case 3:
                                log.trace('_subscribeStreams, this.entity.value=', this.entity.value);
                                messagesObjectName = this.entity.value.messages;
                                rosterObjectName = this.entity.value.roster;
                                _context.next = 8;
                                return _promise2.default.all([this.messagesEntity.subscribe(messagesObjectName), this.membersEntity.subscribe(rosterObjectName)]);

                            case 8:
                                _context.next = 15;
                                break;

                            case 10:
                                _context.prev = 10;
                                _context.t0 = _context["catch"](0);

                                if (this.services.syncClient.connectionState !== 'disconnected') {
                                    log.error('Failed to subscribe on channel objects', this.sid, _context.t0);
                                }
                                log.debug('ERROR: Failed to subscribe on channel objects', this.sid, _context.t0);
                                throw _context.t0;

                            case 15:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this, [[0, 10]]);
            }));

            function _subscribeStreams() {
                return _ref.apply(this, arguments);
            }

            return _subscribeStreams;
        }()
        /**
         * Stop listening for and firing events on this Channel.
         * @returns {Promise}
         * @private
         */

    }, {
        key: "_unsubscribe",
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (!(this.isPrivate && this.entity)) {
                                    _context2.next = 5;
                                    break;
                                }

                                _context2.next = 3;
                                return this.entity.close();

                            case 3:
                                this.entity = null;
                                this.entityPromise = null;

                            case 5:
                                return _context2.abrupt("return", _promise2.default.all([this.membersEntity.unsubscribe(), this.messagesEntity.unsubscribe()]));

                            case 6:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function _unsubscribe() {
                return _ref2.apply(this, arguments);
            }

            return _unsubscribe;
        }()
        /**
         * Set channel status
         * @private
         */

    }, {
        key: "_setStatus",
        value: function _setStatus(status, source) {
            var _this3 = this;

            this.statusSource = source;
            if (this.channelState.status === status) {
                return;
            }
            this.channelState.status = status;
            if (status === 'joined') {
                this._subscribeStreams().catch(function (err) {
                    log.debug('ERROR while setting channel status ' + status, err);
                    if (_this3.services.syncClient.connectionState !== 'disconnected') {
                        throw err;
                    }
                });
            } else if (status === 'invited') {
                this._subscribe().catch(function (err) {
                    log.debug('ERROR while setting channel status ' + status, err);
                    if (_this3.services.syncClient.connectionState !== 'disconnected') {
                        throw err;
                    }
                });
            } else if (this.entityPromise) {
                this._unsubscribe().catch(function (err) {
                    log.debug('ERROR while setting channel status ' + status, err);
                    if (_this3.services.syncClient.connectionState !== 'disconnected') {
                        throw err;
                    }
                });
            }
        }
        /**
         * If channel's status update source
         * @private
         * @return {Channels.DataSource}
         */

    }, {
        key: "_statusSource",
        value: function _statusSource() {
            return this.statusSource;
        }
    }, {
        key: "_update",

        /**
         * Updates local channel object with new values
         * @private
         */
        value: function _update(update) {
            var _a, _b, _c, _d, _e;
            log.trace('_update', update);
            Channel.preprocessUpdate(update, this.sid);
            var updateReasons = new _set2.default();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(update)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var key = _step.value;

                    var localKey = fieldMappings[key];
                    if (!localKey) {
                        continue;
                    }
                    switch (localKey) {
                        case fieldMappings.status:
                            if (!update.status || update.status === 'unknown' || this.channelState.status === filterStatus(update.status)) {
                                break;
                            }
                            this.channelState.status = filterStatus(update.status);
                            updateReasons.add(localKey);
                            break;
                        case fieldMappings.attributes:
                            if (util_1.isDeepEqual(this.channelState.attributes, update.attributes)) {
                                break;
                            }
                            this.channelState.attributes = update.attributes;
                            updateReasons.add(localKey);
                            break;
                        case fieldMappings.lastConsumedMessageIndex:
                            if (update.lastConsumedMessageIndex === undefined || update.lastConsumedMessageIndex === this.channelState.lastConsumedMessageIndex) {
                                break;
                            }
                            this.channelState.lastConsumedMessageIndex = update.lastConsumedMessageIndex;
                            updateReasons.add(localKey);
                            break;
                        case fieldMappings.lastMessage:
                            if (this.channelState.lastMessage && !update.lastMessage) {
                                delete this.channelState.lastMessage;
                                updateReasons.add(localKey);
                                break;
                            }
                            this.channelState.lastMessage = this.channelState.lastMessage || {};
                            if (((_a = update.lastMessage) === null || _a === void 0 ? void 0 : _a.index) !== undefined && update.lastMessage.index !== this.channelState.lastMessage.index) {
                                this.channelState.lastMessage.index = update.lastMessage.index;
                                updateReasons.add(localKey);
                            }
                            if (((_b = update.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp) !== undefined && ((_d = (_c = this.channelState.lastMessage) === null || _c === void 0 ? void 0 : _c.timestamp) === null || _d === void 0 ? void 0 : _d.getTime()) !== update.lastMessage.timestamp.getTime()) {
                                this.channelState.lastMessage.timestamp = update.lastMessage.timestamp;
                                updateReasons.add(localKey);
                            }
                            if (util_1.isDeepEqual(this.channelState.lastMessage, {})) {
                                delete this.channelState.lastMessage;
                            }
                            break;
                        case fieldMappings.state:
                            var state = update.state || undefined;
                            if (state !== undefined) {
                                state.dateUpdated = new Date(state.dateUpdated);
                            }
                            if (util_1.isDeepEqual(this.channelState.state, state)) {
                                break;
                            }
                            this.channelState.state = state;
                            updateReasons.add(localKey);
                            break;
                        default:
                            var isDate = update[key] instanceof Date;
                            var keysMatchAsDates = isDate && ((_e = this.channelState[localKey]) === null || _e === void 0 ? void 0 : _e.getTime()) === update[key].getTime();
                            var keysMatchAsNonDates = !isDate && this[localKey] === update[key];
                            if (keysMatchAsDates || keysMatchAsNonDates) {
                                break;
                            }
                            this.channelState[localKey] = update[key];
                            updateReasons.add(localKey);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            if (updateReasons.size > 0) {
                this.emit('updated', { channel: this, updateReasons: [].concat((0, _toConsumableArray3.default)(updateReasons)) });
            }
        }
        /**
         * @private
         */

    }, {
        key: "_onMessageAdded",
        value: function _onMessageAdded(message) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = (0, _getIterator3.default)(this.members.values()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var member = _step2.value;

                    if (member.identity === message.author) {
                        member._endTyping();
                        break;
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            this.emit('messageAdded', message);
        }
        /**
         * Add a participant to the Channel by its Identity.
         * @param {String} identity - Identity of the Client to add
         * @returns {Promise<void|Error|SessionError>}
         */

    }, {
        key: "add",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(identity) {
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                if (!(!identity || typeof identity !== 'string')) {
                                    _context3.next = 2;
                                    break;
                                }

                                throw new Error('Channel.add requires an <String>identity parameter');

                            case 2:
                                return _context3.abrupt("return", this.membersEntity.add(identity));

                            case 3:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function add(_x) {
                return _ref3.apply(this, arguments);
            }

            return add;
        }()
        /**
         * Advance last consumed Channel's Message index to current consumption horizon.
         * Rejects if User is not Member of Channel.
         * Last consumed Message index is updated only if new index value is higher than previous.
         * @param {Number} index - Message index to advance to as last read
         * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
         */

    }, {
        key: "advanceLastConsumedMessageIndex",
        value: function () {
            var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(index) {
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                if ((0, _isInteger2.default)(index)) {
                                    _context4.next = 2;
                                    break;
                                }

                                throw new Error('Channel.advanceLastConsumedMessageIndex requires an integral <Number>index parameter');

                            case 2:
                                _context4.next = 4;
                                return this._subscribeStreams();

                            case 4:
                                return _context4.abrupt("return", this.services.consumptionHorizon.advanceLastConsumedMessageIndexForChannel(this.sid, index, this.lastConsumedMessageIndex));

                            case 5:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function advanceLastConsumedMessageIndex(_x2) {
                return _ref4.apply(this, arguments);
            }

            return advanceLastConsumedMessageIndex;
        }()
        /**
         * Decline an invitation to the Channel and unsubscribe from its events.
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "decline",
        value: function () {
            var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
                return _regenerator2.default.wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                _context5.next = 2;
                                return this.services.session.addCommand('declineInvitation', {
                                    channelSid: this.sid
                                });

                            case 2:
                                return _context5.abrupt("return", this);

                            case 3:
                            case "end":
                                return _context5.stop();
                        }
                    }
                }, _callee5, this);
            }));

            function decline() {
                return _ref5.apply(this, arguments);
            }

            return decline;
        }()
        /**
         * Delete the Channel and unsubscribe from its events.
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "delete",
        value: function () {
            var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
                return _regenerator2.default.wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                _context6.next = 2;
                                return this.services.session.addCommand('destroyChannel', {
                                    channelSid: this.sid
                                });

                            case 2:
                                return _context6.abrupt("return", this);

                            case 3:
                            case "end":
                                return _context6.stop();
                        }
                    }
                }, _callee6, this);
            }));

            function _delete() {
                return _ref6.apply(this, arguments);
            }

            return _delete;
        }()
        /**
         * Get the custom attributes of this Channel.<br/>
         *
         * <i>NOTE: {@link Channel}'s <code>attributes</code> property will be empty for public channels until this function is called.</i>
         * @returns {Promise<Object>}
         */

    }, {
        key: "getAttributes",
        value: function () {
            var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
                return _regenerator2.default.wrap(function _callee7$(_context7) {
                    while (1) {
                        switch (_context7.prev = _context7.next) {
                            case 0:
                                _context7.next = 2;
                                return this._subscribe();

                            case 2:
                                return _context7.abrupt("return", this.attributes);

                            case 3:
                            case "end":
                                return _context7.stop();
                        }
                    }
                }, _callee7, this);
            }));

            function getAttributes() {
                return _ref7.apply(this, arguments);
            }

            return getAttributes;
        }()
        /**
         * Returns messages from channel using paginator interface.
         * @param {Number} [pageSize=30] Number of messages to return in single chunk
         * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default
         * @param {String} [direction=backwards] - Query direction. By default it query backwards
         *                                         from newer to older. 'forward' will query in opposite direction
         * @returns {Promise<Paginator<Message>>} page of messages
         */

    }, {
        key: "getMessages",
        value: function () {
            var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(pageSize, anchor, direction) {
                return _regenerator2.default.wrap(function _callee8$(_context8) {
                    while (1) {
                        switch (_context8.prev = _context8.next) {
                            case 0:
                                if (!(typeof anchor !== 'undefined' && !(0, _isInteger2.default)(anchor))) {
                                    _context8.next = 2;
                                    break;
                                }

                                throw new Error('Anchor should be a valid message index');

                            case 2:
                                _context8.next = 4;
                                return this._subscribeStreams();

                            case 4:
                                return _context8.abrupt("return", this.messagesEntity.getMessages(pageSize, anchor, direction));

                            case 5:
                            case "end":
                                return _context8.stop();
                        }
                    }
                }, _callee8, this);
            }));

            function getMessages(_x3, _x4, _x5) {
                return _ref8.apply(this, arguments);
            }

            return getMessages;
        }()
        /**
         * Get a list of all Members joined to this Channel.
         * @returns {Promise<Array<Member>>}
         */

    }, {
        key: "getMembers",
        value: function () {
            var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
                return _regenerator2.default.wrap(function _callee9$(_context9) {
                    while (1) {
                        switch (_context9.prev = _context9.next) {
                            case 0:
                                _context9.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                return _context9.abrupt("return", this.membersEntity.getMembers());

                            case 3:
                            case "end":
                                return _context9.stop();
                        }
                    }
                }, _callee9, this);
            }));

            function getMembers() {
                return _ref9.apply(this, arguments);
            }

            return getMembers;
        }()
        /**
         * Get channel members count.
         * <br/>
         * This method is semi-realtime. This means that this data will be eventually correct,
         * but will also possibly be incorrect for a few seconds. The Chat system does not
         * provide real time events for counter values changes.
         * <br/>
         * So this is quite useful for any UI badges, but is not recommended
         * to build any core application logic based on these counters being accurate in real time.
         * @returns {Promise<number|Error>}
         */

    }, {
        key: "getMembersCount",
        value: function () {
            var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10() {
                var links, url, response;
                return _regenerator2.default.wrap(function _callee10$(_context10) {
                    while (1) {
                        switch (_context10.prev = _context10.next) {
                            case 0:
                                _context10.next = 2;
                                return this.services.session.getSessionLinks();

                            case 2:
                                links = _context10.sent;
                                url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();
                                _context10.next = 6;
                                return this.services.network.get(url);

                            case 6:
                                response = _context10.sent;
                                return _context10.abrupt("return", response.body.members_count);

                            case 8:
                            case "end":
                                return _context10.stop();
                        }
                    }
                }, _callee10, this);
            }));

            function getMembersCount() {
                return _ref10.apply(this, arguments);
            }

            return getMembersCount;
        }()
        /**
         * Get a Member by its SID.
         * @param {String} memberSid - Member sid
         * @returns {Promise<Member>}
         */

    }, {
        key: "getMemberBySid",
        value: function () {
            var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(memberSid) {
                return _regenerator2.default.wrap(function _callee11$(_context11) {
                    while (1) {
                        switch (_context11.prev = _context11.next) {
                            case 0:
                                if (!(!memberSid || typeof memberSid !== 'string')) {
                                    _context11.next = 2;
                                    break;
                                }

                                throw new Error('Channel.getMemberBySid requires a <String>memberSid parameter');

                            case 2:
                                return _context11.abrupt("return", this.membersEntity.getMemberBySid(memberSid));

                            case 3:
                            case "end":
                                return _context11.stop();
                        }
                    }
                }, _callee11, this);
            }));

            function getMemberBySid(_x6) {
                return _ref11.apply(this, arguments);
            }

            return getMemberBySid;
        }()
        /**
         * Get a Member by its identity.
         * @param {String} identity - Member identity
         * @returns {Promise<Member>}
         */

    }, {
        key: "getMemberByIdentity",
        value: function () {
            var _ref12 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee12(identity) {
                return _regenerator2.default.wrap(function _callee12$(_context12) {
                    while (1) {
                        switch (_context12.prev = _context12.next) {
                            case 0:
                                if (!(!identity || typeof identity !== 'string')) {
                                    _context12.next = 2;
                                    break;
                                }

                                throw new Error('Channel.getMemberByIdentity requires a <String>identity parameter');

                            case 2:
                                return _context12.abrupt("return", this.membersEntity.getMemberByIdentity(identity));

                            case 3:
                            case "end":
                                return _context12.stop();
                        }
                    }
                }, _callee12, this);
            }));

            function getMemberByIdentity(_x7) {
                return _ref12.apply(this, arguments);
            }

            return getMemberByIdentity;
        }()
        /**
         * Get total message count in a channel.
         * <br/>
         * This method is semi-realtime. This means that this data will be eventually correct,
         * but will also possibly be incorrect for a few seconds. The Chat system does not
         * provide real time events for counter values changes.
         * <br/>
         * So this is quite useful for any UI badges, but is not recommended
         * to build any core application logic based on these counters being accurate in real time.
         * @returns {Promise<number|Error>}
         */

    }, {
        key: "getMessagesCount",
        value: function () {
            var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee13() {
                var links, url, response;
                return _regenerator2.default.wrap(function _callee13$(_context13) {
                    while (1) {
                        switch (_context13.prev = _context13.next) {
                            case 0:
                                _context13.next = 2;
                                return this.services.session.getSessionLinks();

                            case 2:
                                links = _context13.sent;
                                url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();
                                _context13.next = 6;
                                return this.services.network.get(url);

                            case 6:
                                response = _context13.sent;
                                return _context13.abrupt("return", response.body.messages_count);

                            case 8:
                            case "end":
                                return _context13.stop();
                        }
                    }
                }, _callee13, this);
            }));

            function getMessagesCount() {
                return _ref13.apply(this, arguments);
            }

            return getMessagesCount;
        }()
        /**
         * Get unconsumed messages count for User if he is Member of this Channel.
         * Rejects if User is not Member of Channel.
         * <br/>
         * This method is semi-realtime. This means that this data will be eventually correct,
         * but will also possibly be incorrect for a few seconds. The Chat system does not
         * provide real time events for counter values changes.
         * <br/>
         * So this is quite useful for any “unread messages count” badges, but is not recommended
         * to build any core application logic based on these counters being accurate in real time.
         * @returns {Promise<number|Error>}
         */

    }, {
        key: "getUnconsumedMessagesCount",
        value: function () {
            var _ref14 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee14() {
                var links, url, response;
                return _regenerator2.default.wrap(function _callee14$(_context14) {
                    while (1) {
                        switch (_context14.prev = _context14.next) {
                            case 0:
                                _context14.next = 2;
                                return this.services.session.getSessionLinks();

                            case 2:
                                links = _context14.sent;
                                url = new util_1.UriBuilder(links.myChannelsUrl).arg('ChannelSid', this.sid).build();
                                _context14.next = 6;
                                return this.services.network.get(url);

                            case 6:
                                response = _context14.sent;

                                if (!(response.body.channels.length && response.body.channels[0].channel_sid == this.sid)) {
                                    _context14.next = 11;
                                    break;
                                }

                                if (!(typeof response.body.channels[0].unread_messages_count !== 'undefined' && response.body.channels[0].unread_messages_count != null)) {
                                    _context14.next = 10;
                                    break;
                                }

                                return _context14.abrupt("return", response.body.channels[0].unread_messages_count);

                            case 10:
                                return _context14.abrupt("return", null);

                            case 11:
                                throw new Error('Channel is not in user channels list');

                            case 12:
                            case "end":
                                return _context14.stop();
                        }
                    }
                }, _callee14, this);
            }));

            function getUnconsumedMessagesCount() {
                return _ref14.apply(this, arguments);
            }

            return getUnconsumedMessagesCount;
        }()
        /**
         * Invite a user to the Channel by their Identity.
         * @param {String} identity - Identity of the user to invite
         * @returns {Promise<void|Error|SessionError>}
         */

    }, {
        key: "invite",
        value: function () {
            var _ref15 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee15(identity) {
                return _regenerator2.default.wrap(function _callee15$(_context15) {
                    while (1) {
                        switch (_context15.prev = _context15.next) {
                            case 0:
                                if (!(typeof identity !== 'string' || !identity.length)) {
                                    _context15.next = 2;
                                    break;
                                }

                                throw new Error('Channel.invite requires an <String>identity parameter');

                            case 2:
                                _context15.next = 4;
                                return this.membersEntity.invite(identity);

                            case 4:
                            case "end":
                                return _context15.stop();
                        }
                    }
                }, _callee15, this);
            }));

            function invite(_x8) {
                return _ref15.apply(this, arguments);
            }

            return invite;
        }()
        /**
         * Join the Channel and subscribe to its events.
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "join",
        value: function () {
            var _ref16 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee16() {
                return _regenerator2.default.wrap(function _callee16$(_context16) {
                    while (1) {
                        switch (_context16.prev = _context16.next) {
                            case 0:
                                _context16.next = 2;
                                return this.services.session.addCommand('joinChannelV2', { channelSid: this.sid });

                            case 2:
                                return _context16.abrupt("return", this);

                            case 3:
                            case "end":
                                return _context16.stop();
                        }
                    }
                }, _callee16, this);
            }));

            function join() {
                return _ref16.apply(this, arguments);
            }

            return join;
        }()
        /**
         * Leave the Channel.
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "leave",
        value: function () {
            var _ref17 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee17() {
                return _regenerator2.default.wrap(function _callee17$(_context17) {
                    while (1) {
                        switch (_context17.prev = _context17.next) {
                            case 0:
                                if (!(this.channelState.status === 'joined')) {
                                    _context17.next = 3;
                                    break;
                                }

                                _context17.next = 3;
                                return this.services.session.addCommand('leaveChannel', { channelSid: this.sid });

                            case 3:
                                return _context17.abrupt("return", this);

                            case 4:
                            case "end":
                                return _context17.stop();
                        }
                    }
                }, _callee17, this);
            }));

            function leave() {
                return _ref17.apply(this, arguments);
            }

            return leave;
        }()
        /**
         * Remove a Member from the Channel.
         * @param {String} member - identity of member to remove
         * @returns {Promise<void|Error|SessionError>}
         */

    }, {
        key: "removeMember",
        value: function () {
            var _ref18 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee18(member) {
                return _regenerator2.default.wrap(function _callee18$(_context18) {
                    while (1) {
                        switch (_context18.prev = _context18.next) {
                            case 0:
                                if (!(!member || typeof member !== 'string' && !(member instanceof member_1.Member))) {
                                    _context18.next = 2;
                                    break;
                                }

                                throw new Error('Channel.removeMember requires a <String|Member>member parameter.');

                            case 2:
                                if (!(member instanceof member_1.Member)) {
                                    _context18.next = 7;
                                    break;
                                }

                                _context18.next = 5;
                                return this.membersEntity.removeBySid(member.sid);

                            case 5:
                                _context18.next = 9;
                                break;

                            case 7:
                                _context18.next = 9;
                                return this.membersEntity.removeByIdentity(member);

                            case 9:
                            case "end":
                                return _context18.stop();
                        }
                    }
                }, _callee18, this);
            }));

            function removeMember(_x9) {
                return _ref18.apply(this, arguments);
            }

            return removeMember;
        }()
        /**
         * Send a Message in the Channel.
         * @param {String | FormData | Channel#SendMediaOptions} message - The message body for text message,
         * FormData or MediaOptions for media content. Sending FormData supported only with browser engine
         * @param {Object} messageAttributes - attributes for the message
         * @returns {Promise<number|Error|SessionError>} new Message's index in the Channel's messages list
         */

    }, {
        key: "sendMessage",
        value: function () {
            var _ref19 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee19(message, messageAttributes) {
                var response, _response;

                return _regenerator2.default.wrap(function _callee19$(_context19) {
                    while (1) {
                        switch (_context19.prev = _context19.next) {
                            case 0:
                                if (!(typeof message === 'undefined')) {
                                    _context19.next = 2;
                                    break;
                                }

                                throw new Error('Message is required parameter');

                            case 2:
                                if (!(typeof message === 'string' || message === null)) {
                                    _context19.next = 9;
                                    break;
                                }

                                _context19.next = 5;
                                return this.messagesEntity.send(message, messageAttributes);

                            case 5:
                                response = _context19.sent;
                                return _context19.abrupt("return", util_1.parseToNumber(response.messageId));

                            case 9:
                                _context19.next = 11;
                                return this.messagesEntity.sendMedia(message, messageAttributes);

                            case 11:
                                _response = _context19.sent;
                                return _context19.abrupt("return", util_1.parseToNumber(_response.messageId));

                            case 13:
                            case "end":
                                return _context19.stop();
                        }
                    }
                }, _callee19, this);
            }));

            function sendMessage(_x10, _x11) {
                return _ref19.apply(this, arguments);
            }

            return sendMessage;
        }()
        /**
         * Set last consumed Channel's Message index to last known Message's index in this Channel.
         * @returns {Promise<number|SessionError>} resulting unread messages count in the channel
         */

    }, {
        key: "setAllMessagesConsumed",
        value: function () {
            var _ref20 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee20() {
                var messagesPage;
                return _regenerator2.default.wrap(function _callee20$(_context20) {
                    while (1) {
                        switch (_context20.prev = _context20.next) {
                            case 0:
                                _context20.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                _context20.next = 4;
                                return this.getMessages(1);

                            case 4:
                                messagesPage = _context20.sent;

                                if (!(messagesPage.items.length > 0)) {
                                    _context20.next = 7;
                                    break;
                                }

                                return _context20.abrupt("return", this.advanceLastConsumedMessageIndex(messagesPage.items[0].index));

                            case 7:
                                return _context20.abrupt("return", _promise2.default.resolve(0));

                            case 8:
                            case "end":
                                return _context20.stop();
                        }
                    }
                }, _callee20, this);
            }));

            function setAllMessagesConsumed() {
                return _ref20.apply(this, arguments);
            }

            return setAllMessagesConsumed;
        }()
        /**
         * Set all messages in the channel unread.
         * @returns {Promise<number|SessionError>} resulting unread messages count in the channel
         */

    }, {
        key: "setNoMessagesConsumed",
        value: function () {
            var _ref21 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee21() {
                return _regenerator2.default.wrap(function _callee21$(_context21) {
                    while (1) {
                        switch (_context21.prev = _context21.next) {
                            case 0:
                                _context21.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                return _context21.abrupt("return", this.services.consumptionHorizon.updateLastConsumedMessageIndexForChannel(this.sid, null));

                            case 3:
                            case "end":
                                return _context21.stop();
                        }
                    }
                }, _callee21, this);
            }));

            function setNoMessagesConsumed() {
                return _ref21.apply(this, arguments);
            }

            return setNoMessagesConsumed;
        }()
        /**
         * Set User Notification level for this channel.
         * @param {Channel#NotificationLevel} notificationLevel - The new user notification level
         * @returns {Promise<void|Error|SessionError>}
         */

    }, {
        key: "setUserNotificationLevel",
        value: function () {
            var _ref22 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee22(notificationLevel) {
                return _regenerator2.default.wrap(function _callee22$(_context22) {
                    while (1) {
                        switch (_context22.prev = _context22.next) {
                            case 0:
                                if (notificationLevel) {
                                    _context22.next = 2;
                                    break;
                                }

                                throw new Error('notificationLevel can\'t be null');

                            case 2:
                                _context22.next = 4;
                                return this.services.session.addCommand('editNotificationLevel', { channelSid: this.sid, notificationLevel: notificationLevel });

                            case 4:
                            case "end":
                                return _context22.stop();
                        }
                    }
                }, _callee22, this);
            }));

            function setUserNotificationLevel(_x12) {
                return _ref22.apply(this, arguments);
            }

            return setUserNotificationLevel;
        }()
        /**
         * Send a notification to the server indicating that this Client is currently typing in this Channel.
         * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.
         * @returns {Promise<void|SessionError>}
         */

    }, {
        key: "typing",
        value: function typing() {
            return this.services.typingIndicator.send(this.sid);
        }
        /**
         * Update the Channel's attributes.
         * @param {Object} attributes - The new attributes object
         * @returns {Promise<Channel|Error|SessionError>}
         */

    }, {
        key: "updateAttributes",
        value: function () {
            var _ref23 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee23(attributes) {
                return _regenerator2.default.wrap(function _callee23$(_context23) {
                    while (1) {
                        switch (_context23.prev = _context23.next) {
                            case 0:
                                if (!(typeof attributes === 'undefined')) {
                                    _context23.next = 4;
                                    break;
                                }

                                throw new Error('Attributes is required parameter');

                            case 4:
                                if (!(attributes === null)) {
                                    _context23.next = 8;
                                    break;
                                }

                                throw new Error('Attributes can\'t be null');

                            case 8:
                                if (!(attributes.constructor !== Object)) {
                                    _context23.next = 10;
                                    break;
                                }

                                throw new Error('Attributes must be a valid JSON object.');

                            case 10:
                                _context23.next = 12;
                                return this.services.session.addCommand('editAttributes', {
                                    channelSid: this.sid,
                                    attributes: (0, _stringify2.default)(attributes)
                                });

                            case 12:
                                return _context23.abrupt("return", this);

                            case 13:
                            case "end":
                                return _context23.stop();
                        }
                    }
                }, _callee23, this);
            }));

            function updateAttributes(_x13) {
                return _ref23.apply(this, arguments);
            }

            return updateAttributes;
        }()
        /**
         * Update the Channel's friendlyName.
         * @param {String} name - The new Channel friendlyName
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "updateFriendlyName",
        value: function () {
            var _ref24 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee24(name) {
                return _regenerator2.default.wrap(function _callee24$(_context24) {
                    while (1) {
                        switch (_context24.prev = _context24.next) {
                            case 0:
                                if (!(this.channelState.friendlyName !== name)) {
                                    _context24.next = 3;
                                    break;
                                }

                                _context24.next = 3;
                                return this.services.session.addCommand('editFriendlyName', {
                                    channelSid: this.sid,
                                    friendlyName: name
                                });

                            case 3:
                                return _context24.abrupt("return", this);

                            case 4:
                            case "end":
                                return _context24.stop();
                        }
                    }
                }, _callee24, this);
            }));

            function updateFriendlyName(_x14) {
                return _ref24.apply(this, arguments);
            }

            return updateFriendlyName;
        }()
        /**
         * Set last consumed Channel's Message index to current consumption horizon.
         * @param {Number|null} index - Message index to set as last read.
         * If null provided, then the behavior is identical to {@link Channel#setNoMessagesConsumed}
         * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
         */

    }, {
        key: "updateLastConsumedMessageIndex",
        value: function () {
            var _ref25 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee25(index) {
                return _regenerator2.default.wrap(function _callee25$(_context25) {
                    while (1) {
                        switch (_context25.prev = _context25.next) {
                            case 0:
                                if ((0, _isInteger2.default)(index) || index === null) {
                                    _context25.next = 2;
                                    break;
                                }

                                throw new Error('Incorrect argument "index": integer number or null expected');

                            case 2:
                                _context25.next = 4;
                                return this._subscribeStreams();

                            case 4:
                                return _context25.abrupt("return", this.services.consumptionHorizon.updateLastConsumedMessageIndexForChannel(this.sid, index));

                            case 5:
                            case "end":
                                return _context25.stop();
                        }
                    }
                }, _callee25, this);
            }));

            function updateLastConsumedMessageIndex(_x15) {
                return _ref25.apply(this, arguments);
            }

            return updateLastConsumedMessageIndex;
        }()
        /**
         * Update the Channel's unique name.
         * @param {String} uniqueName - The new Channel uniqueName
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "updateUniqueName",
        value: function () {
            var _ref26 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee26(uniqueName) {
                return _regenerator2.default.wrap(function _callee26$(_context26) {
                    while (1) {
                        switch (_context26.prev = _context26.next) {
                            case 0:
                                if (!(this.channelState.uniqueName !== uniqueName)) {
                                    _context26.next = 4;
                                    break;
                                }

                                if (!uniqueName) {
                                    uniqueName = '';
                                }
                                _context26.next = 4;
                                return this.services.session.addCommand('editUniqueName', {
                                    channelSid: this.sid,
                                    uniqueName: uniqueName
                                });

                            case 4:
                                return _context26.abrupt("return", this);

                            case 5:
                            case "end":
                                return _context26.stop();
                        }
                    }
                }, _callee26, this);
            }));

            function updateUniqueName(_x16) {
                return _ref26.apply(this, arguments);
            }

            return updateUniqueName;
        }()
        /**
         * Gets User Descriptors for this channel.
         * @returns {Promise<Paginator<UserDescriptor>>}
         */

    }, {
        key: "getUserDescriptors",
        value: function () {
            var _ref27 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee27() {
                return _regenerator2.default.wrap(function _callee27$(_context27) {
                    while (1) {
                        switch (_context27.prev = _context27.next) {
                            case 0:
                                return _context27.abrupt("return", this.services.users.getChannelUserDescriptors(this.sid));

                            case 1:
                            case "end":
                                return _context27.stop();
                        }
                    }
                }, _callee27, this);
            }));

            function getUserDescriptors() {
                return _ref27.apply(this, arguments);
            }

            return getUserDescriptors;
        }()
    }, {
        key: "status",
        get: function get() {
            return this.channelState.status;
        }
    }, {
        key: "type",
        get: function get() {
            return this.channelState.type;
        }
    }, {
        key: "uniqueName",
        get: function get() {
            return this.channelState.uniqueName;
        }
    }, {
        key: "isPrivate",
        get: function get() {
            return this.channelState.type === 'private';
        }
    }, {
        key: "friendlyName",
        get: function get() {
            return this.channelState.friendlyName;
        }
    }, {
        key: "dateUpdated",
        get: function get() {
            return this.channelState.dateUpdated;
        }
    }, {
        key: "dateCreated",
        get: function get() {
            return this.channelState.dateCreated;
        }
    }, {
        key: "createdBy",
        get: function get() {
            return this.channelState.createdBy;
        }
    }, {
        key: "attributes",
        get: function get() {
            return this.channelState.attributes;
        }
    }, {
        key: "lastConsumedMessageIndex",
        get: function get() {
            return this.channelState.lastConsumedMessageIndex;
        }
    }, {
        key: "lastMessage",
        get: function get() {
            return this.channelState.lastMessage;
        }
    }, {
        key: "notificationLevel",
        get: function get() {
            return this.channelState.notificationLevel;
        }
    }, {
        key: "state",
        get: function get() {
            return this.channelState.state;
        }
    }], [{
        key: "preprocessUpdate",
        value: function preprocessUpdate(update, channelSid) {
            try {
                if (typeof update.attributes === 'string') {
                    update.attributes = JSON.parse(update.attributes);
                } else if (update.attributes) {
                    (0, _stringify2.default)(update.attributes);
                }
            } catch (e) {
                log.warn('Retrieved malformed attributes from the server for channel: ' + channelSid);
                update.attributes = {};
            }
            try {
                if (update.dateCreated) {
                    update.dateCreated = new Date(update.dateCreated);
                }
            } catch (e) {
                log.warn('Retrieved malformed dateCreated from the server for channel: ' + channelSid);
                delete update.dateCreated;
            }
            try {
                if (update.dateUpdated) {
                    update.dateUpdated = new Date(update.dateUpdated);
                }
            } catch (e) {
                log.warn('Retrieved malformed dateUpdated from the server for channel: ' + channelSid);
                delete update.dateUpdated;
            }
            try {
                if (update.lastMessage && update.lastMessage.timestamp) {
                    update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);
                }
            } catch (e) {
                log.warn('Retrieved malformed lastMessage.timestamp from the server for channel: ' + channelSid);
                delete update.lastMessage.timestamp;
            }
        }
    }]);
    return Channel;
}(events_1.EventEmitter);

exports.Channel = Channel;
/**
 * Fired when a Member has joined the Channel.
 * @event Channel#memberJoined
 * @type {Member}
 */
/**
 * Fired when a Member has left the Channel.
 * @event Channel#memberLeft
 * @type {Member}
 */
/**
 * Fired when a Member's fields has been updated.
 * @event Channel#memberUpdated
 * @type {Object}
 * @property {Member} member - Updated Member
 * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Channel.
 * @event Channel#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Channel's message list.
 * @event Channel#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Channel#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when a Member has stopped typing.
 * @event Channel#typingEnded
 * @type {Member}
 */
/**
 * Fired when a Member has started typing.
 * @event Channel#typingStarted
 * @type {Member}
 */
/**
 * Fired when a Channel's attributes or metadata have been updated.
 * During Channel's {@link Client.create | creation and initialization} this event might be fired multiple times
 * for same joined or created Channel as new data is arriving from different sources.
 * @event Channel#updated
 * @type {Object}
 * @property {Channel} channel - Updated Channel
 * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons
 */
/**
 * Fired when the Channel was destroyed or currently logged in User has left private Channel
 * @event Channel#removed
 * @type {Channel}
 */