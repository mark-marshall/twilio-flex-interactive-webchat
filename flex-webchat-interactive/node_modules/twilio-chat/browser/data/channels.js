"use strict";

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _set = require("babel-runtime/core-js/set");

var _set2 = _interopRequireDefault(_set);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var logger_1 = require("../logger");
var channel_1 = require("../channel");
exports.Channel = channel_1.Channel;
var deferred_1 = require("../util/deferred");
var util_1 = require("../util");
var log = logger_1.Logger.scope('Channels');
/**
 * Represents channels collection
 * {@see Channel}
 */

var Channels = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Channels, _events_1$EventEmitte);

    function Channels(services) {
        (0, _classCallCheck3.default)(this, Channels);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Channels.__proto__ || (0, _getPrototypeOf2.default)(Channels)).call(this));

        _this.services = services;
        _this.channels = new _map2.default();
        _this.thumbstones = new _set2.default();
        _this.syncListFetched = false;
        _this.syncListRead = new deferred_1.Deferred();
        return _this;
    }

    (0, _createClass3.default)(Channels, [{
        key: "getMap",
        value: function getMap() {
            var _this2 = this;

            return this.services.session.getMyChannelsId().then(function (name) {
                return _this2.services.syncClient.map({ id: name, mode: 'open_existing' });
            });
        }
        /**
         * Add channel to server
         * @private
         * @returns {Promise<Channel|SessionError>} Channel
         */

    }, {
        key: "addChannel",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(options) {
                var attributes, response, channelSid, channelDocument, existingChannel, channel;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                attributes = void 0;

                                if (typeof options.attributes === 'undefined') {
                                    attributes = {};
                                } else {
                                    attributes = options.attributes;
                                }

                                if (!(attributes === null)) {
                                    _context.next = 4;
                                    break;
                                }

                                throw new Error('Attributes can\'t be null');

                            case 4:
                                if (!(attributes.constructor !== Object)) {
                                    _context.next = 6;
                                    break;
                                }

                                throw new Error('Attributes must be a valid JSON object');

                            case 6:
                                _context.next = 8;
                                return this.services.session.addCommand('createChannel', {
                                    friendlyName: options.friendlyName,
                                    uniqueName: options.uniqueName,
                                    type: options.isPrivate ? 'private' : 'public',
                                    attributes: (0, _stringify2.default)(attributes)
                                });

                            case 8:
                                response = _context.sent;
                                channelSid = 'channelSid' in response ? response['channelSid'] : null;
                                channelDocument = 'channel' in response ? response['channel'] : null;
                                existingChannel = this.channels.get(channelSid);

                                if (!existingChannel) {
                                    _context.next = 16;
                                    break;
                                }

                                _context.next = 15;
                                return existingChannel._subscribe();

                            case 15:
                                return _context.abrupt("return", existingChannel);

                            case 16:
                                channel = new channel_1.Channel(this.services, {
                                    channel: channelDocument,
                                    entityName: null,
                                    uniqueName: null,
                                    attributes: null,
                                    createdBy: null,
                                    friendlyName: null,
                                    lastConsumedMessageIndex: null,
                                    type: options.isPrivate ? 'private' : 'public',
                                    dateCreated: null,
                                    dateUpdated: null
                                }, channelSid);

                                this.channels.set(channel.sid, channel);
                                this.registerForEvents(channel);
                                _context.next = 21;
                                return channel._subscribe();

                            case 21:
                                this.emit('channelAdded', channel);
                                return _context.abrupt("return", channel);

                            case 23:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function addChannel(_x) {
                return _ref.apply(this, arguments);
            }

            return addChannel;
        }()
        /**
         * Fetch channels list and instantiate all necessary objects
         */

    }, {
        key: "fetchChannels",
        value: function fetchChannels() {
            var _this3 = this;

            this.getMap().then(function () {
                var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(map) {
                    var upserts, paginator, items;
                    return _regenerator2.default.wrap(function _callee2$(_context2) {
                        while (1) {
                            switch (_context2.prev = _context2.next) {
                                case 0:
                                    map.on('itemAdded', function (args) {
                                        log.debug('itemAdded: ' + args.item.key);
                                        _this3.upsertChannel('sync', args.item.key, args.item.value);
                                    });
                                    map.on('itemRemoved', function (args) {
                                        log.debug('itemRemoved: ' + args.key);
                                        var sid = args.key;
                                        if (!_this3.syncListFetched) {
                                            _this3.thumbstones.add(sid);
                                        }
                                        var channel = _this3.channels.get(sid);
                                        if (channel) {
                                            if (channel.status === 'joined' || channel.status === 'invited') {
                                                channel._setStatus('known', 'sync');
                                                _this3.emit('channelLeft', channel);
                                            }
                                            if (channel.isPrivate) {
                                                _this3.channels.delete(sid);
                                                _this3.emit('channelRemoved', channel);
                                                channel.emit('removed', channel);
                                            }
                                        }
                                    });
                                    map.on('itemUpdated', function (args) {
                                        log.debug('itemUpdated: ' + args.item.key);
                                        _this3.upsertChannel('sync', args.item.key, args.item.value);
                                    });
                                    upserts = [];
                                    _context2.next = 6;
                                    return _this3.services.syncList.getPage();

                                case 6:
                                    paginator = _context2.sent;
                                    items = paginator.items;

                                    items.forEach(function (item) {
                                        upserts.push(_this3.upsertChannel('synclist', item.channel_sid, item));
                                    });

                                case 9:
                                    if (!paginator.hasNextPage) {
                                        _context2.next = 16;
                                        break;
                                    }

                                    _context2.next = 12;
                                    return paginator.nextPage();

                                case 12:
                                    paginator = _context2.sent;

                                    paginator.items.forEach(function (item) {
                                        upserts.push(_this3.upsertChannel('synclist', item.channel_sid, item));
                                    });
                                    _context2.next = 9;
                                    break;

                                case 16:
                                    _this3.syncListRead.set(true);
                                    return _context2.abrupt("return", _promise2.default.all(upserts));

                                case 18:
                                case "end":
                                    return _context2.stop();
                            }
                        }
                    }, _callee2, _this3);
                }));

                return function (_x2) {
                    return _ref2.apply(this, arguments);
                };
            }()).then(function () {
                _this3.syncListFetched = true;
                _this3.thumbstones.clear();
                log.debug('Channels list fetched');
            }).then(function () {
                return _this3;
            }).catch(function (e) {
                if (_this3.services.syncClient.connectionState != 'disconnected') {
                    log.error('Failed to get channels list', e);
                }
                log.debug('ERROR: Failed to get channels list', e);
                throw e;
            });
        }
    }, {
        key: "_wrapPaginator",
        value: function _wrapPaginator(page, op) {
            var _this4 = this;

            return op(page.items).then(function (items) {
                return {
                    items: items,
                    hasNextPage: page.hasNextPage,
                    hasPrevPage: page.hasPrevPage,
                    nextPage: function nextPage() {
                        return page.nextPage().then(function (x) {
                            return _this4._wrapPaginator(x, op);
                        });
                    },
                    prevPage: function prevPage() {
                        return page.prevPage().then(function (x) {
                            return _this4._wrapPaginator(x, op);
                        });
                    }
                };
            });
        }
    }, {
        key: "getChannels",
        value: function getChannels(args) {
            var _this5 = this;

            return this.getMap().then(function (channelsMap) {
                return channelsMap.getItems(args);
            }).then(function (page) {
                return _this5._wrapPaginator(page, function (items) {
                    return _promise2.default.all(items.map(function (item) {
                        return _this5.upsertChannel('sync', item.key, item.value);
                    }));
                });
            });
        }
    }, {
        key: "getChannel",
        value: function getChannel(sid) {
            var _this6 = this;

            return this.getMap().then(function (channelsMap) {
                return channelsMap.getItems({ key: sid });
            }).then(function (page) {
                return page.items.map(function (item) {
                    return _this6.upsertChannel('sync', item.key, item.value);
                });
            }).then(function (items) {
                return items.length > 0 ? items[0] : null;
            });
        }
    }, {
        key: "pushChannel",
        value: function pushChannel(descriptor) {
            var sid = descriptor.sid;
            var data = {
                entityName: null,
                lastConsumedMessageIndex: descriptor.lastConsumedMessageIndex,
                type: descriptor.type,
                status: descriptor.status,
                friendlyName: descriptor.friendlyName,
                dateUpdated: descriptor.dateUpdated,
                dateCreated: descriptor.dateCreated,
                uniqueName: descriptor.uniqueName,
                createdBy: descriptor.createdBy,
                attributes: descriptor.attributes,
                channel: descriptor.channel,
                notificationLevel: descriptor.notificationLevel,
                sid: sid
            };
            return this.upsertChannel('chat', sid, data);
        }
    }, {
        key: "upsertChannel",
        value: function upsertChannel(source, sid, data) {
            var _this7 = this;

            log.trace('upsertChannel(sid=' + sid + ', data=', data);
            var channel = this.channels.get(sid);
            // Update the Channel's status if we know about it
            if (channel) {
                log.trace('upsertChannel: channel ' + sid + ' is known and it\'s' + ' status is known from source ' + channel._statusSource() + ' and update came from source ' + source, channel);
                if (typeof channel._statusSource() === 'undefined' || source === channel._statusSource() || source === 'synclist' && channel._statusSource() !== 'sync' || source === 'sync') {
                    if (data.status === 'joined' && channel.status !== 'joined') {
                        channel._setStatus('joined', source);
                        var updateData = {};
                        if (typeof data.notificationLevel !== 'undefined') {
                            updateData.notificationLevel = data.notificationLevel;
                        }
                        if (typeof data.lastConsumedMessageIndex !== 'undefined') {
                            updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;
                        }
                        if (!util_1.isDeepEqual(updateData, {})) {
                            channel._update(updateData);
                        }
                        channel._subscribe().then(function () {
                            _this7.emit('channelJoined', channel);
                        });
                    } else if (data.status === 'invited' && channel.status !== 'invited') {
                        channel._setStatus('invited', source);
                        var _updateData = {};
                        if (typeof data.notificationLevel !== 'undefined') {
                            _updateData.notificationLevel = data.notificationLevel;
                        }
                        if (typeof data.lastConsumedMessageIndex !== 'undefined') {
                            _updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;
                        }
                        if (!util_1.isDeepEqual(_updateData, {})) {
                            channel._update(_updateData);
                        }
                        channel._subscribe().then(function () {
                            _this7.emit('channelInvited', channel);
                        });
                    } else if (data.status === 'known' && (channel.status === 'invited' || channel.status === 'joined')) {
                        channel._setStatus('known', source);
                        channel._update(data);
                        channel._subscribe().then(function () {
                            _this7.emit('channelLeft', channel);
                        });
                    } else if ((data.status === 'notParticipating' || data.status === 'known') && data.type === 'private') {
                        channel._subscribe();
                    } else {
                        channel._update(data);
                    }
                } else {
                    log.trace('upsertChannel: channel is known from sync and came from chat, ignoring', {
                        sid: sid,
                        data: data.status,
                        channel: channel.status
                    });
                }
                return channel._subscribe().then(function () {
                    return channel;
                });
            }
            if ((source === 'chat' || source === 'synclist') && this.thumbstones.has(sid)) {
                // if channel was deleted, we ignore it
                log.trace('upsertChannel: channel is deleted and came again from chat, ignoring', sid);
                return;
            }
            // Fetch the Channel if we don't know about it
            log.trace('upsertChannel: creating local channel object with sid ' + sid, data);
            channel = new channel_1.Channel(this.services, data, sid);
            this.channels.set(sid, channel);
            return channel._subscribe().then(function () {
                _this7.registerForEvents(channel);
                _this7.emit('channelAdded', channel);
                if (data.status === 'joined') {
                    channel._setStatus('joined', source);
                    _this7.emit('channelJoined', channel);
                } else if (data.status === 'invited') {
                    channel._setStatus('invited', source);
                    _this7.emit('channelInvited', channel);
                }
                return channel;
            });
        }
    }, {
        key: "onChannelRemoved",
        value: function onChannelRemoved(sid) {
            var channel = this.channels.get(sid);
            if (channel) {
                this.channels.delete(sid);
                this.emit('channelRemoved', channel);
            }
        }
    }, {
        key: "registerForEvents",
        value: function registerForEvents(channel) {
            var _this8 = this;

            channel.on('removed', function () {
                return _this8.onChannelRemoved(channel.sid);
            });
            channel.on('updated', function (args) {
                return _this8.emit('channelUpdated', args);
            });
            channel.on('memberJoined', this.emit.bind(this, 'memberJoined'));
            channel.on('memberLeft', this.emit.bind(this, 'memberLeft'));
            channel.on('memberUpdated', function (args) {
                return _this8.emit('memberUpdated', args);
            });
            channel.on('messageAdded', this.emit.bind(this, 'messageAdded'));
            channel.on('messageUpdated', function (args) {
                return _this8.emit('messageUpdated', args);
            });
            channel.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
            channel.on('typingStarted', this.emit.bind(this, 'typingStarted'));
            channel.on('typingEnded', this.emit.bind(this, 'typingEnded'));
        }
    }]);
    return Channels;
}(events_1.EventEmitter);

exports.Channels = Channels;