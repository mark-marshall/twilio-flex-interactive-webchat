"use strict";

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = require("../logger");
var notificationtypes_1 = require("../interfaces/notificationtypes");
var log = logger_1.Logger.scope('TypingIndicator');
/**
 * An important note in regards to typing timeout timers. There are two places that the SDK can get the "typing_timeout" attribute from. The first
 * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the
 * "typing_timeout" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a
 * notification of type "twilio.ipmsg.typing_indicator". In this case, the "typing_timeout" value will be +1 of that in the console. This
 * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,
 * the timeout returned from the notification should be used as the timeout for the "typingEnded" event, +1 is to account for latency.
 *
 * @private
 */
/**
 * @class TypingIndicator
 *
 * @constructor
 * @private
 */

var TypingIndicator = function () {
    function TypingIndicator(config, services, getChannel) {
        (0, _classCallCheck3.default)(this, TypingIndicator);

        this.config = config;
        this.services = services;
        this.getChannel = getChannel;
        this.serviceTypingTimeout = null;
        this.sentUpdates = new _map2.default();
    }

    (0, _createClass3.default)(TypingIndicator, [{
        key: "initialize",

        /**
         * Initialize TypingIndicator controller
         * Registers for needed message types and sets listeners
         * @private
         */
        value: function initialize() {
            var _this = this;

            this.services.notificationClient.subscribe(notificationtypes_1.NotificationTypes.TYPING_INDICATOR, 'twilsock');
            this.services.notificationClient.on('message', function (type, message) {
                if (type === notificationtypes_1.NotificationTypes.TYPING_INDICATOR) {
                    _this.handleRemoteTyping(message);
                }
            });
        }
        /**
         * Remote members typing events handler
         * @private
         */

    }, {
        key: "handleRemoteTyping",
        value: function handleRemoteTyping(message) {
            var _this2 = this;

            log.trace('Got new typing indicator ', message);
            this.getChannel(message.channel_sid).then(function (channel) {
                if (!channel) {
                    return;
                }
                channel.members.forEach(function (member) {
                    if (member.identity !== message.identity) {
                        return;
                    }
                    var timeout = _this2.config.typingIndicatorTimeoutOverride + 1000 || message.typing_timeout * 1000;
                    member._startTyping(timeout);
                });
            }).catch(function (err) {
                log.error(err);
                throw err;
            });
        }
        /**
         * Send typing event for the given channel sid
         * @param {String} channelSid
         */

    }, {
        key: "send",
        value: function send(channelSid) {
            var lastUpdate = this.sentUpdates.get(channelSid);
            if (lastUpdate && lastUpdate > Date.now() - this.typingTimeout) {
                return _promise2.default.resolve();
            }
            this.sentUpdates.set(channelSid, Date.now());
            return this._send(channelSid);
        }
    }, {
        key: "_send",
        value: function _send(channelSid) {
            var _this3 = this;

            log.trace('Sending typing indicator');
            var url = this.config.typingIndicatorUri;
            var headers = {
                'Content-Type': 'application/x-www-form-urlencoded'
            };
            var body = 'ChannelSid=' + channelSid;
            return this.services.transport.post(url, headers, body).then(function (response) {
                if (response.body.hasOwnProperty('typing_timeout')) {
                    _this3.serviceTypingTimeout = response.body.typing_timeout * 1000;
                }
            }).catch(function (err) {
                log.error('Failed to send typing indicator:', err);
                throw err;
            });
        }
    }, {
        key: "typingTimeout",
        get: function get() {
            return this.config.typingIndicatorTimeoutOverride || this.serviceTypingTimeout || this.config.typingIndicatorTimeoutDefault;
        }
    }]);
    return TypingIndicator;
}();

exports.TypingIndicator = TypingIndicator;