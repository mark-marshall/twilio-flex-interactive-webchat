"use strict";

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var logger_1 = require("./logger");
var util_1 = require("./util");
var log = logger_1.Logger.scope('User');
/**
 * @classdesc Extended user information.
 * Note that <code>online</code> and <code>notifiable</code> properties are eligible
 * to use only if reachability function is enabled.
 * You may check if it is enabled by reading value of {@link Client}'s <code>reachabilityEnabled</code> property.
 *
 * @property {String} identity - User identity
 * @property {String} friendlyName - User friendly name, null if not set
 * @property {Object} attributes - Object with custom attributes for user
 * @property {Boolean} online - User real-time channel connection status
 * @property {Boolean} notifiable - User push notification registration status
 *
 * @fires User#updated
 * @fires User#userSubscribed
 * @fires User#userUnsubscribed
 *
 * @constructor
 * @param {String} identity - Identity of user
 * @param {String} entityId - id of user's object
 * @param {Object} datasync - datasync service
 * @param {Object} session - session service
 */

var User = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(User, _events_1$EventEmitte);

    /**
     * The update reason for <code>updated</code> event emitted on User
     * @typedef {('friendlyName' | 'attributes' | 'online' | 'notifiable')} User#UpdateReason
     */
    function User(identity, entityName, services) {
        (0, _classCallCheck3.default)(this, User);

        var _this = (0, _possibleConstructorReturn3.default)(this, (User.__proto__ || (0, _getPrototypeOf2.default)(User)).call(this));

        _this.subscribed = 'initializing';
        _this.setMaxListeners(0);
        _this.services = services;
        _this.state = {
            identity: identity,
            entityName: entityName,
            friendlyName: null,
            attributes: {},
            online: null,
            notifiable: null
        };
        return _this;
    }

    (0, _createClass3.default)(User, [{
        key: "_update",

        // Handles service updates
        value: function _update(key, value) {
            var updateReasons = [];
            log.debug('User for', this.state.identity, 'updated:', key, value);
            switch (key) {
                case 'friendlyName':
                    if (this.state.friendlyName !== value.value) {
                        updateReasons.push('friendlyName');
                        this.state.friendlyName = value.value;
                    }
                    break;
                case 'attributes':
                    var updateAttributes = {};
                    try {
                        updateAttributes = JSON.parse(value.value);
                    } catch (e) {
                        log.warn('Retrieved malformed attributes from the server for user: ' + this.state.identity);
                    }
                    if (!util_1.isDeepEqual(this.state.attributes, updateAttributes)) {
                        this.state.attributes = updateAttributes;
                        updateReasons.push('attributes');
                    }
                    break;
                case 'reachability':
                    if (this.state.online !== value.online) {
                        this.state.online = value.online;
                        updateReasons.push('online');
                    }
                    if (this.state.notifiable !== value.notifiable) {
                        this.state.notifiable = value.notifiable;
                        updateReasons.push('notifiable');
                    }
                    break;
                default:
                    return;
            }
            if (updateReasons.length > 0) {
                this.emit('updated', { user: this, updateReasons: updateReasons });
            }
        }
        // Fetch reachability info

    }, {
        key: "_updateReachabilityInfo",
        value: function _updateReachabilityInfo(map, update) {
            var _this2 = this;

            if (!this.services.session.reachabilityEnabled) {
                return _promise2.default.resolve();
            }
            return map.get('reachability').then(update).catch(function (err) {
                log.warn('Failed to get reachability info for ', _this2.state.identity, err);
            });
        }
        // Fetch user

    }, {
        key: "_fetch",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var _this3 = this;

                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                if (this.state.entityName) {
                                    _context.next = 2;
                                    break;
                                }

                                return _context.abrupt("return", this);

                            case 2:
                                this.promiseToFetch = this.services.syncClient.map({ id: this.state.entityName, mode: 'open_existing', includeItems: true }).then(function (map) {
                                    _this3.entity = map;
                                    map.on('itemUpdated', function (args) {
                                        log.debug(_this3.state.entityName + ' (' + _this3.state.identity + ') itemUpdated: ' + args.item.key);
                                        return _this3._update(args.item.key, args.item.value);
                                    });
                                    return _promise2.default.all([map.get('friendlyName').then(function (item) {
                                        return _this3._update(item.key, item.value);
                                    }), map.get('attributes').then(function (item) {
                                        return _this3._update(item.key, item.value);
                                    }), _this3._updateReachabilityInfo(map, function (item) {
                                        return _this3._update(item.key, item.value);
                                    })]);
                                }).then(function () {
                                    log.debug('Fetched for', _this3.identity);
                                    _this3.subscribed = 'subscribed';
                                    _this3.emit('userSubscribed', _this3);
                                    return _this3;
                                }).catch(function (err) {
                                    _this3.promiseToFetch = null;
                                    throw err;
                                });
                                return _context.abrupt("return", this.promiseToFetch);

                            case 4:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function _fetch() {
                return _ref.apply(this, arguments);
            }

            return _fetch;
        }()
    }, {
        key: "_ensureFetched",
        value: function _ensureFetched() {
            return this.promiseToFetch || this._fetch();
        }
        /**
         * Updates user attributes.
         * @param {Object} attributes - Updated attributes
         * @returns {Promise<User|Error|SessionError>}
         */

    }, {
        key: "updateAttributes",
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(attributes) {
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (!(typeof attributes === 'undefined')) {
                                    _context2.next = 4;
                                    break;
                                }

                                throw new Error('Attributes is required parameter');

                            case 4:
                                if (!(attributes === null)) {
                                    _context2.next = 8;
                                    break;
                                }

                                throw new Error('Attributes can\'t be null');

                            case 8:
                                if (!(attributes.constructor !== Object)) {
                                    _context2.next = 10;
                                    break;
                                }

                                throw new Error('Attributes must be a valid JSON object');

                            case 10:
                                if (!(this.subscribed == 'unsubscribed')) {
                                    _context2.next = 12;
                                    break;
                                }

                                throw new Error('Can\'t modify unsubscribed object');

                            case 12:
                                _context2.next = 14;
                                return this.services.session.addCommand('editUserAttributes', {
                                    username: this.state.identity,
                                    attributes: (0, _stringify2.default)(attributes)
                                });

                            case 14:
                                return _context2.abrupt("return", this);

                            case 15:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function updateAttributes(_x) {
                return _ref2.apply(this, arguments);
            }

            return updateAttributes;
        }()
        /**
         * Update Users friendlyName.
         * @param {String} friendlyName - Updated friendlyName
         * @returns {Promise<User|Error|SessionError>}
         */

    }, {
        key: "updateFriendlyName",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(friendlyName) {
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                if (!(friendlyName && typeof friendlyName !== 'string')) {
                                    _context3.next = 2;
                                    break;
                                }

                                throw new Error('friendlyName must be string or empty');

                            case 2:
                                if (!(this.subscribed == 'unsubscribed')) {
                                    _context3.next = 4;
                                    break;
                                }

                                throw new Error('Can\'t modify unsubscribed object');

                            case 4:
                                _context3.next = 6;
                                return this.services.session.addCommand('editUserFriendlyName', {
                                    username: this.state.identity,
                                    friendlyName: friendlyName
                                });

                            case 6:
                                return _context3.abrupt("return", this);

                            case 7:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function updateFriendlyName(_x2) {
                return _ref3.apply(this, arguments);
            }

            return updateFriendlyName;
        }()
        /**
         * Removes User from subscription list.
         * @returns {Promise<void>} Promise of completion
         */

    }, {
        key: "unsubscribe",
        value: function () {
            var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                if (!this.promiseToFetch) {
                                    _context4.next = 7;
                                    break;
                                }

                                _context4.next = 3;
                                return this.promiseToFetch;

                            case 3:
                                this.entity.close();
                                this.promiseToFetch = null;
                                this.subscribed = 'unsubscribed';
                                this.emit('userUnsubscribed', this);

                            case 7:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function unsubscribe() {
                return _ref4.apply(this, arguments);
            }

            return unsubscribe;
        }()
    }, {
        key: "identity",
        get: function get() {
            return this.state.identity;
        },
        set: function set(identity) {
            this.state.identity = identity;
        }
    }, {
        key: "entityName",
        set: function set(name) {
            this.state.entityName = name;
        }
    }, {
        key: "attributes",
        get: function get() {
            return this.state.attributes;
        }
    }, {
        key: "friendlyName",
        get: function get() {
            return this.state.friendlyName;
        }
    }, {
        key: "online",
        get: function get() {
            return this.state.online;
        }
    }, {
        key: "notifiable",
        get: function get() {
            return this.state.notifiable;
        }
    }, {
        key: "isSubscribed",
        get: function get() {
            return this.subscribed == 'subscribed';
        }
    }]);
    return User;
}(events_1.EventEmitter);

exports.User = User;
/**
 * Fired when User's properties or reachability status have been updated.
 * @event User#updated
 * @type {Object}
 * @property {User} user - Updated User
 * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons
 */
/**
 * Fired when Client is subscribed to User.
 * @event User#userSubscribed
 * @type {User}
 */
/**
 * Fired when Client is unsubscribed from this User.
 * @event User#userUnsubscribed
 * @type {User}
 */