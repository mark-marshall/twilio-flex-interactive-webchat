"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
var uuid = require("uuid");
var platform = require("platform");
var responsecodes_1 = require("./interfaces/responsecodes");
var logger_1 = require("./logger");
var sessionerror_1 = require("./sessionerror");
var deferred_1 = require("./util/deferred");
var iso8601_duration_1 = require("iso8601-duration");
var SDK_VERSION = require('./../package.json').version;
var SESSION_PURPOSE = 'com.twilio.rtd.ipmsg';
var log = logger_1.Logger.scope('Session');

var Command = function Command() {
    (0, _classCallCheck3.default)(this, Command);
};

function hasAllPropertiesSet(obj, properties) {
    return !properties.some(function (prop) {
        return !obj.hasOwnProperty(prop);
    });
}
/**
 *  Constructs the instance of Session
 *
 *  @classdesc Provides the interface to send the command to the server
 *  It is reliable, which means that it tracks the command object state
 *  and waits the answer from the server.
 */

var Session = function () {
    function Session(services, config) {
        (0, _classCallCheck3.default)(this, Session);

        var platformInfo = typeof navigator !== 'undefined' ? platform.parse(navigator.userAgent) : platform;
        this.services = services;
        this.config = config;
        this.sessionInfo = new deferred_1.Deferred();
        this.currentContext = {};
        this.pendingCommands = new _map2.default();
        this.sessionStreamPromise = null;
        this.endpointPlatform = ['js', SDK_VERSION, platformInfo.os, platformInfo.name, platformInfo.version].join('|');
    }

    (0, _createClass3.default)(Session, [{
        key: "handleContextUpdate",
        value: function handleContextUpdate(updatedContext) {
            log.info('Session context updated');
            log.debug('new session context:', updatedContext);
            this.currentContext = updatedContext;
            if (!hasAllPropertiesSet(updatedContext, ['identity', 'userInfo', 'links', 'myChannels', 'channels'])) {
                return; // not enough data to proceed, wait
            }
            log.info('new session context accepted');
            this.sessionInfo.set(updatedContext);
        }
    }, {
        key: "initialize",
        value: function initialize() {
            var _this = this;

            var context = {
                type: 'IpMsgSession',
                apiVersion: '3',
                endpointPlatform: this.endpointPlatform
            };
            this.sessionStreamPromise = this.services.syncClient.list({ purpose: SESSION_PURPOSE, context: context }).then(function (list) {
                log.info('Session created', list.sid);
                list.on('itemAdded', function (args) {
                    return _this.processCommandResponse(args.item);
                });
                list.on('itemUpdated', function (args) {
                    return _this.processCommandResponse(args.item);
                });
                list.on('contextUpdated', function (args) {
                    return _this.handleContextUpdate(args.context);
                });
                return list;
            }).catch(function (err) {
                log.error('Failed to create session', err);
                throw err;
            });
            return this.sessionStreamPromise;
        }
        /**
         * Sends the command to the server
         * @returns Promise the promise, which is being fulfilled only when service will reply
         */

    }, {
        key: "addCommand",
        value: function addCommand(action, params) {
            return this.processCommand(action, params);
        }
        /**
         * @private
         */

    }, {
        key: "processCommand",
        value: function processCommand(action, params) {
            var _this2 = this;

            var createSessionIfNotFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

            var command = new Command();
            command.request = params;
            command.request.action = action;
            command.commandId = uuid.v4();
            log.info('Adding command: ', action, command.commandId);
            log.debug('command arguments:', params, createSessionIfNotFound);
            return new _promise2.default(function (resolve, reject) {
                _this2.sessionStreamPromise.then(function (list) {
                    _this2.pendingCommands.set(command.commandId, { resolve: resolve, reject: reject, commandId: command.commandId, request: command.request });
                    return list.push(command);
                }).then(function () {
                    return log.debug('Command accepted by server', command.commandId);
                }).catch(function (err) {
                    _this2.pendingCommands.delete(command.commandId);
                    log.error('Failed to add a command to the session', err);
                    if ((err.code == responsecodes_1.ResponseCodes.ACCESS_FORBIDDEN_FOR_IDENTITY || err.code === responsecodes_1.ResponseCodes.LIST_NOT_FOUND) && createSessionIfNotFound) {
                        log.info('recreating session...');
                        _this2.initialize();
                        resolve(_this2.processCommand(action, params, false)); // second attempt
                    } else {
                        reject(new Error('Can\'t add command: ' + err.message));
                    }
                });
            });
        }
        /**
         * @private
         */

    }, {
        key: "processCommandResponse",
        value: function processCommandResponse(entity) {
            if (entity.value.hasOwnProperty('response') && entity.value.hasOwnProperty('commandId') && this.pendingCommands.has(entity.value.commandId)) {
                var value = entity.value;
                var commandId = entity.value.commandId;
                if (value.response.status === responsecodes_1.ResponseCodes.HTTP_200_OK) {
                    log.debug('Command succeeded: ', value);
                    var resolve = this.pendingCommands.get(commandId).resolve;
                    this.pendingCommands.delete(commandId);
                    resolve(value.response);
                } else {
                    log.error('Command failed: ', value);
                    var reject = this.pendingCommands.get(commandId).reject;
                    this.pendingCommands.delete(commandId);
                    reject(new sessionerror_1.SessionError(value.response.statusText, value.response.status));
                }
            }
        }
    }, {
        key: "getSessionContext",
        value: function getSessionContext() {
            return this.sessionStreamPromise.then(function (stream) {
                return stream.getContext();
            });
        }
    }, {
        key: "getSessionLinks",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var info;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this.sessionInfo.promise;

                            case 2:
                                info = _context.sent;
                                return _context.abrupt("return", {
                                    publicChannelsUrl: this.config.baseUrl + info.links.publicChannelsUrl,
                                    myChannelsUrl: this.config.baseUrl + info.links.myChannelsUrl,
                                    typingUrl: this.config.baseUrl + info.links.typingUrl,
                                    syncListUrl: this.config.baseUrl + info.links.syncListUrl,
                                    usersUrl: this.config.baseUrl + info.links.usersUrl,
                                    mediaServiceUrl: info.links.mediaServiceUrl
                                });

                            case 4:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function getSessionLinks() {
                return _ref.apply(this, arguments);
            }

            return getSessionLinks;
        }()
    }, {
        key: "getChannelsId",
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                var info;
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                _context2.next = 2;
                                return this.sessionInfo.promise;

                            case 2:
                                info = _context2.sent;
                                return _context2.abrupt("return", info.channels);

                            case 4:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function getChannelsId() {
                return _ref2.apply(this, arguments);
            }

            return getChannelsId;
        }()
    }, {
        key: "getMyChannelsId",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                var info;
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                _context3.next = 2;
                                return this.sessionInfo.promise;

                            case 2:
                                info = _context3.sent;
                                return _context3.abrupt("return", info.myChannels);

                            case 4:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function getMyChannelsId() {
                return _ref3.apply(this, arguments);
            }

            return getMyChannelsId;
        }()
    }, {
        key: "getMaxUserInfosToSubscribe",
        value: function () {
            var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
                var info;
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                _context4.next = 2;
                                return this.sessionInfo.promise;

                            case 2:
                                info = _context4.sent;
                                return _context4.abrupt("return", this.config.userInfosToSubscribeOverride || info.userInfosToSubscribe || this.config.userInfosToSubscribeDefault);

                            case 4:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function getMaxUserInfosToSubscribe() {
                return _ref4.apply(this, arguments);
            }

            return getMaxUserInfosToSubscribe;
        }()
    }, {
        key: "getUsersData",
        value: function getUsersData() {
            return this.sessionInfo.promise.then(function (info) {
                return {
                    user: info.userInfo,
                    identity: info.identity
                };
            });
        }
    }, {
        key: "getConsumptionReportInterval",
        value: function () {
            var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
                var context, consumptionIntervalToUse;
                return _regenerator2.default.wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                _context5.next = 2;
                                return this.getSessionContext();

                            case 2:
                                context = _context5.sent;
                                consumptionIntervalToUse = this.config.consumptionReportIntervalOverride || context.consumptionReportInterval || this.config.consumptionReportIntervalDefault;
                                _context5.prev = 4;
                                return _context5.abrupt("return", iso8601_duration_1.toSeconds(iso8601_duration_1.parse(consumptionIntervalToUse)));

                            case 8:
                                _context5.prev = 8;
                                _context5.t0 = _context5["catch"](4);

                                log.error('Failed to parse consumption report interval', consumptionIntervalToUse, 'using default value', this.config.consumptionReportIntervalDefault);
                                return _context5.abrupt("return", iso8601_duration_1.toSeconds(iso8601_duration_1.parse(this.config.consumptionReportIntervalDefault)));

                            case 12:
                            case "end":
                                return _context5.stop();
                        }
                    }
                }, _callee5, this, [[4, 8]]);
            }));

            function getConsumptionReportInterval() {
                return _ref5.apply(this, arguments);
            }

            return getConsumptionReportInterval;
        }()
    }, {
        key: "getHttpCacheInterval",
        value: function () {
            var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
                var context, cacheIntervalToUse;
                return _regenerator2.default.wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                _context6.next = 2;
                                return this.getSessionContext();

                            case 2:
                                context = _context6.sent;
                                cacheIntervalToUse = this.config.httpCacheIntervalOverride || context.httpCacheInterval || this.config.httpCacheIntervalDefault;
                                _context6.prev = 4;
                                return _context6.abrupt("return", iso8601_duration_1.toSeconds(iso8601_duration_1.parse(cacheIntervalToUse)));

                            case 8:
                                _context6.prev = 8;
                                _context6.t0 = _context6["catch"](4);

                                log.error('Failed to parse cache interval', cacheIntervalToUse, 'using default value', this.config.httpCacheIntervalDefault);
                                return _context6.abrupt("return", iso8601_duration_1.toSeconds(iso8601_duration_1.parse(this.config.httpCacheIntervalDefault)));

                            case 12:
                            case "end":
                                return _context6.stop();
                        }
                    }
                }, _callee6, this, [[4, 8]]);
            }));

            function getHttpCacheInterval() {
                return _ref6.apply(this, arguments);
            }

            return getHttpCacheInterval;
        }()
    }, {
        key: "identity",
        get: function get() {
            return this.sessionInfo.current.identity;
        }
    }, {
        key: "reachabilityEnabled",
        get: function get() {
            return this.currentContext.reachabilityEnabled;
        }
    }]);
    return Session;
}();

exports.Session = Session;