"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var logger_1 = require("./logger");
var configuration_1 = require("./configuration");
var user_1 = require("./user");
exports.User = user_1.User;
var publicchannels_1 = require("./data/publicchannels");
var network_1 = require("./services/network");
var notificationtypes_1 = require("./interfaces/notificationtypes");
var synclist_1 = require("./synclist");
var twilsock_1 = require("twilsock");
var twilio_notifications_1 = require("twilio-notifications");
var twilio_sync_1 = require("twilio-sync");
var twilio_mcs_client_1 = require("twilio-mcs-client");
var session_1 = require("./session");
var channels_1 = require("./data/channels");
var users_1 = require("./data/users");
var typingindicator_1 = require("./services/typingindicator");
var consumptionhorizon_1 = require("./services/consumptionhorizon");
var userchannels_1 = require("./data/userchannels");
var pushnotification_1 = require("./pushnotification");
exports.PushNotification = pushnotification_1.PushNotification;
var util_1 = require("./util");
var log = logger_1.Logger.scope('Client');
var SDK_VERSION = require('./../package.json').version;
var MSG_NO_TOKEN = 'A valid Twilio token should be provided';

var ClientServices = function ClientServices() {
    (0, _classCallCheck3.default)(this, ClientServices);
};
/**
 * A Client is a starting point to access Twilio Programmable Chat functionality.
 *
 * @property {Client#ConnectionState} connectionState - Client connection state
 * @property {Boolean} reachabilityEnabled - Client reachability state
 * @property {User} user - Information for logged in user
 * @property {String} version - Current version of Chat client
 *
 * @fires Client#connectionError
 * @fires Client#connectionStateChanged
 * @fires Client#channelAdded
 * @fires Client#channelInvited
 * @fires Client#channelJoined
 * @fires Client#channelLeft
 * @fires Client#channelRemoved
 * @fires Client#channelUpdated
 * @fires Client#memberJoined
 * @fires Client#memberLeft
 * @fires Client#memberUpdated
 * @fires Client#messageAdded
 * @fires Client#messageRemoved
 * @fires Client#messageUpdated
 * @fires Client#pushNotification
 * @fires Client#tokenAboutToExpire
 * @fires Client#tokenExpired
 * @fires Client#typingEnded
 * @fires Client#typingStarted
 * @fires Client#userSubscribed
 * @fires Client#userUnsubscribed
 * @fires Client#userUpdated
 */


var Client = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Client, _events_1$EventEmitte);

    /**
     * These options can be passed to Client constructor.
     * @typedef {Object} Client#ClientOptions
     * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
     *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
     */
    /**
     * These options can be passed to {@link Client#createChannel}.
     * @typedef {Object} Client#CreateChannelOptions
     * @property {Object} [attributes] - Any custom attributes to attach to the Channel
     * @property {String} [friendlyName] - The non-unique display name of the Channel
     * @property {Boolean} [isPrivate] - Whether or not this Channel should be visible to uninvited Clients
     * @property {String} [uniqueName] - The unique identity name of the Channel
     */
    /**
     * Connection state of Client.
     * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState
     */
    /**
     * Notifications channel type.
     * @typedef {('gcm'|'fcm'|'apn')} Client#NotificationsChannelType
     */
    /**
     * These options can be passed to {@link Client#getLocalChannels}.
     * @typedef {Object} Client#ChannelSortingOptions
     * @property {('lastMessage'|'friendlyName'|'uniqueName')} criteria - Sorting criteria for Channels array
     * @property {('ascending'|'descending')} [order] - Sorting order. If not present, then default is <code>ascending</code>
     */
    function Client(token, options) {
        (0, _classCallCheck3.default)(this, Client);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Client.__proto__ || (0, _getPrototypeOf2.default)(Client)).call(this));

        _this.connectionState = 'connecting';
        _this.sessionPromise = null;
        _this.channelsPromise = null;
        _this.version = SDK_VERSION;
        _this.parsePushNotification = Client.parsePushNotification;
        _this.options = options || {};
        if (!_this.options.disableDeepClone) {
            _this.options = util_1.deepClone(_this.options);
        }
        _this.options.logLevel = _this.options.logLevel || 'silent';
        log.setLevel(_this.options.logLevel);
        var productId = _this.options.productId = 'ip_messaging';
        // Filling ClientMetadata
        _this.options.clientMetadata = _this.options.clientMetadata || {};
        if (!_this.options.clientMetadata.hasOwnProperty('type')) {
            _this.options.clientMetadata.type = 'chat';
        }
        if (!_this.options.clientMetadata.hasOwnProperty('sdk')) {
            _this.options.clientMetadata.sdk = 'JS';
            _this.options.clientMetadata.sdkv = SDK_VERSION;
        }
        // Enable session local storage for Sync
        _this.options.Sync = _this.options.Sync || {};
        if (typeof _this.options.Sync.enableSessionStorage === 'undefined') {
            _this.options.Sync.enableSessionStorage = true;
        }
        if (_this.options.region) {
            _this.options.Sync.region = _this.options.region;
        }
        if (!token) {
            throw new Error(MSG_NO_TOKEN);
        }
        _this.services = new ClientServices();
        _this.config = new configuration_1.Configuration(_this.options);
        _this.options.twilsockClient = _this.options.twilsockClient || new twilsock_1.Twilsock(token, productId, _this.options);
        _this.options.transport = _this.options.transport || _this.options.twilsockClient;
        _this.options.notificationsClient = _this.options.notificationsClient || new twilio_notifications_1.Notifications(token, _this.options);
        _this.options.syncClient = _this.options.syncClient || new twilio_sync_1.SyncClient(token, _this.options);
        _this.services.syncClient = _this.options.syncClient;
        _this.services.transport = _this.options.transport;
        _this.services.twilsockClient = _this.options.twilsockClient;
        _this.services.notificationClient = _this.options.notificationsClient;
        _this.services.session = new session_1.Session(_this.services, _this.config);
        _this.sessionPromise = _this.services.session.initialize();
        _this.services.network = new network_1.Network(_this.config, _this.services);
        _this.services.users = new users_1.Users({
            session: _this.services.session,
            network: _this.services.network,
            syncClient: _this.services.syncClient
        });
        _this.services.users.on('userSubscribed', _this.emit.bind(_this, 'userSubscribed'));
        _this.services.users.on('userUpdated', function (args) {
            return _this.emit('userUpdated', args);
        });
        _this.services.users.on('userUnsubscribed', _this.emit.bind(_this, 'userUnsubscribed'));
        _this.services.twilsockClient.on('tokenAboutToExpire', function (ttl) {
            return _this.emit('tokenAboutToExpire', ttl);
        });
        _this.services.twilsockClient.on('tokenExpired', function () {
            return _this.emit('tokenExpired');
        });
        _this.services.twilsockClient.on('connectionError', function (error) {
            return _this.emit('connectionError', error);
        });
        _this.services.consumptionHorizon = new consumptionhorizon_1.ConsumptionHorizon(_this.services);
        _this.services.typingIndicator = new typingindicator_1.TypingIndicator(_this.config, {
            transport: _this.services.twilsockClient,
            notificationClient: _this.services.notificationClient
        }, _this.getChannelBySid.bind(_this));
        _this.services.syncList = new synclist_1.SyncList(_this.services);
        _this.channels = new channels_1.Channels(_this.services);
        _this.channelsPromise = _this.sessionPromise.then(function () {
            _this.channels.on('channelAdded', _this.emit.bind(_this, 'channelAdded'));
            _this.channels.on('channelRemoved', _this.emit.bind(_this, 'channelRemoved'));
            _this.channels.on('channelInvited', _this.emit.bind(_this, 'channelInvited'));
            _this.channels.on('channelJoined', _this.emit.bind(_this, 'channelJoined'));
            _this.channels.on('channelLeft', _this.emit.bind(_this, 'channelLeft'));
            _this.channels.on('channelUpdated', function (args) {
                return _this.emit('channelUpdated', args);
            });
            _this.channels.on('memberJoined', _this.emit.bind(_this, 'memberJoined'));
            _this.channels.on('memberLeft', _this.emit.bind(_this, 'memberLeft'));
            _this.channels.on('memberUpdated', function (args) {
                return _this.emit('memberUpdated', args);
            });
            _this.channels.on('messageAdded', _this.emit.bind(_this, 'messageAdded'));
            _this.channels.on('messageUpdated', function (args) {
                return _this.emit('messageUpdated', args);
            });
            _this.channels.on('messageRemoved', _this.emit.bind(_this, 'messageRemoved'));
            _this.channels.on('typingStarted', _this.emit.bind(_this, 'typingStarted'));
            _this.channels.on('typingEnded', _this.emit.bind(_this, 'typingEnded'));
            return _this.channels.fetchChannels();
        }).then(function () {
            return _this.channels;
        });
        _this.services.notificationClient.on('connectionStateChanged', function (state) {
            var changedConnectionState = null;
            switch (state) {
                case 'connected':
                    changedConnectionState = 'connected';
                    break;
                case 'denied':
                    changedConnectionState = 'denied';
                    break;
                case 'disconnecting':
                    changedConnectionState = 'disconnecting';
                    break;
                case 'disconnected':
                    changedConnectionState = 'disconnected';
                    break;
                default:
                    changedConnectionState = 'connecting';
            }
            if (changedConnectionState !== _this.connectionState) {
                _this.connectionState = changedConnectionState;
                _this.emit('connectionStateChanged', _this.connectionState);
            }
        });
        _this.fpaToken = token;
        return _this;
    }
    /**
     * Factory method to create Chat client instance.
     *
     * @param {String} token - Access token
     * @param {Client#ClientOptions} options - Options to customize the Client
     * @returns {Promise<Client>}
     */


    (0, _createClass3.default)(Client, [{
        key: "subscribeToPushNotifications",
        value: function subscribeToPushNotifications(channelType) {
            var _this2 = this;

            var subscriptions = [];
            [notificationtypes_1.NotificationTypes.NEW_MESSAGE, notificationtypes_1.NotificationTypes.ADDED_TO_CHANNEL, notificationtypes_1.NotificationTypes.INVITED_TO_CHANNEL, notificationtypes_1.NotificationTypes.REMOVED_FROM_CHANNEL, notificationtypes_1.NotificationTypes.TYPING_INDICATOR, notificationtypes_1.NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {
                subscriptions.push(_this2.services.notificationClient.subscribe(messageType, channelType));
            });
            return _promise2.default.all(subscriptions);
        }
    }, {
        key: "unsubscribeFromPushNotifications",
        value: function unsubscribeFromPushNotifications(channelType) {
            var _this3 = this;

            var subscriptions = [];
            [notificationtypes_1.NotificationTypes.NEW_MESSAGE, notificationtypes_1.NotificationTypes.ADDED_TO_CHANNEL, notificationtypes_1.NotificationTypes.INVITED_TO_CHANNEL, notificationtypes_1.NotificationTypes.REMOVED_FROM_CHANNEL, notificationtypes_1.NotificationTypes.TYPING_INDICATOR, notificationtypes_1.NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {
                subscriptions.push(_this3.services.notificationClient.unsubscribe(messageType, channelType));
            });
            return _promise2.default.all(subscriptions);
        }
    }, {
        key: "initialize",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var _this4 = this;

                var links, options;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this.sessionPromise;

                            case 2:
                                Client.supportedPushChannels.forEach(function (channelType) {
                                    return _this4.subscribeToPushNotifications(channelType);
                                });
                                _context.next = 5;
                                return this.services.session.getSessionLinks();

                            case 5:
                                links = _context.sent;

                                this.services.publicChannels = new publicchannels_1.PublicChannels(this, this.services, links.publicChannelsUrl);
                                this.services.userChannels = new userchannels_1.UserChannels(this, this.services, links.myChannelsUrl);
                                options = (0, _assign2.default)(this.options);

                                options.transport = null;
                                this.services.mcsClient = new twilio_mcs_client_1.McsClient(this.fpaToken, links.mediaServiceUrl, options);
                                _context.next = 13;
                                return this.services.typingIndicator.initialize();

                            case 13:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function initialize() {
                return _ref.apply(this, arguments);
            }

            return initialize;
        }()
        /**
         * Gracefully shutting down library instance.
         * @public
         * @returns {Promise<void>}
         */

    }, {
        key: "shutdown",
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                _context2.next = 2;
                                return this.services.twilsockClient.disconnect();

                            case 2:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function shutdown() {
                return _ref2.apply(this, arguments);
            }

            return shutdown;
        }()
        /**
         * Update the token used by the Client and re-register with Programmable Chat services.
         * @param {String} token - Access token
         * @public
         * @returns {Promise<Client>}
         */

    }, {
        key: "updateToken",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(token) {
                var _this5 = this;

                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                log.info('updateToken');

                                if (token) {
                                    _context3.next = 3;
                                    break;
                                }

                                throw new Error(MSG_NO_TOKEN);

                            case 3:
                                if (!(this.fpaToken === token)) {
                                    _context3.next = 5;
                                    break;
                                }

                                return _context3.abrupt("return", this);

                            case 5:
                                _context3.next = 7;
                                return this.services.twilsockClient.updateToken(token).then(function () {
                                    return _this5.fpaToken = token;
                                }).then(function () {
                                    return _this5.services.mcsClient.updateToken(token);
                                }).then(function () {
                                    return _this5.sessionPromise;
                                });

                            case 7:
                                return _context3.abrupt("return", this);

                            case 8:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function updateToken(_x) {
                return _ref3.apply(this, arguments);
            }

            return updateToken;
        }()
        /**
         * Get a known Channel by its SID.
         * @param {String} channelSid - Channel sid
         * @returns {Promise<Channel>}
         */

    }, {
        key: "getChannelBySid",
        value: function () {
            var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(channelSid) {
                var _this6 = this;

                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                if (!(!channelSid || typeof channelSid !== 'string')) {
                                    _context4.next = 2;
                                    break;
                                }

                                throw new Error('Client.getChannelBySid requires a <String>channelSid parameter');

                            case 2:
                                return _context4.abrupt("return", this.channels.syncListRead.promise.then(function () {
                                    return _this6.channels.getChannel(channelSid).then(function (channel) {
                                        return channel || _this6.services.publicChannels.getChannelBySid(channelSid).then(function (x) {
                                            return _this6.channels.pushChannel(x);
                                        });
                                    });
                                }));

                            case 3:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function getChannelBySid(_x2) {
                return _ref4.apply(this, arguments);
            }

            return getChannelBySid;
        }()
        /**
         * Get a known Channel by its unique identifier name.
         * @param {String} uniqueName - The unique identifier name of the Channel to get
         * @returns {Promise<Channel>}
         */

    }, {
        key: "getChannelByUniqueName",
        value: function () {
            var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(uniqueName) {
                var _this7 = this;

                return _regenerator2.default.wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                if (!(!uniqueName || typeof uniqueName !== 'string')) {
                                    _context5.next = 2;
                                    break;
                                }

                                throw new Error('Client.getChannelByUniqueName requires a <String>uniqueName parameter');

                            case 2:
                                return _context5.abrupt("return", this.channels.syncListRead.promise.then(function () {
                                    return _this7.services.publicChannels.getChannelByUniqueName(uniqueName).then(function (x) {
                                        return _this7.channels.pushChannel(x);
                                    });
                                }));

                            case 3:
                            case "end":
                                return _context5.stop();
                        }
                    }
                }, _callee5, this);
            }));

            function getChannelByUniqueName(_x3) {
                return _ref5.apply(this, arguments);
            }

            return getChannelByUniqueName;
        }()
        /**
         * Get the current list of all subscribed Channels.
         * @returns {Promise<Paginator<Channel>>}
         */

    }, {
        key: "getSubscribedChannels",
        value: function getSubscribedChannels(args) {
            return this.channelsPromise.then(function (channels) {
                return channels.getChannels(args);
            });
        }
        /**
         * Get array of Channels locally known to Client in provided sorting order.
         * Locally known channels are the ones created and/or joined during client runtime and currently logged in User subscribed Channels.
         * To ensure full list of subscribed Channels fetched - call the {@link Client#getSubscribedChannels} method
         * and fetch all pages with help of {@link Paginator#nextPage} method.
         * @param {Client#ChannelSortingOptions} [sortingOptions] - Options for the Channel sorting
         * @returns {Promise<Array<Channel>>}
         */

    }, {
        key: "getLocalChannels",
        value: function getLocalChannels(sortingOptions) {
            return this.channelsPromise.then(function (channels) {
                var result = [];
                channels.channels.forEach(function (value) {
                    result.push(value);
                });
                var sortingOrder = 'ascending';
                if (sortingOptions && sortingOptions.order) {
                    if (sortingOptions.order === 'descending') {
                        sortingOrder = 'descending';
                    } else if (sortingOptions.order !== 'ascending') {
                        throw new Error('Sorting order should be `ascending` or `descending`');
                    }
                }
                if (sortingOptions && sortingOptions.criteria) {
                    if (sortingOptions.criteria === 'lastMessage') {
                        result.sort(function (a, b) {
                            return Client.compareChannelsByLastMessage(a, b, sortingOrder);
                        });
                    } else if (sortingOptions.criteria === 'uniqueName') {
                        result.sort(function (a, b) {
                            return Client.compareChannelsByStringProperty(a.uniqueName, b.uniqueName, sortingOrder);
                        });
                    } else if (sortingOptions.criteria === 'friendlyName') {
                        result.sort(function (a, b) {
                            return Client.compareChannelsByStringProperty(a.friendlyName, b.friendlyName, sortingOrder);
                        });
                    } else {
                        throw new Error('Sorting criteria should be one of `lastMessage`, `uniqueName` or `friendlyName`');
                    }
                }
                return result;
            });
        }
    }, {
        key: "getPublicChannelDescriptors",

        /**
         * Get the public channels directory content.
         * @returns {Promise<Paginator<ChannelDescriptor>>}
         */
        value: function getPublicChannelDescriptors() {
            return this.services.publicChannels.getChannels();
        }
        /**
         * Get the User's (created by, joined or invited to) channels directory content.
         * @returns {Promise<Paginator<ChannelDescriptor>>}
         */

    }, {
        key: "getUserChannelDescriptors",
        value: function getUserChannelDescriptors() {
            return this.services.userChannels.getChannels();
        }
        /**
         * Create a Channel on the server and subscribe to its events.
         * Default options are public Channel type with empty uniqueName and friendlyName.
         * @param {Client#CreateChannelOptions} [options] - Options for the Channel
         * @returns {Promise<Channel>}
         */

    }, {
        key: "createChannel",
        value: function createChannel(options) {
            options = options || {};
            return this.channelsPromise.then(function (channelsEntity) {
                return channelsEntity.addChannel(options);
            });
        }
        /**
         * Registers for push notifications.
         * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported
         * @param {string} registrationId - Push notification id provided by platform
         * @returns {Promise<void>}
         */

    }, {
        key: "setPushRegistrationId",
        value: function () {
            var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(channelType, registrationId) {
                var _this8 = this;

                return _regenerator2.default.wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                if (!(Client.supportedPushChannels.indexOf(channelType) === -1)) {
                                    _context6.next = 2;
                                    break;
                                }

                                throw new Error('Invalid or unsupported channelType: ' + channelType);

                            case 2:
                                _context6.next = 4;
                                return this.subscribeToPushNotifications(channelType).then(function () {
                                    return _this8.services.notificationClient.setPushRegistrationId(registrationId, channelType);
                                });

                            case 4:
                            case "end":
                                return _context6.stop();
                        }
                    }
                }, _callee6, this);
            }));

            function setPushRegistrationId(_x4, _x5) {
                return _ref6.apply(this, arguments);
            }

            return setPushRegistrationId;
        }()
        /**
         * Unregisters from push notifications.
         * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported
         * @returns {Promise<void>}
         */

    }, {
        key: "unsetPushRegistrationId",
        value: function () {
            var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(channelType) {
                return _regenerator2.default.wrap(function _callee7$(_context7) {
                    while (1) {
                        switch (_context7.prev = _context7.next) {
                            case 0:
                                if (!(Client.supportedPushChannels.indexOf(channelType) === -1)) {
                                    _context7.next = 2;
                                    break;
                                }

                                throw new Error('Invalid or unsupported channelType: ' + channelType);

                            case 2:
                                _context7.next = 4;
                                return this.unsubscribeFromPushNotifications(channelType);

                            case 4:
                            case "end":
                                return _context7.stop();
                        }
                    }
                }, _callee7, this);
            }));

            function unsetPushRegistrationId(_x6) {
                return _ref7.apply(this, arguments);
            }

            return unsetPushRegistrationId;
        }()
    }, {
        key: "handlePushNotification",

        /**
         * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.
         * @param {Object} notificationPayload - Push notification payload
         * @returns {void|Error}
         */
        value: function () {
            var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(notificationPayload) {
                return _regenerator2.default.wrap(function _callee8$(_context8) {
                    while (1) {
                        switch (_context8.prev = _context8.next) {
                            case 0:
                                log.debug('handlePushNotification, notificationPayload=', notificationPayload);
                                this.emit('pushNotification', Client.parsePushNotification(notificationPayload));

                            case 2:
                            case "end":
                                return _context8.stop();
                        }
                    }
                }, _callee8, this);
            }));

            function handlePushNotification(_x7) {
                return _ref8.apply(this, arguments);
            }

            return handlePushNotification;
        }()
        /**
         * Gets user for given identity, if it's in subscribed list - then return the user object from it,
         * if not - then subscribes and adds user to the subscribed list.
         * @param {String} identity - Identity of User
         * @returns {Promise<User>} Fully initialized user
         */

    }, {
        key: "getUser",
        value: function getUser(identity) {
            return this.services.users.getUser(identity);
        }
        /**
         * Gets user descriptor for given identity.
         * @param {String} identity - Identity of User
         * @returns {Promise<UserDescriptor>} User descriptor
         */

    }, {
        key: "getUserDescriptor",
        value: function () {
            var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9(identity) {
                return _regenerator2.default.wrap(function _callee9$(_context9) {
                    while (1) {
                        switch (_context9.prev = _context9.next) {
                            case 0:
                                return _context9.abrupt("return", this.services.users.getUserDescriptor(identity));

                            case 1:
                            case "end":
                                return _context9.stop();
                        }
                    }
                }, _callee9, this);
            }));

            function getUserDescriptor(_x8) {
                return _ref9.apply(this, arguments);
            }

            return getUserDescriptor;
        }()
        /**
         * @returns {Promise<Array<User>>} List of subscribed User objects
         */

    }, {
        key: "getSubscribedUsers",
        value: function () {
            var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10() {
                return _regenerator2.default.wrap(function _callee10$(_context10) {
                    while (1) {
                        switch (_context10.prev = _context10.next) {
                            case 0:
                                return _context10.abrupt("return", this.services.users.getSubscribedUsers());

                            case 1:
                            case "end":
                                return _context10.stop();
                        }
                    }
                }, _callee10, this);
            }));

            function getSubscribedUsers() {
                return _ref10.apply(this, arguments);
            }

            return getSubscribedUsers;
        }()
    }, {
        key: "user",
        get: function get() {
            return this.services.users.myself;
        }
    }, {
        key: "reachabilityEnabled",
        get: function get() {
            return this.services.session.reachabilityEnabled;
        }
    }, {
        key: "token",
        get: function get() {
            return this.fpaToken;
        }
    }], [{
        key: "create",
        value: function () {
            var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(token, options) {
                var client;
                return _regenerator2.default.wrap(function _callee11$(_context11) {
                    while (1) {
                        switch (_context11.prev = _context11.next) {
                            case 0:
                                client = new Client(token, options);
                                _context11.next = 3;
                                return client.initialize();

                            case 3:
                                return _context11.abrupt("return", client);

                            case 4:
                            case "end":
                                return _context11.stop();
                        }
                    }
                }, _callee11, this);
            }));

            function create(_x9, _x10) {
                return _ref11.apply(this, arguments);
            }

            return create;
        }()
    }, {
        key: "compareChannelsByLastMessage",
        value: function compareChannelsByLastMessage(a, b, order) {
            if (a.lastMessage && b.lastMessage) {
                if (a.lastMessage.timestamp && b.lastMessage.timestamp) {
                    if (a.lastMessage.timestamp.getTime() < b.lastMessage.timestamp.getTime()) {
                        return order === 'ascending' ? -1 : 1;
                    } else {
                        return order === 'ascending' ? 1 : -1;
                    }
                } else {
                    if (a.lastMessage.timestamp) {
                        return -1;
                    } else if (b.lastMessage.timestamp) {
                        return 1;
                    }
                }
            }
            if (a.lastMessage) {
                return -1;
            } else if (b.lastMessage) {
                return 1;
            }
            return 0;
        }
    }, {
        key: "compareChannelsByStringProperty",
        value: function compareChannelsByStringProperty(str1, str2, order) {
            if (str1 && str2) {
                return order === 'ascending' ? str1.localeCompare(str2) : -1 * str1.localeCompare(str2);
            } else if (str1) {
                return -1;
            } else if (str2) {
                return 1;
            }
            return 0;
        }
    }, {
        key: "parsePushNotificationChatData",
        value: function parsePushNotificationChatData(data) {
            var result = {};
            for (var key in Client.supportedPushDataFields) {
                if (typeof data[key] !== 'undefined' && data[key] !== null) {
                    if (key === 'message_index') {
                        if (util_1.parseToNumber(data[key]) !== null) {
                            result[Client.supportedPushDataFields[key]] = Number(data[key]);
                        }
                    } else {
                        result[Client.supportedPushDataFields[key]] = data[key];
                    }
                }
            }
            return result;
        }
        /**
         * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object
         * @param {Object} notificationPayload - Push notification payload
         * @returns {PushNotification|Error}
         */

    }, {
        key: "parsePushNotification",
        value: function parsePushNotification(notificationPayload) {
            log.debug('parsePushNotification, notificationPayload=', notificationPayload);
            if (typeof notificationPayload === 'undefined' || notificationPayload === null) {
                throw new Error('Push notification payload should be provided');
            }
            // APNS specifics
            if (typeof notificationPayload.aps !== 'undefined') {
                if (!notificationPayload.twi_message_type) {
                    throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
                }
                var data = Client.parsePushNotificationChatData(notificationPayload);
                var apsPayload = notificationPayload.aps;
                var body = null;
                var title = null;
                if (typeof apsPayload.alert === 'string') {
                    body = apsPayload.alert || null;
                } else {
                    body = apsPayload.alert.body || null;
                    title = apsPayload.alert.title || null;
                }
                return new pushnotification_1.PushNotification({
                    title: title,
                    body: body,
                    sound: apsPayload.sound || null,
                    badge: apsPayload.badge || null,
                    action: apsPayload.category || null,
                    type: notificationPayload.twi_message_type,
                    data: data
                });
            }
            // FCM/GCM specifics
            if (typeof notificationPayload.data !== 'undefined') {
                var dataPayload = notificationPayload.data;
                if (!dataPayload.twi_message_type) {
                    throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
                }
                var _data = Client.parsePushNotificationChatData(notificationPayload.data);
                return new pushnotification_1.PushNotification({
                    title: dataPayload.twi_title || null,
                    body: dataPayload.twi_body || null,
                    sound: dataPayload.twi_sound || null,
                    badge: null,
                    action: dataPayload.twi_action || null,
                    type: dataPayload.twi_message_type,
                    data: _data
                });
            }
            throw new Error('Provided push notification payload is not Programmable Chat notification');
        }
    }]);
    return Client;
}(events_1.EventEmitter);

exports.Client = Client;
Client.version = SDK_VERSION;
Client.supportedPushChannels = ['fcm', 'apn', 'gcm'];
Client.supportedPushDataFields = {
    'channel_sid': 'channelSid',
    'message_sid': 'messageSid',
    'message_index': 'messageIndex'
};
exports.default = Client;
/**
 * Fired when a Channel becomes visible to the Client.
 * Fired for created and not joined private channels and for all type of channels Client has joined or invited to.
 * @event Client#channelAdded
 * @type {Channel}
 */
/**
 * Fired when the Client is invited to a Channel.
 * @event Client#channelInvited
 * @type {Channel}
 */
/**
 * Fired when the Client joins a Channel.
 * @event Client#channelJoined
 * @type {Channel}
 */
/**
 * Fired when the Client leaves a Channel.
 * @event Client#channelLeft
 * @type {Channel}
 */
/**
 * Fired when a Channel is no longer visible to the Client.
 * @event Client#channelRemoved
 * @type {Channel}
 */
/**
 * Fired when a Channel's attributes or metadata have been updated.
 * During Channel's {@link Client.create| creation and initialization} this event might be fired multiple times
 * for same joined or created Channel as new data is arriving from different sources.
 * @event Client#channelUpdated
 * @type {Object}
 * @property {Channel} channel - Updated Channel
 * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons
 */
/**
 * Fired when Client's connection state has been changed.
 * @event Client#connectionStateChanged
 * @type {Client#ConnectionState}
 */
/**
 * Fired when a Member has joined the Channel.
 * @event Client#memberJoined
 * @type {Member}
 */
/**
 * Fired when a Member has left the Channel.
 * @event Client#memberLeft
 * @type {Member}
 */
/**
 * Fired when a Member's fields has been updated.
 * @event Client#memberUpdated
 * @type {Object}
 * @property {Member} member - Updated Member
 * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Channel on the server.
 * @event Client#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Channel's message list.
 * @event Client#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Client#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when token is about to expire and needs to be updated.
 * @event Client#tokenAboutToExpire
 * @type {void}
 */
/**
 * Fired when token is expired.
 * @event Client#tokenExpired
 * @type {void}
 */
/**
 * Fired when a Member has stopped typing.
 * @event Client#typingEnded
 * @type {Member}
 */
/**
 * Fired when a Member has started typing.
 * @event Client#typingStarted
 * @type {Member}
 */
/**
 * Fired when client received (and parsed) push notification via one of push channels (apn, gcm, fcm).
 * @event Client#pushNotification
 * @type {PushNotification}
 */
/**
 * Fired when the Client is subscribed to a User.
 * @event Client#userSubscribed
 * @type {User}
 */
/**
 * Fired when the Client is unsubscribed from a User.
 * @event Client#userUnsubscribed
 * @type {User}
 */
/**
 * Fired when the User's properties or reachability status have been updated.
 * @event Client#userUpdated
 * @type {Object}
 * @property {User} user - Updated User
 * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons
 */
/**
 * Fired when connection is interrupted by unexpected reason
 * @event Client#connectionError
 * @type {Object}
 * @property {Boolean} terminal - twilsock will stop connection attempts
 * @property {String} message - root cause
 * @property {Number} [httpStatusCode] - http status code if available
 * @property {Number} [errorCode] - Twilio public error code if available
 */